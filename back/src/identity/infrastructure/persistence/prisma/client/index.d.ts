
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model Banque
 * 
 */
export type Banque = $Result.DefaultSelection<Prisma.$BanquePayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model LigneCredit
 * 
 */
export type LigneCredit = $Result.DefaultSelection<Prisma.$LigneCreditPayload>
/**
 * Model Garantie
 * 
 */
export type Garantie = $Result.DefaultSelection<Prisma.$GarantiePayload>
/**
 * Model Engagement
 * 
 */
export type Engagement = $Result.DefaultSelection<Prisma.$EngagementPayload>
/**
 * Model StepCompletion
 * 
 */
export type StepCompletion = $Result.DefaultSelection<Prisma.$StepCompletionPayload>
/**
 * Model SwiftMessage
 * 
 */
export type SwiftMessage = $Result.DefaultSelection<Prisma.$SwiftMessagePayload>
/**
 * Model DocumentImport
 * 
 */
export type DocumentImport = $Result.DefaultSelection<Prisma.$DocumentImportPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model BusinessUnit
 * 
 */
export type BusinessUnit = $Result.DefaultSelection<Prisma.$BusinessUnitPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model CompanySupplier
 * 
 */
export type CompanySupplier = $Result.DefaultSelection<Prisma.$CompanySupplierPayload>
/**
 * Model BusinessUnitSupplier
 * 
 */
export type BusinessUnitSupplier = $Result.DefaultSelection<Prisma.$BusinessUnitSupplierPayload>
/**
 * Model CompanyBanque
 * 
 */
export type CompanyBanque = $Result.DefaultSelection<Prisma.$CompanyBanquePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model WorkflowTemplate
 * 
 */
export type WorkflowTemplate = $Result.DefaultSelection<Prisma.$WorkflowTemplatePayload>
/**
 * Model WorkflowStep
 * 
 */
export type WorkflowStep = $Result.DefaultSelection<Prisma.$WorkflowStepPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.banque`: Exposes CRUD operations for the **Banque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banques
    * const banques = await prisma.banque.findMany()
    * ```
    */
  get banque(): Prisma.BanqueDelegate<ExtArgs>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs>;

  /**
   * `prisma.ligneCredit`: Exposes CRUD operations for the **LigneCredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneCredits
    * const ligneCredits = await prisma.ligneCredit.findMany()
    * ```
    */
  get ligneCredit(): Prisma.LigneCreditDelegate<ExtArgs>;

  /**
   * `prisma.garantie`: Exposes CRUD operations for the **Garantie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Garanties
    * const garanties = await prisma.garantie.findMany()
    * ```
    */
  get garantie(): Prisma.GarantieDelegate<ExtArgs>;

  /**
   * `prisma.engagement`: Exposes CRUD operations for the **Engagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Engagements
    * const engagements = await prisma.engagement.findMany()
    * ```
    */
  get engagement(): Prisma.EngagementDelegate<ExtArgs>;

  /**
   * `prisma.stepCompletion`: Exposes CRUD operations for the **StepCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StepCompletions
    * const stepCompletions = await prisma.stepCompletion.findMany()
    * ```
    */
  get stepCompletion(): Prisma.StepCompletionDelegate<ExtArgs>;

  /**
   * `prisma.swiftMessage`: Exposes CRUD operations for the **SwiftMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SwiftMessages
    * const swiftMessages = await prisma.swiftMessage.findMany()
    * ```
    */
  get swiftMessage(): Prisma.SwiftMessageDelegate<ExtArgs>;

  /**
   * `prisma.documentImport`: Exposes CRUD operations for the **DocumentImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentImports
    * const documentImports = await prisma.documentImport.findMany()
    * ```
    */
  get documentImport(): Prisma.DocumentImportDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.businessUnit`: Exposes CRUD operations for the **BusinessUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnits
    * const businessUnits = await prisma.businessUnit.findMany()
    * ```
    */
  get businessUnit(): Prisma.BusinessUnitDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.companySupplier`: Exposes CRUD operations for the **CompanySupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanySuppliers
    * const companySuppliers = await prisma.companySupplier.findMany()
    * ```
    */
  get companySupplier(): Prisma.CompanySupplierDelegate<ExtArgs>;

  /**
   * `prisma.businessUnitSupplier`: Exposes CRUD operations for the **BusinessUnitSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnitSuppliers
    * const businessUnitSuppliers = await prisma.businessUnitSupplier.findMany()
    * ```
    */
  get businessUnitSupplier(): Prisma.BusinessUnitSupplierDelegate<ExtArgs>;

  /**
   * `prisma.companyBanque`: Exposes CRUD operations for the **CompanyBanque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyBanques
    * const companyBanques = await prisma.companyBanque.findMany()
    * ```
    */
  get companyBanque(): Prisma.CompanyBanqueDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.workflowTemplate`: Exposes CRUD operations for the **WorkflowTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowTemplates
    * const workflowTemplates = await prisma.workflowTemplate.findMany()
    * ```
    */
  get workflowTemplate(): Prisma.WorkflowTemplateDelegate<ExtArgs>;

  /**
   * `prisma.workflowStep`: Exposes CRUD operations for the **WorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowSteps
    * const workflowSteps = await prisma.workflowStep.findMany()
    * ```
    */
  get workflowStep(): Prisma.WorkflowStepDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    Banque: 'Banque',
    BankAccount: 'BankAccount',
    LigneCredit: 'LigneCredit',
    Garantie: 'Garantie',
    Engagement: 'Engagement',
    StepCompletion: 'StepCompletion',
    SwiftMessage: 'SwiftMessage',
    DocumentImport: 'DocumentImport',
    Company: 'Company',
    BusinessUnit: 'BusinessUnit',
    Supplier: 'Supplier',
    CompanySupplier: 'CompanySupplier',
    BusinessUnitSupplier: 'BusinessUnitSupplier',
    CompanyBanque: 'CompanyBanque',
    Role: 'Role',
    Permission: 'Permission',
    UserRole: 'UserRole',
    RolePermission: 'RolePermission',
    AuditLog: 'AuditLog',
    WorkflowTemplate: 'WorkflowTemplate',
    WorkflowStep: 'WorkflowStep'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "banque" | "bankAccount" | "ligneCredit" | "garantie" | "engagement" | "stepCompletion" | "swiftMessage" | "documentImport" | "company" | "businessUnit" | "supplier" | "companySupplier" | "businessUnitSupplier" | "companyBanque" | "role" | "permission" | "userRole" | "rolePermission" | "auditLog" | "workflowTemplate" | "workflowStep"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Banque: {
        payload: Prisma.$BanquePayload<ExtArgs>
        fields: Prisma.BanqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BanqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BanqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          findFirst: {
            args: Prisma.BanqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BanqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          findMany: {
            args: Prisma.BanqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>[]
          }
          create: {
            args: Prisma.BanqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          createMany: {
            args: Prisma.BanqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BanqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          update: {
            args: Prisma.BanqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          deleteMany: {
            args: Prisma.BanqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BanqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BanqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanquePayload>
          }
          aggregate: {
            args: Prisma.BanqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanque>
          }
          groupBy: {
            args: Prisma.BanqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<BanqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.BanqueCountArgs<ExtArgs>
            result: $Utils.Optional<BanqueCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      LigneCredit: {
        payload: Prisma.$LigneCreditPayload<ExtArgs>
        fields: Prisma.LigneCreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneCreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneCreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          findFirst: {
            args: Prisma.LigneCreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneCreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          findMany: {
            args: Prisma.LigneCreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>[]
          }
          create: {
            args: Prisma.LigneCreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          createMany: {
            args: Prisma.LigneCreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneCreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          update: {
            args: Prisma.LigneCreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          deleteMany: {
            args: Prisma.LigneCreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneCreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneCreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCreditPayload>
          }
          aggregate: {
            args: Prisma.LigneCreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneCredit>
          }
          groupBy: {
            args: Prisma.LigneCreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneCreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneCreditCountArgs<ExtArgs>
            result: $Utils.Optional<LigneCreditCountAggregateOutputType> | number
          }
        }
      }
      Garantie: {
        payload: Prisma.$GarantiePayload<ExtArgs>
        fields: Prisma.GarantieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GarantieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GarantieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          findFirst: {
            args: Prisma.GarantieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GarantieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          findMany: {
            args: Prisma.GarantieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>[]
          }
          create: {
            args: Prisma.GarantieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          createMany: {
            args: Prisma.GarantieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GarantieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          update: {
            args: Prisma.GarantieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          deleteMany: {
            args: Prisma.GarantieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GarantieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GarantieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GarantiePayload>
          }
          aggregate: {
            args: Prisma.GarantieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGarantie>
          }
          groupBy: {
            args: Prisma.GarantieGroupByArgs<ExtArgs>
            result: $Utils.Optional<GarantieGroupByOutputType>[]
          }
          count: {
            args: Prisma.GarantieCountArgs<ExtArgs>
            result: $Utils.Optional<GarantieCountAggregateOutputType> | number
          }
        }
      }
      Engagement: {
        payload: Prisma.$EngagementPayload<ExtArgs>
        fields: Prisma.EngagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EngagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EngagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          findFirst: {
            args: Prisma.EngagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EngagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          findMany: {
            args: Prisma.EngagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>[]
          }
          create: {
            args: Prisma.EngagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          createMany: {
            args: Prisma.EngagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EngagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          update: {
            args: Prisma.EngagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          deleteMany: {
            args: Prisma.EngagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EngagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EngagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementPayload>
          }
          aggregate: {
            args: Prisma.EngagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEngagement>
          }
          groupBy: {
            args: Prisma.EngagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EngagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EngagementCountArgs<ExtArgs>
            result: $Utils.Optional<EngagementCountAggregateOutputType> | number
          }
        }
      }
      StepCompletion: {
        payload: Prisma.$StepCompletionPayload<ExtArgs>
        fields: Prisma.StepCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StepCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StepCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          findFirst: {
            args: Prisma.StepCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StepCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          findMany: {
            args: Prisma.StepCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>[]
          }
          create: {
            args: Prisma.StepCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          createMany: {
            args: Prisma.StepCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StepCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          update: {
            args: Prisma.StepCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          deleteMany: {
            args: Prisma.StepCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StepCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StepCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StepCompletionPayload>
          }
          aggregate: {
            args: Prisma.StepCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStepCompletion>
          }
          groupBy: {
            args: Prisma.StepCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StepCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StepCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<StepCompletionCountAggregateOutputType> | number
          }
        }
      }
      SwiftMessage: {
        payload: Prisma.$SwiftMessagePayload<ExtArgs>
        fields: Prisma.SwiftMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SwiftMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SwiftMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          findFirst: {
            args: Prisma.SwiftMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SwiftMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          findMany: {
            args: Prisma.SwiftMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>[]
          }
          create: {
            args: Prisma.SwiftMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          createMany: {
            args: Prisma.SwiftMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SwiftMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          update: {
            args: Prisma.SwiftMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          deleteMany: {
            args: Prisma.SwiftMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SwiftMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SwiftMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwiftMessagePayload>
          }
          aggregate: {
            args: Prisma.SwiftMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSwiftMessage>
          }
          groupBy: {
            args: Prisma.SwiftMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SwiftMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SwiftMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SwiftMessageCountAggregateOutputType> | number
          }
        }
      }
      DocumentImport: {
        payload: Prisma.$DocumentImportPayload<ExtArgs>
        fields: Prisma.DocumentImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          findFirst: {
            args: Prisma.DocumentImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          findMany: {
            args: Prisma.DocumentImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>[]
          }
          create: {
            args: Prisma.DocumentImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          createMany: {
            args: Prisma.DocumentImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          update: {
            args: Prisma.DocumentImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          deleteMany: {
            args: Prisma.DocumentImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentImportPayload>
          }
          aggregate: {
            args: Prisma.DocumentImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentImport>
          }
          groupBy: {
            args: Prisma.DocumentImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentImportCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentImportCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnit: {
        payload: Prisma.$BusinessUnitPayload<ExtArgs>
        fields: Prisma.BusinessUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BusinessUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          update: {
            args: Prisma.BusinessUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnit>
          }
          groupBy: {
            args: Prisma.BusinessUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      CompanySupplier: {
        payload: Prisma.$CompanySupplierPayload<ExtArgs>
        fields: Prisma.CompanySupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanySupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanySupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          findFirst: {
            args: Prisma.CompanySupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanySupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          findMany: {
            args: Prisma.CompanySupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>[]
          }
          create: {
            args: Prisma.CompanySupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          createMany: {
            args: Prisma.CompanySupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanySupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          update: {
            args: Prisma.CompanySupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          deleteMany: {
            args: Prisma.CompanySupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanySupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanySupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySupplierPayload>
          }
          aggregate: {
            args: Prisma.CompanySupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanySupplier>
          }
          groupBy: {
            args: Prisma.CompanySupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanySupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanySupplierCountArgs<ExtArgs>
            result: $Utils.Optional<CompanySupplierCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnitSupplier: {
        payload: Prisma.$BusinessUnitSupplierPayload<ExtArgs>
        fields: Prisma.BusinessUnitSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BusinessUnitSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          update: {
            args: Prisma.BusinessUnitSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUnitSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSupplierPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnitSupplier>
          }
          groupBy: {
            args: Prisma.BusinessUnitSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitSupplierCountAggregateOutputType> | number
          }
        }
      }
      CompanyBanque: {
        payload: Prisma.$CompanyBanquePayload<ExtArgs>
        fields: Prisma.CompanyBanqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyBanqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyBanqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          findFirst: {
            args: Prisma.CompanyBanqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyBanqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          findMany: {
            args: Prisma.CompanyBanqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>[]
          }
          create: {
            args: Prisma.CompanyBanqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          createMany: {
            args: Prisma.CompanyBanqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyBanqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          update: {
            args: Prisma.CompanyBanqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          deleteMany: {
            args: Prisma.CompanyBanqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyBanqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyBanqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBanquePayload>
          }
          aggregate: {
            args: Prisma.CompanyBanqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyBanque>
          }
          groupBy: {
            args: Prisma.CompanyBanqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyBanqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyBanqueCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyBanqueCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      WorkflowTemplate: {
        payload: Prisma.$WorkflowTemplatePayload<ExtArgs>
        fields: Prisma.WorkflowTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findFirst: {
            args: Prisma.WorkflowTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          findMany: {
            args: Prisma.WorkflowTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>[]
          }
          create: {
            args: Prisma.WorkflowTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          createMany: {
            args: Prisma.WorkflowTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkflowTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          update: {
            args: Prisma.WorkflowTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowTemplatePayload>
          }
          aggregate: {
            args: Prisma.WorkflowTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowTemplate>
          }
          groupBy: {
            args: Prisma.WorkflowTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowTemplateCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStep: {
        payload: Prisma.$WorkflowStepPayload<ExtArgs>
        fields: Prisma.WorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          update: {
            args: Prisma.WorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStep>
          }
          groupBy: {
            args: Prisma.WorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
    auditLogs: number
    stepCompletions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    stepCompletions?: boolean | UserCountOutputTypeCountStepCompletionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepCompletionWhereInput
  }


  /**
   * Count Type BanqueCountOutputType
   */

  export type BanqueCountOutputType = {
    lignesCredit: number
    companies: number
    bankAccounts: number
  }

  export type BanqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignesCredit?: boolean | BanqueCountOutputTypeCountLignesCreditArgs
    companies?: boolean | BanqueCountOutputTypeCountCompaniesArgs
    bankAccounts?: boolean | BanqueCountOutputTypeCountBankAccountsArgs
  }

  // Custom InputTypes
  /**
   * BanqueCountOutputType without action
   */
  export type BanqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueCountOutputType
     */
    select?: BanqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BanqueCountOutputType without action
   */
  export type BanqueCountOutputTypeCountLignesCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCreditWhereInput
  }

  /**
   * BanqueCountOutputType without action
   */
  export type BanqueCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBanqueWhereInput
  }

  /**
   * BanqueCountOutputType without action
   */
  export type BanqueCountOutputTypeCountBankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
  }


  /**
   * Count Type LigneCreditCountOutputType
   */

  export type LigneCreditCountOutputType = {
    garanties: number
    engagements: number
  }

  export type LigneCreditCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garanties?: boolean | LigneCreditCountOutputTypeCountGarantiesArgs
    engagements?: boolean | LigneCreditCountOutputTypeCountEngagementsArgs
  }

  // Custom InputTypes
  /**
   * LigneCreditCountOutputType without action
   */
  export type LigneCreditCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCreditCountOutputType
     */
    select?: LigneCreditCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LigneCreditCountOutputType without action
   */
  export type LigneCreditCountOutputTypeCountGarantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GarantieWhereInput
  }

  /**
   * LigneCreditCountOutputType without action
   */
  export type LigneCreditCountOutputTypeCountEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementWhereInput
  }


  /**
   * Count Type EngagementCountOutputType
   */

  export type EngagementCountOutputType = {
    childEngagements: number
    stepCompletions: number
  }

  export type EngagementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childEngagements?: boolean | EngagementCountOutputTypeCountChildEngagementsArgs
    stepCompletions?: boolean | EngagementCountOutputTypeCountStepCompletionsArgs
  }

  // Custom InputTypes
  /**
   * EngagementCountOutputType without action
   */
  export type EngagementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementCountOutputType
     */
    select?: EngagementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EngagementCountOutputType without action
   */
  export type EngagementCountOutputTypeCountChildEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementWhereInput
  }

  /**
   * EngagementCountOutputType without action
   */
  export type EngagementCountOutputTypeCountStepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepCompletionWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    subCompanies: number
    businessUnits: number
    users: number
    companySuppliers: number
    companyBanques: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCompanies?: boolean | CompanyCountOutputTypeCountSubCompaniesArgs
    businessUnits?: boolean | CompanyCountOutputTypeCountBusinessUnitsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    companySuppliers?: boolean | CompanyCountOutputTypeCountCompanySuppliersArgs
    companyBanques?: boolean | CompanyCountOutputTypeCountCompanyBanquesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSubCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBusinessUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanySuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySupplierWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyBanquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBanqueWhereInput
  }


  /**
   * Count Type BusinessUnitCountOutputType
   */

  export type BusinessUnitCountOutputType = {
    users: number
    businessUnitSuppliers: number
  }

  export type BusinessUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BusinessUnitCountOutputTypeCountUsersArgs
    businessUnitSuppliers?: boolean | BusinessUnitCountOutputTypeCountBusinessUnitSuppliersArgs
  }

  // Custom InputTypes
  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitCountOutputType
     */
    select?: BusinessUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountBusinessUnitSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSupplierWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    companySuppliers: number
    businessUnitSuppliers: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySuppliers?: boolean | SupplierCountOutputTypeCountCompanySuppliersArgs
    businessUnitSuppliers?: boolean | SupplierCountOutputTypeCountBusinessUnitSuppliersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountCompanySuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySupplierWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountBusinessUnitSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSupplierWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
    rolePermissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type WorkflowTemplateCountOutputType
   */

  export type WorkflowTemplateCountOutputType = {
    steps: number
    engagements: number
  }

  export type WorkflowTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | WorkflowTemplateCountOutputTypeCountStepsArgs
    engagements?: boolean | WorkflowTemplateCountOutputTypeCountEngagementsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowTemplateCountOutputType without action
   */
  export type WorkflowTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplateCountOutputType
     */
    select?: WorkflowTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowTemplateCountOutputType without action
   */
  export type WorkflowTemplateCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowTemplateCountOutputType without action
   */
  export type WorkflowTemplateCountOutputTypeCountEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementWhereInput
  }


  /**
   * Count Type WorkflowStepCountOutputType
   */

  export type WorkflowStepCountOutputType = {
    engagements: number
    stepCompletions: number
  }

  export type WorkflowStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    engagements?: boolean | WorkflowStepCountOutputTypeCountEngagementsArgs
    stepCompletions?: boolean | WorkflowStepCountOutputTypeCountStepCompletionsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepCountOutputType
     */
    select?: WorkflowStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeCountEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementWhereInput
  }

  /**
   * WorkflowStepCountOutputType without action
   */
  export type WorkflowStepCountOutputTypeCountStepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepCompletionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: string | null
    status: string | null
    emailVerified: boolean | null
    emailVerifiedAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastLoginAt: Date | null
    companyId: string | null
    businessUnitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: string | null
    status: string | null
    emailVerified: boolean | null
    emailVerifiedAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastLoginAt: Date | null
    companyId: string | null
    businessUnitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    role: number
    status: number
    emailVerified: number
    emailVerifiedAt: number
    failedLoginAttempts: number
    lockedUntil: number
    lastLoginAt: number
    companyId: number
    businessUnitId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    status?: true
    emailVerified?: true
    emailVerifiedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    companyId?: true
    businessUnitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    status?: true
    emailVerified?: true
    emailVerifiedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    companyId?: true
    businessUnitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    status?: true
    emailVerified?: true
    emailVerifiedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastLoginAt?: true
    companyId?: true
    businessUnitId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    password: string
    role: string
    status: string
    emailVerified: boolean
    emailVerifiedAt: Date | null
    failedLoginAttempts: number
    lockedUntil: Date | null
    lastLoginAt: Date | null
    companyId: string | null
    businessUnitId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    emailVerifiedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    companyId?: boolean
    businessUnitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | user$companyArgs<ExtArgs>
    businessUnit?: boolean | user$businessUnitArgs<ExtArgs>
    userRoles?: boolean | user$userRolesArgs<ExtArgs>
    auditLogs?: boolean | user$auditLogsArgs<ExtArgs>
    stepCompletions?: boolean | user$stepCompletionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    emailVerifiedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastLoginAt?: boolean
    companyId?: boolean
    businessUnitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | user$companyArgs<ExtArgs>
    businessUnit?: boolean | user$businessUnitArgs<ExtArgs>
    userRoles?: boolean | user$userRolesArgs<ExtArgs>
    auditLogs?: boolean | user$auditLogsArgs<ExtArgs>
    stepCompletions?: boolean | user$stepCompletionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs> | null
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      stepCompletions: Prisma.$StepCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      password: string
      role: string
      status: string
      emailVerified: boolean
      emailVerifiedAt: Date | null
      failedLoginAttempts: number
      lockedUntil: Date | null
      lastLoginAt: Date | null
      companyId: string | null
      businessUnitId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends user$companyArgs<ExtArgs> = {}>(args?: Subset<T, user$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    businessUnit<T extends user$businessUnitArgs<ExtArgs> = {}>(args?: Subset<T, user$businessUnitArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userRoles<T extends user$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, user$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends user$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, user$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    stepCompletions<T extends user$stepCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, user$stepCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'String'>
    readonly emailVerified: FieldRef<"user", 'Boolean'>
    readonly emailVerifiedAt: FieldRef<"user", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"user", 'Int'>
    readonly lockedUntil: FieldRef<"user", 'DateTime'>
    readonly lastLoginAt: FieldRef<"user", 'DateTime'>
    readonly companyId: FieldRef<"user", 'String'>
    readonly businessUnitId: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user.company
   */
  export type user$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * user.businessUnit
   */
  export type user$businessUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    where?: BusinessUnitWhereInput
  }

  /**
   * user.userRoles
   */
  export type user$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * user.auditLogs
   */
  export type user$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * user.stepCompletions
   */
  export type user$stepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    where?: StepCompletionWhereInput
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    cursor?: StepCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model Banque
   */

  export type AggregateBanque = {
    _count: BanqueCountAggregateOutputType | null
    _min: BanqueMinAggregateOutputType | null
    _max: BanqueMaxAggregateOutputType | null
  }

  export type BanqueMinAggregateOutputType = {
    id: string | null
    nom: string | null
    codeSwift: string | null
    codeGuichet: string | null
    adresse: string | null
    contactInfo: string | null
    establishment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BanqueMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    codeSwift: string | null
    codeGuichet: string | null
    adresse: string | null
    contactInfo: string | null
    establishment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BanqueCountAggregateOutputType = {
    id: number
    nom: number
    codeSwift: number
    codeGuichet: number
    adresse: number
    contactInfo: number
    establishment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BanqueMinAggregateInputType = {
    id?: true
    nom?: true
    codeSwift?: true
    codeGuichet?: true
    adresse?: true
    contactInfo?: true
    establishment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BanqueMaxAggregateInputType = {
    id?: true
    nom?: true
    codeSwift?: true
    codeGuichet?: true
    adresse?: true
    contactInfo?: true
    establishment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BanqueCountAggregateInputType = {
    id?: true
    nom?: true
    codeSwift?: true
    codeGuichet?: true
    adresse?: true
    contactInfo?: true
    establishment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BanqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banque to aggregate.
     */
    where?: BanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banques to fetch.
     */
    orderBy?: BanqueOrderByWithRelationInput | BanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banques
    **/
    _count?: true | BanqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanqueMaxAggregateInputType
  }

  export type GetBanqueAggregateType<T extends BanqueAggregateArgs> = {
        [P in keyof T & keyof AggregateBanque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanque[P]>
      : GetScalarType<T[P], AggregateBanque[P]>
  }




  export type BanqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanqueWhereInput
    orderBy?: BanqueOrderByWithAggregationInput | BanqueOrderByWithAggregationInput[]
    by: BanqueScalarFieldEnum[] | BanqueScalarFieldEnum
    having?: BanqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanqueCountAggregateInputType | true
    _min?: BanqueMinAggregateInputType
    _max?: BanqueMaxAggregateInputType
  }

  export type BanqueGroupByOutputType = {
    id: string
    nom: string
    codeSwift: string
    codeGuichet: string | null
    adresse: string
    contactInfo: string | null
    establishment: string | null
    createdAt: Date
    updatedAt: Date
    _count: BanqueCountAggregateOutputType | null
    _min: BanqueMinAggregateOutputType | null
    _max: BanqueMaxAggregateOutputType | null
  }

  type GetBanqueGroupByPayload<T extends BanqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanqueGroupByOutputType[P]>
            : GetScalarType<T[P], BanqueGroupByOutputType[P]>
        }
      >
    >


  export type BanqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    codeSwift?: boolean
    codeGuichet?: boolean
    adresse?: boolean
    contactInfo?: boolean
    establishment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lignesCredit?: boolean | Banque$lignesCreditArgs<ExtArgs>
    companies?: boolean | Banque$companiesArgs<ExtArgs>
    bankAccounts?: boolean | Banque$bankAccountsArgs<ExtArgs>
    _count?: boolean | BanqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banque"]>


  export type BanqueSelectScalar = {
    id?: boolean
    nom?: boolean
    codeSwift?: boolean
    codeGuichet?: boolean
    adresse?: boolean
    contactInfo?: boolean
    establishment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BanqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignesCredit?: boolean | Banque$lignesCreditArgs<ExtArgs>
    companies?: boolean | Banque$companiesArgs<ExtArgs>
    bankAccounts?: boolean | Banque$bankAccountsArgs<ExtArgs>
    _count?: boolean | BanqueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BanquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banque"
    objects: {
      lignesCredit: Prisma.$LigneCreditPayload<ExtArgs>[]
      companies: Prisma.$CompanyBanquePayload<ExtArgs>[]
      bankAccounts: Prisma.$BankAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      codeSwift: string
      codeGuichet: string | null
      adresse: string
      contactInfo: string | null
      establishment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banque"]>
    composites: {}
  }

  type BanqueGetPayload<S extends boolean | null | undefined | BanqueDefaultArgs> = $Result.GetResult<Prisma.$BanquePayload, S>

  type BanqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BanqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BanqueCountAggregateInputType | true
    }

  export interface BanqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banque'], meta: { name: 'Banque' } }
    /**
     * Find zero or one Banque that matches the filter.
     * @param {BanqueFindUniqueArgs} args - Arguments to find a Banque
     * @example
     * // Get one Banque
     * const banque = await prisma.banque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BanqueFindUniqueArgs>(args: SelectSubset<T, BanqueFindUniqueArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Banque that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BanqueFindUniqueOrThrowArgs} args - Arguments to find a Banque
     * @example
     * // Get one Banque
     * const banque = await prisma.banque.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BanqueFindUniqueOrThrowArgs>(args: SelectSubset<T, BanqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Banque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueFindFirstArgs} args - Arguments to find a Banque
     * @example
     * // Get one Banque
     * const banque = await prisma.banque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BanqueFindFirstArgs>(args?: SelectSubset<T, BanqueFindFirstArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Banque that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueFindFirstOrThrowArgs} args - Arguments to find a Banque
     * @example
     * // Get one Banque
     * const banque = await prisma.banque.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BanqueFindFirstOrThrowArgs>(args?: SelectSubset<T, BanqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Banques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banques
     * const banques = await prisma.banque.findMany()
     * 
     * // Get first 10 Banques
     * const banques = await prisma.banque.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banqueWithIdOnly = await prisma.banque.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BanqueFindManyArgs>(args?: SelectSubset<T, BanqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Banque.
     * @param {BanqueCreateArgs} args - Arguments to create a Banque.
     * @example
     * // Create one Banque
     * const Banque = await prisma.banque.create({
     *   data: {
     *     // ... data to create a Banque
     *   }
     * })
     * 
     */
    create<T extends BanqueCreateArgs>(args: SelectSubset<T, BanqueCreateArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Banques.
     * @param {BanqueCreateManyArgs} args - Arguments to create many Banques.
     * @example
     * // Create many Banques
     * const banque = await prisma.banque.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BanqueCreateManyArgs>(args?: SelectSubset<T, BanqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banque.
     * @param {BanqueDeleteArgs} args - Arguments to delete one Banque.
     * @example
     * // Delete one Banque
     * const Banque = await prisma.banque.delete({
     *   where: {
     *     // ... filter to delete one Banque
     *   }
     * })
     * 
     */
    delete<T extends BanqueDeleteArgs>(args: SelectSubset<T, BanqueDeleteArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Banque.
     * @param {BanqueUpdateArgs} args - Arguments to update one Banque.
     * @example
     * // Update one Banque
     * const banque = await prisma.banque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BanqueUpdateArgs>(args: SelectSubset<T, BanqueUpdateArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Banques.
     * @param {BanqueDeleteManyArgs} args - Arguments to filter Banques to delete.
     * @example
     * // Delete a few Banques
     * const { count } = await prisma.banque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BanqueDeleteManyArgs>(args?: SelectSubset<T, BanqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banques
     * const banque = await prisma.banque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BanqueUpdateManyArgs>(args: SelectSubset<T, BanqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banque.
     * @param {BanqueUpsertArgs} args - Arguments to update or create a Banque.
     * @example
     * // Update or create a Banque
     * const banque = await prisma.banque.upsert({
     *   create: {
     *     // ... data to create a Banque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banque we want to update
     *   }
     * })
     */
    upsert<T extends BanqueUpsertArgs>(args: SelectSubset<T, BanqueUpsertArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Banques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueCountArgs} args - Arguments to filter Banques to count.
     * @example
     * // Count the number of Banques
     * const count = await prisma.banque.count({
     *   where: {
     *     // ... the filter for the Banques we want to count
     *   }
     * })
    **/
    count<T extends BanqueCountArgs>(
      args?: Subset<T, BanqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanqueAggregateArgs>(args: Subset<T, BanqueAggregateArgs>): Prisma.PrismaPromise<GetBanqueAggregateType<T>>

    /**
     * Group by Banque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanqueGroupByArgs['orderBy'] }
        : { orderBy?: BanqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banque model
   */
  readonly fields: BanqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BanqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lignesCredit<T extends Banque$lignesCreditArgs<ExtArgs> = {}>(args?: Subset<T, Banque$lignesCreditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findMany"> | Null>
    companies<T extends Banque$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Banque$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findMany"> | Null>
    bankAccounts<T extends Banque$bankAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Banque$bankAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banque model
   */ 
  interface BanqueFieldRefs {
    readonly id: FieldRef<"Banque", 'String'>
    readonly nom: FieldRef<"Banque", 'String'>
    readonly codeSwift: FieldRef<"Banque", 'String'>
    readonly codeGuichet: FieldRef<"Banque", 'String'>
    readonly adresse: FieldRef<"Banque", 'String'>
    readonly contactInfo: FieldRef<"Banque", 'String'>
    readonly establishment: FieldRef<"Banque", 'String'>
    readonly createdAt: FieldRef<"Banque", 'DateTime'>
    readonly updatedAt: FieldRef<"Banque", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banque findUnique
   */
  export type BanqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter, which Banque to fetch.
     */
    where: BanqueWhereUniqueInput
  }

  /**
   * Banque findUniqueOrThrow
   */
  export type BanqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter, which Banque to fetch.
     */
    where: BanqueWhereUniqueInput
  }

  /**
   * Banque findFirst
   */
  export type BanqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter, which Banque to fetch.
     */
    where?: BanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banques to fetch.
     */
    orderBy?: BanqueOrderByWithRelationInput | BanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banques.
     */
    cursor?: BanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banques.
     */
    distinct?: BanqueScalarFieldEnum | BanqueScalarFieldEnum[]
  }

  /**
   * Banque findFirstOrThrow
   */
  export type BanqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter, which Banque to fetch.
     */
    where?: BanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banques to fetch.
     */
    orderBy?: BanqueOrderByWithRelationInput | BanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banques.
     */
    cursor?: BanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banques.
     */
    distinct?: BanqueScalarFieldEnum | BanqueScalarFieldEnum[]
  }

  /**
   * Banque findMany
   */
  export type BanqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter, which Banques to fetch.
     */
    where?: BanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banques to fetch.
     */
    orderBy?: BanqueOrderByWithRelationInput | BanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banques.
     */
    cursor?: BanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banques.
     */
    skip?: number
    distinct?: BanqueScalarFieldEnum | BanqueScalarFieldEnum[]
  }

  /**
   * Banque create
   */
  export type BanqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * The data needed to create a Banque.
     */
    data: XOR<BanqueCreateInput, BanqueUncheckedCreateInput>
  }

  /**
   * Banque createMany
   */
  export type BanqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banques.
     */
    data: BanqueCreateManyInput | BanqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banque update
   */
  export type BanqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * The data needed to update a Banque.
     */
    data: XOR<BanqueUpdateInput, BanqueUncheckedUpdateInput>
    /**
     * Choose, which Banque to update.
     */
    where: BanqueWhereUniqueInput
  }

  /**
   * Banque updateMany
   */
  export type BanqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banques.
     */
    data: XOR<BanqueUpdateManyMutationInput, BanqueUncheckedUpdateManyInput>
    /**
     * Filter which Banques to update
     */
    where?: BanqueWhereInput
  }

  /**
   * Banque upsert
   */
  export type BanqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * The filter to search for the Banque to update in case it exists.
     */
    where: BanqueWhereUniqueInput
    /**
     * In case the Banque found by the `where` argument doesn't exist, create a new Banque with this data.
     */
    create: XOR<BanqueCreateInput, BanqueUncheckedCreateInput>
    /**
     * In case the Banque was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanqueUpdateInput, BanqueUncheckedUpdateInput>
  }

  /**
   * Banque delete
   */
  export type BanqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
    /**
     * Filter which Banque to delete.
     */
    where: BanqueWhereUniqueInput
  }

  /**
   * Banque deleteMany
   */
  export type BanqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banques to delete
     */
    where?: BanqueWhereInput
  }

  /**
   * Banque.lignesCredit
   */
  export type Banque$lignesCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    where?: LigneCreditWhereInput
    orderBy?: LigneCreditOrderByWithRelationInput | LigneCreditOrderByWithRelationInput[]
    cursor?: LigneCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneCreditScalarFieldEnum | LigneCreditScalarFieldEnum[]
  }

  /**
   * Banque.companies
   */
  export type Banque$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    where?: CompanyBanqueWhereInput
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    cursor?: CompanyBanqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBanqueScalarFieldEnum | CompanyBanqueScalarFieldEnum[]
  }

  /**
   * Banque.bankAccounts
   */
  export type Banque$bankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    cursor?: BankAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * Banque without action
   */
  export type BanqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banque
     */
    select?: BanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BanqueInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    keyAccount: string | null
    currency: string | null
    rib: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedBy: string | null
    banqueId: string | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    keyAccount: string | null
    currency: string | null
    rib: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedBy: string | null
    banqueId: string | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    accountNumber: number
    keyAccount: number
    currency: number
    rib: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    createdBy: number
    updatedBy: number
    deletedBy: number
    banqueId: number
    _all: number
  }


  export type BankAccountMinAggregateInputType = {
    id?: true
    accountNumber?: true
    keyAccount?: true
    currency?: true
    rib?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    banqueId?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    accountNumber?: true
    keyAccount?: true
    currency?: true
    rib?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    banqueId?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    accountNumber?: true
    keyAccount?: true
    currency?: true
    rib?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedBy?: true
    banqueId?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    createdBy: string
    updatedBy: string
    deletedBy: string | null
    banqueId: string
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    keyAccount?: boolean
    currency?: boolean
    rib?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    banqueId?: boolean
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>


  export type BankAccountSelectScalar = {
    id?: boolean
    accountNumber?: boolean
    keyAccount?: boolean
    currency?: boolean
    rib?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedBy?: boolean
    banqueId?: boolean
  }

  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      banque: Prisma.$BanquePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountNumber: string
      keyAccount: string
      currency: string
      rib: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      createdBy: string
      updatedBy: string
      deletedBy: string | null
      banqueId: string
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banque<T extends BanqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BanqueDefaultArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */ 
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly accountNumber: FieldRef<"BankAccount", 'String'>
    readonly keyAccount: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly rib: FieldRef<"BankAccount", 'String'>
    readonly isActive: FieldRef<"BankAccount", 'Boolean'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
    readonly deletedAt: FieldRef<"BankAccount", 'DateTime'>
    readonly createdBy: FieldRef<"BankAccount", 'String'>
    readonly updatedBy: FieldRef<"BankAccount", 'String'>
    readonly deletedBy: FieldRef<"BankAccount", 'String'>
    readonly banqueId: FieldRef<"BankAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model LigneCredit
   */

  export type AggregateLigneCredit = {
    _count: LigneCreditCountAggregateOutputType | null
    _avg: LigneCreditAvgAggregateOutputType | null
    _sum: LigneCreditSumAggregateOutputType | null
    _min: LigneCreditMinAggregateOutputType | null
    _max: LigneCreditMaxAggregateOutputType | null
  }

  export type LigneCreditAvgAggregateOutputType = {
    montantPlafond: number | null
    taux: number | null
    commitmentCommissionRate: number | null
    estimatedOutstanding: number | null
    consumption: number | null
    outstanding: number | null
    seuilAvanceSurStock: number | null
    seuilAvanceSurFacture: number | null
    seuilEscompte: number | null
    seuilLC: number | null
    seuilObligtDouane: number | null
    seuilCautionAdmin: number | null
    seuilDcvrtMobile: number | null
    seuilTrsfrLibre: number | null
    seuilLeasing: number | null
    seuilCMT: number | null
    seuilFraisMission: number | null
    seuilLCAS: number | null
    avanceSurStock: number | null
    avanceFacture: number | null
    escompte: number | null
    obligatDouane: number | null
    cautionAdmin: number | null
    dcvrtMobile: number | null
    trsfrLibre: number | null
    leasing: number | null
    CMT: number | null
    fraisMission: number | null
    LCAS: number | null
    faciliteCaissier: number | null
    maxConsumptionTolerance: number | null
    minConsumptionTolerance: number | null
    refinancing: number | null
  }

  export type LigneCreditSumAggregateOutputType = {
    montantPlafond: number | null
    taux: number | null
    commitmentCommissionRate: number | null
    estimatedOutstanding: number | null
    consumption: number | null
    outstanding: number | null
    seuilAvanceSurStock: number | null
    seuilAvanceSurFacture: number | null
    seuilEscompte: number | null
    seuilLC: number | null
    seuilObligtDouane: number | null
    seuilCautionAdmin: number | null
    seuilDcvrtMobile: number | null
    seuilTrsfrLibre: number | null
    seuilLeasing: number | null
    seuilCMT: number | null
    seuilFraisMission: number | null
    seuilLCAS: number | null
    avanceSurStock: number | null
    avanceFacture: number | null
    escompte: number | null
    obligatDouane: number | null
    cautionAdmin: number | null
    dcvrtMobile: number | null
    trsfrLibre: number | null
    leasing: number | null
    CMT: number | null
    fraisMission: number | null
    LCAS: number | null
    faciliteCaissier: number | null
    maxConsumptionTolerance: number | null
    minConsumptionTolerance: number | null
    refinancing: number | null
  }

  export type LigneCreditMinAggregateOutputType = {
    id: string | null
    no: string | null
    description: string | null
    banqueId: string | null
    autorisationNo: string | null
    bankAccountNo: string | null
    montantPlafond: number | null
    montantDevise: string | null
    taux: number | null
    commitmentCommissionRate: number | null
    estimatedOutstanding: number | null
    consumption: number | null
    outstanding: number | null
    startDate: Date | null
    expiryDate: Date | null
    renewalDate: Date | null
    statut: string | null
    responsibilityCenter: string | null
    seuilAvanceSurStock: number | null
    seuilAvanceSurFacture: number | null
    seuilEscompte: number | null
    seuilLC: number | null
    seuilObligtDouane: number | null
    seuilCautionAdmin: number | null
    seuilDcvrtMobile: number | null
    seuilTrsfrLibre: number | null
    seuilLeasing: number | null
    seuilCMT: number | null
    seuilFraisMission: number | null
    seuilLCAS: number | null
    avanceSurStock: number | null
    avanceFacture: number | null
    escompte: number | null
    obligatDouane: number | null
    cautionAdmin: number | null
    dcvrtMobile: number | null
    trsfrLibre: number | null
    leasing: number | null
    CMT: number | null
    fraisMission: number | null
    LCAS: number | null
    faciliteCaissier: number | null
    typeFinancement: string | null
    maxConsumptionTolerance: number | null
    minConsumptionTolerance: number | null
    noSeries: string | null
    refinancing: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCreditMaxAggregateOutputType = {
    id: string | null
    no: string | null
    description: string | null
    banqueId: string | null
    autorisationNo: string | null
    bankAccountNo: string | null
    montantPlafond: number | null
    montantDevise: string | null
    taux: number | null
    commitmentCommissionRate: number | null
    estimatedOutstanding: number | null
    consumption: number | null
    outstanding: number | null
    startDate: Date | null
    expiryDate: Date | null
    renewalDate: Date | null
    statut: string | null
    responsibilityCenter: string | null
    seuilAvanceSurStock: number | null
    seuilAvanceSurFacture: number | null
    seuilEscompte: number | null
    seuilLC: number | null
    seuilObligtDouane: number | null
    seuilCautionAdmin: number | null
    seuilDcvrtMobile: number | null
    seuilTrsfrLibre: number | null
    seuilLeasing: number | null
    seuilCMT: number | null
    seuilFraisMission: number | null
    seuilLCAS: number | null
    avanceSurStock: number | null
    avanceFacture: number | null
    escompte: number | null
    obligatDouane: number | null
    cautionAdmin: number | null
    dcvrtMobile: number | null
    trsfrLibre: number | null
    leasing: number | null
    CMT: number | null
    fraisMission: number | null
    LCAS: number | null
    faciliteCaissier: number | null
    typeFinancement: string | null
    maxConsumptionTolerance: number | null
    minConsumptionTolerance: number | null
    noSeries: string | null
    refinancing: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCreditCountAggregateOutputType = {
    id: number
    no: number
    description: number
    banqueId: number
    autorisationNo: number
    bankAccountNo: number
    montantPlafond: number
    montantDevise: number
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: number
    expiryDate: number
    renewalDate: number
    statut: number
    responsibilityCenter: number
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: number
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: number
    refinancing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LigneCreditAvgAggregateInputType = {
    montantPlafond?: true
    taux?: true
    commitmentCommissionRate?: true
    estimatedOutstanding?: true
    consumption?: true
    outstanding?: true
    seuilAvanceSurStock?: true
    seuilAvanceSurFacture?: true
    seuilEscompte?: true
    seuilLC?: true
    seuilObligtDouane?: true
    seuilCautionAdmin?: true
    seuilDcvrtMobile?: true
    seuilTrsfrLibre?: true
    seuilLeasing?: true
    seuilCMT?: true
    seuilFraisMission?: true
    seuilLCAS?: true
    avanceSurStock?: true
    avanceFacture?: true
    escompte?: true
    obligatDouane?: true
    cautionAdmin?: true
    dcvrtMobile?: true
    trsfrLibre?: true
    leasing?: true
    CMT?: true
    fraisMission?: true
    LCAS?: true
    faciliteCaissier?: true
    maxConsumptionTolerance?: true
    minConsumptionTolerance?: true
    refinancing?: true
  }

  export type LigneCreditSumAggregateInputType = {
    montantPlafond?: true
    taux?: true
    commitmentCommissionRate?: true
    estimatedOutstanding?: true
    consumption?: true
    outstanding?: true
    seuilAvanceSurStock?: true
    seuilAvanceSurFacture?: true
    seuilEscompte?: true
    seuilLC?: true
    seuilObligtDouane?: true
    seuilCautionAdmin?: true
    seuilDcvrtMobile?: true
    seuilTrsfrLibre?: true
    seuilLeasing?: true
    seuilCMT?: true
    seuilFraisMission?: true
    seuilLCAS?: true
    avanceSurStock?: true
    avanceFacture?: true
    escompte?: true
    obligatDouane?: true
    cautionAdmin?: true
    dcvrtMobile?: true
    trsfrLibre?: true
    leasing?: true
    CMT?: true
    fraisMission?: true
    LCAS?: true
    faciliteCaissier?: true
    maxConsumptionTolerance?: true
    minConsumptionTolerance?: true
    refinancing?: true
  }

  export type LigneCreditMinAggregateInputType = {
    id?: true
    no?: true
    description?: true
    banqueId?: true
    autorisationNo?: true
    bankAccountNo?: true
    montantPlafond?: true
    montantDevise?: true
    taux?: true
    commitmentCommissionRate?: true
    estimatedOutstanding?: true
    consumption?: true
    outstanding?: true
    startDate?: true
    expiryDate?: true
    renewalDate?: true
    statut?: true
    responsibilityCenter?: true
    seuilAvanceSurStock?: true
    seuilAvanceSurFacture?: true
    seuilEscompte?: true
    seuilLC?: true
    seuilObligtDouane?: true
    seuilCautionAdmin?: true
    seuilDcvrtMobile?: true
    seuilTrsfrLibre?: true
    seuilLeasing?: true
    seuilCMT?: true
    seuilFraisMission?: true
    seuilLCAS?: true
    avanceSurStock?: true
    avanceFacture?: true
    escompte?: true
    obligatDouane?: true
    cautionAdmin?: true
    dcvrtMobile?: true
    trsfrLibre?: true
    leasing?: true
    CMT?: true
    fraisMission?: true
    LCAS?: true
    faciliteCaissier?: true
    typeFinancement?: true
    maxConsumptionTolerance?: true
    minConsumptionTolerance?: true
    noSeries?: true
    refinancing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCreditMaxAggregateInputType = {
    id?: true
    no?: true
    description?: true
    banqueId?: true
    autorisationNo?: true
    bankAccountNo?: true
    montantPlafond?: true
    montantDevise?: true
    taux?: true
    commitmentCommissionRate?: true
    estimatedOutstanding?: true
    consumption?: true
    outstanding?: true
    startDate?: true
    expiryDate?: true
    renewalDate?: true
    statut?: true
    responsibilityCenter?: true
    seuilAvanceSurStock?: true
    seuilAvanceSurFacture?: true
    seuilEscompte?: true
    seuilLC?: true
    seuilObligtDouane?: true
    seuilCautionAdmin?: true
    seuilDcvrtMobile?: true
    seuilTrsfrLibre?: true
    seuilLeasing?: true
    seuilCMT?: true
    seuilFraisMission?: true
    seuilLCAS?: true
    avanceSurStock?: true
    avanceFacture?: true
    escompte?: true
    obligatDouane?: true
    cautionAdmin?: true
    dcvrtMobile?: true
    trsfrLibre?: true
    leasing?: true
    CMT?: true
    fraisMission?: true
    LCAS?: true
    faciliteCaissier?: true
    typeFinancement?: true
    maxConsumptionTolerance?: true
    minConsumptionTolerance?: true
    noSeries?: true
    refinancing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCreditCountAggregateInputType = {
    id?: true
    no?: true
    description?: true
    banqueId?: true
    autorisationNo?: true
    bankAccountNo?: true
    montantPlafond?: true
    montantDevise?: true
    taux?: true
    commitmentCommissionRate?: true
    estimatedOutstanding?: true
    consumption?: true
    outstanding?: true
    startDate?: true
    expiryDate?: true
    renewalDate?: true
    statut?: true
    responsibilityCenter?: true
    seuilAvanceSurStock?: true
    seuilAvanceSurFacture?: true
    seuilEscompte?: true
    seuilLC?: true
    seuilObligtDouane?: true
    seuilCautionAdmin?: true
    seuilDcvrtMobile?: true
    seuilTrsfrLibre?: true
    seuilLeasing?: true
    seuilCMT?: true
    seuilFraisMission?: true
    seuilLCAS?: true
    avanceSurStock?: true
    avanceFacture?: true
    escompte?: true
    obligatDouane?: true
    cautionAdmin?: true
    dcvrtMobile?: true
    trsfrLibre?: true
    leasing?: true
    CMT?: true
    fraisMission?: true
    LCAS?: true
    faciliteCaissier?: true
    typeFinancement?: true
    maxConsumptionTolerance?: true
    minConsumptionTolerance?: true
    noSeries?: true
    refinancing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LigneCreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCredit to aggregate.
     */
    where?: LigneCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCredits to fetch.
     */
    orderBy?: LigneCreditOrderByWithRelationInput | LigneCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneCredits
    **/
    _count?: true | LigneCreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneCreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneCreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneCreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneCreditMaxAggregateInputType
  }

  export type GetLigneCreditAggregateType<T extends LigneCreditAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneCredit[P]>
      : GetScalarType<T[P], AggregateLigneCredit[P]>
  }




  export type LigneCreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCreditWhereInput
    orderBy?: LigneCreditOrderByWithAggregationInput | LigneCreditOrderByWithAggregationInput[]
    by: LigneCreditScalarFieldEnum[] | LigneCreditScalarFieldEnum
    having?: LigneCreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneCreditCountAggregateInputType | true
    _avg?: LigneCreditAvgAggregateInputType
    _sum?: LigneCreditSumAggregateInputType
    _min?: LigneCreditMinAggregateInputType
    _max?: LigneCreditMaxAggregateInputType
  }

  export type LigneCreditGroupByOutputType = {
    id: string
    no: string
    description: string | null
    banqueId: string
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date
    expiryDate: Date
    renewalDate: Date | null
    statut: string
    responsibilityCenter: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt: Date
    updatedAt: Date
    _count: LigneCreditCountAggregateOutputType | null
    _avg: LigneCreditAvgAggregateOutputType | null
    _sum: LigneCreditSumAggregateOutputType | null
    _min: LigneCreditMinAggregateOutputType | null
    _max: LigneCreditMaxAggregateOutputType | null
  }

  type GetLigneCreditGroupByPayload<T extends LigneCreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneCreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneCreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneCreditGroupByOutputType[P]>
            : GetScalarType<T[P], LigneCreditGroupByOutputType[P]>
        }
      >
    >


  export type LigneCreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    no?: boolean
    description?: boolean
    banqueId?: boolean
    autorisationNo?: boolean
    bankAccountNo?: boolean
    montantPlafond?: boolean
    montantDevise?: boolean
    taux?: boolean
    commitmentCommissionRate?: boolean
    estimatedOutstanding?: boolean
    consumption?: boolean
    outstanding?: boolean
    startDate?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    statut?: boolean
    responsibilityCenter?: boolean
    seuilAvanceSurStock?: boolean
    seuilAvanceSurFacture?: boolean
    seuilEscompte?: boolean
    seuilLC?: boolean
    seuilObligtDouane?: boolean
    seuilCautionAdmin?: boolean
    seuilDcvrtMobile?: boolean
    seuilTrsfrLibre?: boolean
    seuilLeasing?: boolean
    seuilCMT?: boolean
    seuilFraisMission?: boolean
    seuilLCAS?: boolean
    avanceSurStock?: boolean
    avanceFacture?: boolean
    escompte?: boolean
    obligatDouane?: boolean
    cautionAdmin?: boolean
    dcvrtMobile?: boolean
    trsfrLibre?: boolean
    leasing?: boolean
    CMT?: boolean
    fraisMission?: boolean
    LCAS?: boolean
    faciliteCaissier?: boolean
    typeFinancement?: boolean
    maxConsumptionTolerance?: boolean
    minConsumptionTolerance?: boolean
    noSeries?: boolean
    refinancing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
    garanties?: boolean | LigneCredit$garantiesArgs<ExtArgs>
    engagements?: boolean | LigneCredit$engagementsArgs<ExtArgs>
    _count?: boolean | LigneCreditCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCredit"]>


  export type LigneCreditSelectScalar = {
    id?: boolean
    no?: boolean
    description?: boolean
    banqueId?: boolean
    autorisationNo?: boolean
    bankAccountNo?: boolean
    montantPlafond?: boolean
    montantDevise?: boolean
    taux?: boolean
    commitmentCommissionRate?: boolean
    estimatedOutstanding?: boolean
    consumption?: boolean
    outstanding?: boolean
    startDate?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    statut?: boolean
    responsibilityCenter?: boolean
    seuilAvanceSurStock?: boolean
    seuilAvanceSurFacture?: boolean
    seuilEscompte?: boolean
    seuilLC?: boolean
    seuilObligtDouane?: boolean
    seuilCautionAdmin?: boolean
    seuilDcvrtMobile?: boolean
    seuilTrsfrLibre?: boolean
    seuilLeasing?: boolean
    seuilCMT?: boolean
    seuilFraisMission?: boolean
    seuilLCAS?: boolean
    avanceSurStock?: boolean
    avanceFacture?: boolean
    escompte?: boolean
    obligatDouane?: boolean
    cautionAdmin?: boolean
    dcvrtMobile?: boolean
    trsfrLibre?: boolean
    leasing?: boolean
    CMT?: boolean
    fraisMission?: boolean
    LCAS?: boolean
    faciliteCaissier?: boolean
    typeFinancement?: boolean
    maxConsumptionTolerance?: boolean
    minConsumptionTolerance?: boolean
    noSeries?: boolean
    refinancing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LigneCreditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
    garanties?: boolean | LigneCredit$garantiesArgs<ExtArgs>
    engagements?: boolean | LigneCredit$engagementsArgs<ExtArgs>
    _count?: boolean | LigneCreditCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LigneCreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneCredit"
    objects: {
      banque: Prisma.$BanquePayload<ExtArgs>
      garanties: Prisma.$GarantiePayload<ExtArgs>[]
      engagements: Prisma.$EngagementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      no: string
      description: string | null
      banqueId: string
      autorisationNo: string
      bankAccountNo: string
      montantPlafond: number
      montantDevise: string
      taux: number
      commitmentCommissionRate: number
      estimatedOutstanding: number
      consumption: number
      outstanding: number
      startDate: Date
      expiryDate: Date
      renewalDate: Date | null
      statut: string
      responsibilityCenter: string | null
      seuilAvanceSurStock: number
      seuilAvanceSurFacture: number
      seuilEscompte: number
      seuilLC: number
      seuilObligtDouane: number
      seuilCautionAdmin: number
      seuilDcvrtMobile: number
      seuilTrsfrLibre: number
      seuilLeasing: number
      seuilCMT: number
      seuilFraisMission: number
      seuilLCAS: number
      avanceSurStock: number
      avanceFacture: number
      escompte: number
      obligatDouane: number
      cautionAdmin: number
      dcvrtMobile: number
      trsfrLibre: number
      leasing: number
      CMT: number
      fraisMission: number
      LCAS: number
      faciliteCaissier: number
      typeFinancement: string
      maxConsumptionTolerance: number
      minConsumptionTolerance: number
      noSeries: string
      refinancing: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligneCredit"]>
    composites: {}
  }

  type LigneCreditGetPayload<S extends boolean | null | undefined | LigneCreditDefaultArgs> = $Result.GetResult<Prisma.$LigneCreditPayload, S>

  type LigneCreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LigneCreditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LigneCreditCountAggregateInputType | true
    }

  export interface LigneCreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneCredit'], meta: { name: 'LigneCredit' } }
    /**
     * Find zero or one LigneCredit that matches the filter.
     * @param {LigneCreditFindUniqueArgs} args - Arguments to find a LigneCredit
     * @example
     * // Get one LigneCredit
     * const ligneCredit = await prisma.ligneCredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneCreditFindUniqueArgs>(args: SelectSubset<T, LigneCreditFindUniqueArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LigneCredit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LigneCreditFindUniqueOrThrowArgs} args - Arguments to find a LigneCredit
     * @example
     * // Get one LigneCredit
     * const ligneCredit = await prisma.ligneCredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneCreditFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneCreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LigneCredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditFindFirstArgs} args - Arguments to find a LigneCredit
     * @example
     * // Get one LigneCredit
     * const ligneCredit = await prisma.ligneCredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneCreditFindFirstArgs>(args?: SelectSubset<T, LigneCreditFindFirstArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LigneCredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditFindFirstOrThrowArgs} args - Arguments to find a LigneCredit
     * @example
     * // Get one LigneCredit
     * const ligneCredit = await prisma.ligneCredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneCreditFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneCreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LigneCredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneCredits
     * const ligneCredits = await prisma.ligneCredit.findMany()
     * 
     * // Get first 10 LigneCredits
     * const ligneCredits = await prisma.ligneCredit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneCreditWithIdOnly = await prisma.ligneCredit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneCreditFindManyArgs>(args?: SelectSubset<T, LigneCreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LigneCredit.
     * @param {LigneCreditCreateArgs} args - Arguments to create a LigneCredit.
     * @example
     * // Create one LigneCredit
     * const LigneCredit = await prisma.ligneCredit.create({
     *   data: {
     *     // ... data to create a LigneCredit
     *   }
     * })
     * 
     */
    create<T extends LigneCreditCreateArgs>(args: SelectSubset<T, LigneCreditCreateArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LigneCredits.
     * @param {LigneCreditCreateManyArgs} args - Arguments to create many LigneCredits.
     * @example
     * // Create many LigneCredits
     * const ligneCredit = await prisma.ligneCredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneCreditCreateManyArgs>(args?: SelectSubset<T, LigneCreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneCredit.
     * @param {LigneCreditDeleteArgs} args - Arguments to delete one LigneCredit.
     * @example
     * // Delete one LigneCredit
     * const LigneCredit = await prisma.ligneCredit.delete({
     *   where: {
     *     // ... filter to delete one LigneCredit
     *   }
     * })
     * 
     */
    delete<T extends LigneCreditDeleteArgs>(args: SelectSubset<T, LigneCreditDeleteArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LigneCredit.
     * @param {LigneCreditUpdateArgs} args - Arguments to update one LigneCredit.
     * @example
     * // Update one LigneCredit
     * const ligneCredit = await prisma.ligneCredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneCreditUpdateArgs>(args: SelectSubset<T, LigneCreditUpdateArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LigneCredits.
     * @param {LigneCreditDeleteManyArgs} args - Arguments to filter LigneCredits to delete.
     * @example
     * // Delete a few LigneCredits
     * const { count } = await prisma.ligneCredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneCreditDeleteManyArgs>(args?: SelectSubset<T, LigneCreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneCredits
     * const ligneCredit = await prisma.ligneCredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneCreditUpdateManyArgs>(args: SelectSubset<T, LigneCreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneCredit.
     * @param {LigneCreditUpsertArgs} args - Arguments to update or create a LigneCredit.
     * @example
     * // Update or create a LigneCredit
     * const ligneCredit = await prisma.ligneCredit.upsert({
     *   create: {
     *     // ... data to create a LigneCredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneCredit we want to update
     *   }
     * })
     */
    upsert<T extends LigneCreditUpsertArgs>(args: SelectSubset<T, LigneCreditUpsertArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LigneCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditCountArgs} args - Arguments to filter LigneCredits to count.
     * @example
     * // Count the number of LigneCredits
     * const count = await prisma.ligneCredit.count({
     *   where: {
     *     // ... the filter for the LigneCredits we want to count
     *   }
     * })
    **/
    count<T extends LigneCreditCountArgs>(
      args?: Subset<T, LigneCreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneCreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneCreditAggregateArgs>(args: Subset<T, LigneCreditAggregateArgs>): Prisma.PrismaPromise<GetLigneCreditAggregateType<T>>

    /**
     * Group by LigneCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneCreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneCreditGroupByArgs['orderBy'] }
        : { orderBy?: LigneCreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneCreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneCreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneCredit model
   */
  readonly fields: LigneCreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneCredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneCreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banque<T extends BanqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BanqueDefaultArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    garanties<T extends LigneCredit$garantiesArgs<ExtArgs> = {}>(args?: Subset<T, LigneCredit$garantiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findMany"> | Null>
    engagements<T extends LigneCredit$engagementsArgs<ExtArgs> = {}>(args?: Subset<T, LigneCredit$engagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneCredit model
   */ 
  interface LigneCreditFieldRefs {
    readonly id: FieldRef<"LigneCredit", 'String'>
    readonly no: FieldRef<"LigneCredit", 'String'>
    readonly description: FieldRef<"LigneCredit", 'String'>
    readonly banqueId: FieldRef<"LigneCredit", 'String'>
    readonly autorisationNo: FieldRef<"LigneCredit", 'String'>
    readonly bankAccountNo: FieldRef<"LigneCredit", 'String'>
    readonly montantPlafond: FieldRef<"LigneCredit", 'Float'>
    readonly montantDevise: FieldRef<"LigneCredit", 'String'>
    readonly taux: FieldRef<"LigneCredit", 'Float'>
    readonly commitmentCommissionRate: FieldRef<"LigneCredit", 'Float'>
    readonly estimatedOutstanding: FieldRef<"LigneCredit", 'Float'>
    readonly consumption: FieldRef<"LigneCredit", 'Float'>
    readonly outstanding: FieldRef<"LigneCredit", 'Float'>
    readonly startDate: FieldRef<"LigneCredit", 'DateTime'>
    readonly expiryDate: FieldRef<"LigneCredit", 'DateTime'>
    readonly renewalDate: FieldRef<"LigneCredit", 'DateTime'>
    readonly statut: FieldRef<"LigneCredit", 'String'>
    readonly responsibilityCenter: FieldRef<"LigneCredit", 'String'>
    readonly seuilAvanceSurStock: FieldRef<"LigneCredit", 'Float'>
    readonly seuilAvanceSurFacture: FieldRef<"LigneCredit", 'Float'>
    readonly seuilEscompte: FieldRef<"LigneCredit", 'Float'>
    readonly seuilLC: FieldRef<"LigneCredit", 'Float'>
    readonly seuilObligtDouane: FieldRef<"LigneCredit", 'Float'>
    readonly seuilCautionAdmin: FieldRef<"LigneCredit", 'Float'>
    readonly seuilDcvrtMobile: FieldRef<"LigneCredit", 'Float'>
    readonly seuilTrsfrLibre: FieldRef<"LigneCredit", 'Float'>
    readonly seuilLeasing: FieldRef<"LigneCredit", 'Float'>
    readonly seuilCMT: FieldRef<"LigneCredit", 'Float'>
    readonly seuilFraisMission: FieldRef<"LigneCredit", 'Float'>
    readonly seuilLCAS: FieldRef<"LigneCredit", 'Float'>
    readonly avanceSurStock: FieldRef<"LigneCredit", 'Float'>
    readonly avanceFacture: FieldRef<"LigneCredit", 'Float'>
    readonly escompte: FieldRef<"LigneCredit", 'Float'>
    readonly obligatDouane: FieldRef<"LigneCredit", 'Float'>
    readonly cautionAdmin: FieldRef<"LigneCredit", 'Float'>
    readonly dcvrtMobile: FieldRef<"LigneCredit", 'Float'>
    readonly trsfrLibre: FieldRef<"LigneCredit", 'Float'>
    readonly leasing: FieldRef<"LigneCredit", 'Float'>
    readonly CMT: FieldRef<"LigneCredit", 'Float'>
    readonly fraisMission: FieldRef<"LigneCredit", 'Float'>
    readonly LCAS: FieldRef<"LigneCredit", 'Float'>
    readonly faciliteCaissier: FieldRef<"LigneCredit", 'Float'>
    readonly typeFinancement: FieldRef<"LigneCredit", 'String'>
    readonly maxConsumptionTolerance: FieldRef<"LigneCredit", 'Float'>
    readonly minConsumptionTolerance: FieldRef<"LigneCredit", 'Float'>
    readonly noSeries: FieldRef<"LigneCredit", 'String'>
    readonly refinancing: FieldRef<"LigneCredit", 'Float'>
    readonly createdAt: FieldRef<"LigneCredit", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneCredit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneCredit findUnique
   */
  export type LigneCreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter, which LigneCredit to fetch.
     */
    where: LigneCreditWhereUniqueInput
  }

  /**
   * LigneCredit findUniqueOrThrow
   */
  export type LigneCreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter, which LigneCredit to fetch.
     */
    where: LigneCreditWhereUniqueInput
  }

  /**
   * LigneCredit findFirst
   */
  export type LigneCreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter, which LigneCredit to fetch.
     */
    where?: LigneCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCredits to fetch.
     */
    orderBy?: LigneCreditOrderByWithRelationInput | LigneCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCredits.
     */
    cursor?: LigneCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCredits.
     */
    distinct?: LigneCreditScalarFieldEnum | LigneCreditScalarFieldEnum[]
  }

  /**
   * LigneCredit findFirstOrThrow
   */
  export type LigneCreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter, which LigneCredit to fetch.
     */
    where?: LigneCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCredits to fetch.
     */
    orderBy?: LigneCreditOrderByWithRelationInput | LigneCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCredits.
     */
    cursor?: LigneCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCredits.
     */
    distinct?: LigneCreditScalarFieldEnum | LigneCreditScalarFieldEnum[]
  }

  /**
   * LigneCredit findMany
   */
  export type LigneCreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter, which LigneCredits to fetch.
     */
    where?: LigneCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCredits to fetch.
     */
    orderBy?: LigneCreditOrderByWithRelationInput | LigneCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneCredits.
     */
    cursor?: LigneCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCredits.
     */
    skip?: number
    distinct?: LigneCreditScalarFieldEnum | LigneCreditScalarFieldEnum[]
  }

  /**
   * LigneCredit create
   */
  export type LigneCreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneCredit.
     */
    data: XOR<LigneCreditCreateInput, LigneCreditUncheckedCreateInput>
  }

  /**
   * LigneCredit createMany
   */
  export type LigneCreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneCredits.
     */
    data: LigneCreditCreateManyInput | LigneCreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneCredit update
   */
  export type LigneCreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneCredit.
     */
    data: XOR<LigneCreditUpdateInput, LigneCreditUncheckedUpdateInput>
    /**
     * Choose, which LigneCredit to update.
     */
    where: LigneCreditWhereUniqueInput
  }

  /**
   * LigneCredit updateMany
   */
  export type LigneCreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneCredits.
     */
    data: XOR<LigneCreditUpdateManyMutationInput, LigneCreditUncheckedUpdateManyInput>
    /**
     * Filter which LigneCredits to update
     */
    where?: LigneCreditWhereInput
  }

  /**
   * LigneCredit upsert
   */
  export type LigneCreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneCredit to update in case it exists.
     */
    where: LigneCreditWhereUniqueInput
    /**
     * In case the LigneCredit found by the `where` argument doesn't exist, create a new LigneCredit with this data.
     */
    create: XOR<LigneCreditCreateInput, LigneCreditUncheckedCreateInput>
    /**
     * In case the LigneCredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneCreditUpdateInput, LigneCreditUncheckedUpdateInput>
  }

  /**
   * LigneCredit delete
   */
  export type LigneCreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    /**
     * Filter which LigneCredit to delete.
     */
    where: LigneCreditWhereUniqueInput
  }

  /**
   * LigneCredit deleteMany
   */
  export type LigneCreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCredits to delete
     */
    where?: LigneCreditWhereInput
  }

  /**
   * LigneCredit.garanties
   */
  export type LigneCredit$garantiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    where?: GarantieWhereInput
    orderBy?: GarantieOrderByWithRelationInput | GarantieOrderByWithRelationInput[]
    cursor?: GarantieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GarantieScalarFieldEnum | GarantieScalarFieldEnum[]
  }

  /**
   * LigneCredit.engagements
   */
  export type LigneCredit$engagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    where?: EngagementWhereInput
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    cursor?: EngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * LigneCredit without action
   */
  export type LigneCreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
  }


  /**
   * Model Garantie
   */

  export type AggregateGarantie = {
    _count: GarantieCountAggregateOutputType | null
    _avg: GarantieAvgAggregateOutputType | null
    _sum: GarantieSumAggregateOutputType | null
    _min: GarantieMinAggregateOutputType | null
    _max: GarantieMaxAggregateOutputType | null
  }

  export type GarantieAvgAggregateOutputType = {
    montant: number | null
  }

  export type GarantieSumAggregateOutputType = {
    montant: number | null
  }

  export type GarantieMinAggregateOutputType = {
    id: string | null
    ligneCreditId: string | null
    type: string | null
    montant: number | null
    dateExpiration: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type GarantieMaxAggregateOutputType = {
    id: string | null
    ligneCreditId: string | null
    type: string | null
    montant: number | null
    dateExpiration: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type GarantieCountAggregateOutputType = {
    id: number
    ligneCreditId: number
    type: number
    montant: number
    dateExpiration: number
    description: number
    createdAt: number
    _all: number
  }


  export type GarantieAvgAggregateInputType = {
    montant?: true
  }

  export type GarantieSumAggregateInputType = {
    montant?: true
  }

  export type GarantieMinAggregateInputType = {
    id?: true
    ligneCreditId?: true
    type?: true
    montant?: true
    dateExpiration?: true
    description?: true
    createdAt?: true
  }

  export type GarantieMaxAggregateInputType = {
    id?: true
    ligneCreditId?: true
    type?: true
    montant?: true
    dateExpiration?: true
    description?: true
    createdAt?: true
  }

  export type GarantieCountAggregateInputType = {
    id?: true
    ligneCreditId?: true
    type?: true
    montant?: true
    dateExpiration?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type GarantieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Garantie to aggregate.
     */
    where?: GarantieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Garanties to fetch.
     */
    orderBy?: GarantieOrderByWithRelationInput | GarantieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GarantieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Garanties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Garanties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Garanties
    **/
    _count?: true | GarantieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GarantieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GarantieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GarantieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GarantieMaxAggregateInputType
  }

  export type GetGarantieAggregateType<T extends GarantieAggregateArgs> = {
        [P in keyof T & keyof AggregateGarantie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGarantie[P]>
      : GetScalarType<T[P], AggregateGarantie[P]>
  }




  export type GarantieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GarantieWhereInput
    orderBy?: GarantieOrderByWithAggregationInput | GarantieOrderByWithAggregationInput[]
    by: GarantieScalarFieldEnum[] | GarantieScalarFieldEnum
    having?: GarantieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GarantieCountAggregateInputType | true
    _avg?: GarantieAvgAggregateInputType
    _sum?: GarantieSumAggregateInputType
    _min?: GarantieMinAggregateInputType
    _max?: GarantieMaxAggregateInputType
  }

  export type GarantieGroupByOutputType = {
    id: string
    ligneCreditId: string
    type: string
    montant: number
    dateExpiration: Date
    description: string | null
    createdAt: Date
    _count: GarantieCountAggregateOutputType | null
    _avg: GarantieAvgAggregateOutputType | null
    _sum: GarantieSumAggregateOutputType | null
    _min: GarantieMinAggregateOutputType | null
    _max: GarantieMaxAggregateOutputType | null
  }

  type GetGarantieGroupByPayload<T extends GarantieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GarantieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GarantieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GarantieGroupByOutputType[P]>
            : GetScalarType<T[P], GarantieGroupByOutputType[P]>
        }
      >
    >


  export type GarantieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ligneCreditId?: boolean
    type?: boolean
    montant?: boolean
    dateExpiration?: boolean
    description?: boolean
    createdAt?: boolean
    ligneCredit?: boolean | LigneCreditDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["garantie"]>


  export type GarantieSelectScalar = {
    id?: boolean
    ligneCreditId?: boolean
    type?: boolean
    montant?: boolean
    dateExpiration?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type GarantieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ligneCredit?: boolean | LigneCreditDefaultArgs<ExtArgs>
  }

  export type $GarantiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Garantie"
    objects: {
      ligneCredit: Prisma.$LigneCreditPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ligneCreditId: string
      type: string
      montant: number
      dateExpiration: Date
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["garantie"]>
    composites: {}
  }

  type GarantieGetPayload<S extends boolean | null | undefined | GarantieDefaultArgs> = $Result.GetResult<Prisma.$GarantiePayload, S>

  type GarantieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GarantieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GarantieCountAggregateInputType | true
    }

  export interface GarantieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Garantie'], meta: { name: 'Garantie' } }
    /**
     * Find zero or one Garantie that matches the filter.
     * @param {GarantieFindUniqueArgs} args - Arguments to find a Garantie
     * @example
     * // Get one Garantie
     * const garantie = await prisma.garantie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GarantieFindUniqueArgs>(args: SelectSubset<T, GarantieFindUniqueArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Garantie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GarantieFindUniqueOrThrowArgs} args - Arguments to find a Garantie
     * @example
     * // Get one Garantie
     * const garantie = await prisma.garantie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GarantieFindUniqueOrThrowArgs>(args: SelectSubset<T, GarantieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Garantie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieFindFirstArgs} args - Arguments to find a Garantie
     * @example
     * // Get one Garantie
     * const garantie = await prisma.garantie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GarantieFindFirstArgs>(args?: SelectSubset<T, GarantieFindFirstArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Garantie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieFindFirstOrThrowArgs} args - Arguments to find a Garantie
     * @example
     * // Get one Garantie
     * const garantie = await prisma.garantie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GarantieFindFirstOrThrowArgs>(args?: SelectSubset<T, GarantieFindFirstOrThrowArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Garanties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Garanties
     * const garanties = await prisma.garantie.findMany()
     * 
     * // Get first 10 Garanties
     * const garanties = await prisma.garantie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const garantieWithIdOnly = await prisma.garantie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GarantieFindManyArgs>(args?: SelectSubset<T, GarantieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Garantie.
     * @param {GarantieCreateArgs} args - Arguments to create a Garantie.
     * @example
     * // Create one Garantie
     * const Garantie = await prisma.garantie.create({
     *   data: {
     *     // ... data to create a Garantie
     *   }
     * })
     * 
     */
    create<T extends GarantieCreateArgs>(args: SelectSubset<T, GarantieCreateArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Garanties.
     * @param {GarantieCreateManyArgs} args - Arguments to create many Garanties.
     * @example
     * // Create many Garanties
     * const garantie = await prisma.garantie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GarantieCreateManyArgs>(args?: SelectSubset<T, GarantieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Garantie.
     * @param {GarantieDeleteArgs} args - Arguments to delete one Garantie.
     * @example
     * // Delete one Garantie
     * const Garantie = await prisma.garantie.delete({
     *   where: {
     *     // ... filter to delete one Garantie
     *   }
     * })
     * 
     */
    delete<T extends GarantieDeleteArgs>(args: SelectSubset<T, GarantieDeleteArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Garantie.
     * @param {GarantieUpdateArgs} args - Arguments to update one Garantie.
     * @example
     * // Update one Garantie
     * const garantie = await prisma.garantie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GarantieUpdateArgs>(args: SelectSubset<T, GarantieUpdateArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Garanties.
     * @param {GarantieDeleteManyArgs} args - Arguments to filter Garanties to delete.
     * @example
     * // Delete a few Garanties
     * const { count } = await prisma.garantie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GarantieDeleteManyArgs>(args?: SelectSubset<T, GarantieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Garanties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Garanties
     * const garantie = await prisma.garantie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GarantieUpdateManyArgs>(args: SelectSubset<T, GarantieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Garantie.
     * @param {GarantieUpsertArgs} args - Arguments to update or create a Garantie.
     * @example
     * // Update or create a Garantie
     * const garantie = await prisma.garantie.upsert({
     *   create: {
     *     // ... data to create a Garantie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Garantie we want to update
     *   }
     * })
     */
    upsert<T extends GarantieUpsertArgs>(args: SelectSubset<T, GarantieUpsertArgs<ExtArgs>>): Prisma__GarantieClient<$Result.GetResult<Prisma.$GarantiePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Garanties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieCountArgs} args - Arguments to filter Garanties to count.
     * @example
     * // Count the number of Garanties
     * const count = await prisma.garantie.count({
     *   where: {
     *     // ... the filter for the Garanties we want to count
     *   }
     * })
    **/
    count<T extends GarantieCountArgs>(
      args?: Subset<T, GarantieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GarantieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Garantie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GarantieAggregateArgs>(args: Subset<T, GarantieAggregateArgs>): Prisma.PrismaPromise<GetGarantieAggregateType<T>>

    /**
     * Group by Garantie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GarantieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GarantieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GarantieGroupByArgs['orderBy'] }
        : { orderBy?: GarantieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GarantieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGarantieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Garantie model
   */
  readonly fields: GarantieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Garantie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GarantieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ligneCredit<T extends LigneCreditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LigneCreditDefaultArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Garantie model
   */ 
  interface GarantieFieldRefs {
    readonly id: FieldRef<"Garantie", 'String'>
    readonly ligneCreditId: FieldRef<"Garantie", 'String'>
    readonly type: FieldRef<"Garantie", 'String'>
    readonly montant: FieldRef<"Garantie", 'Float'>
    readonly dateExpiration: FieldRef<"Garantie", 'DateTime'>
    readonly description: FieldRef<"Garantie", 'String'>
    readonly createdAt: FieldRef<"Garantie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Garantie findUnique
   */
  export type GarantieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter, which Garantie to fetch.
     */
    where: GarantieWhereUniqueInput
  }

  /**
   * Garantie findUniqueOrThrow
   */
  export type GarantieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter, which Garantie to fetch.
     */
    where: GarantieWhereUniqueInput
  }

  /**
   * Garantie findFirst
   */
  export type GarantieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter, which Garantie to fetch.
     */
    where?: GarantieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Garanties to fetch.
     */
    orderBy?: GarantieOrderByWithRelationInput | GarantieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Garanties.
     */
    cursor?: GarantieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Garanties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Garanties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Garanties.
     */
    distinct?: GarantieScalarFieldEnum | GarantieScalarFieldEnum[]
  }

  /**
   * Garantie findFirstOrThrow
   */
  export type GarantieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter, which Garantie to fetch.
     */
    where?: GarantieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Garanties to fetch.
     */
    orderBy?: GarantieOrderByWithRelationInput | GarantieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Garanties.
     */
    cursor?: GarantieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Garanties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Garanties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Garanties.
     */
    distinct?: GarantieScalarFieldEnum | GarantieScalarFieldEnum[]
  }

  /**
   * Garantie findMany
   */
  export type GarantieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter, which Garanties to fetch.
     */
    where?: GarantieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Garanties to fetch.
     */
    orderBy?: GarantieOrderByWithRelationInput | GarantieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Garanties.
     */
    cursor?: GarantieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Garanties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Garanties.
     */
    skip?: number
    distinct?: GarantieScalarFieldEnum | GarantieScalarFieldEnum[]
  }

  /**
   * Garantie create
   */
  export type GarantieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * The data needed to create a Garantie.
     */
    data: XOR<GarantieCreateInput, GarantieUncheckedCreateInput>
  }

  /**
   * Garantie createMany
   */
  export type GarantieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Garanties.
     */
    data: GarantieCreateManyInput | GarantieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Garantie update
   */
  export type GarantieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * The data needed to update a Garantie.
     */
    data: XOR<GarantieUpdateInput, GarantieUncheckedUpdateInput>
    /**
     * Choose, which Garantie to update.
     */
    where: GarantieWhereUniqueInput
  }

  /**
   * Garantie updateMany
   */
  export type GarantieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Garanties.
     */
    data: XOR<GarantieUpdateManyMutationInput, GarantieUncheckedUpdateManyInput>
    /**
     * Filter which Garanties to update
     */
    where?: GarantieWhereInput
  }

  /**
   * Garantie upsert
   */
  export type GarantieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * The filter to search for the Garantie to update in case it exists.
     */
    where: GarantieWhereUniqueInput
    /**
     * In case the Garantie found by the `where` argument doesn't exist, create a new Garantie with this data.
     */
    create: XOR<GarantieCreateInput, GarantieUncheckedCreateInput>
    /**
     * In case the Garantie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GarantieUpdateInput, GarantieUncheckedUpdateInput>
  }

  /**
   * Garantie delete
   */
  export type GarantieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
    /**
     * Filter which Garantie to delete.
     */
    where: GarantieWhereUniqueInput
  }

  /**
   * Garantie deleteMany
   */
  export type GarantieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Garanties to delete
     */
    where?: GarantieWhereInput
  }

  /**
   * Garantie without action
   */
  export type GarantieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garantie
     */
    select?: GarantieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GarantieInclude<ExtArgs> | null
  }


  /**
   * Model Engagement
   */

  export type AggregateEngagement = {
    _count: EngagementCountAggregateOutputType | null
    _avg: EngagementAvgAggregateOutputType | null
    _sum: EngagementSumAggregateOutputType | null
    _min: EngagementMinAggregateOutputType | null
    _max: EngagementMaxAggregateOutputType | null
  }

  export type EngagementAvgAggregateOutputType = {
    montant: number | null
  }

  export type EngagementSumAggregateOutputType = {
    montant: number | null
  }

  export type EngagementMinAggregateOutputType = {
    id: string | null
    ligneCreditId: string | null
    typeFinancement: string | null
    montant: number | null
    devise: string | null
    dateEngagement: Date | null
    dateEcheance: Date | null
    statut: string | null
    referenceDossier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowTemplateId: string | null
    workflowStepId: string | null
    parentEngagementId: string | null
  }

  export type EngagementMaxAggregateOutputType = {
    id: string | null
    ligneCreditId: string | null
    typeFinancement: string | null
    montant: number | null
    devise: string | null
    dateEngagement: Date | null
    dateEcheance: Date | null
    statut: string | null
    referenceDossier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowTemplateId: string | null
    workflowStepId: string | null
    parentEngagementId: string | null
  }

  export type EngagementCountAggregateOutputType = {
    id: number
    ligneCreditId: number
    typeFinancement: number
    montant: number
    devise: number
    dateEngagement: number
    dateEcheance: number
    statut: number
    referenceDossier: number
    createdAt: number
    updatedAt: number
    workflowTemplateId: number
    workflowStepId: number
    parentEngagementId: number
    _all: number
  }


  export type EngagementAvgAggregateInputType = {
    montant?: true
  }

  export type EngagementSumAggregateInputType = {
    montant?: true
  }

  export type EngagementMinAggregateInputType = {
    id?: true
    ligneCreditId?: true
    typeFinancement?: true
    montant?: true
    devise?: true
    dateEngagement?: true
    dateEcheance?: true
    statut?: true
    referenceDossier?: true
    createdAt?: true
    updatedAt?: true
    workflowTemplateId?: true
    workflowStepId?: true
    parentEngagementId?: true
  }

  export type EngagementMaxAggregateInputType = {
    id?: true
    ligneCreditId?: true
    typeFinancement?: true
    montant?: true
    devise?: true
    dateEngagement?: true
    dateEcheance?: true
    statut?: true
    referenceDossier?: true
    createdAt?: true
    updatedAt?: true
    workflowTemplateId?: true
    workflowStepId?: true
    parentEngagementId?: true
  }

  export type EngagementCountAggregateInputType = {
    id?: true
    ligneCreditId?: true
    typeFinancement?: true
    montant?: true
    devise?: true
    dateEngagement?: true
    dateEcheance?: true
    statut?: true
    referenceDossier?: true
    createdAt?: true
    updatedAt?: true
    workflowTemplateId?: true
    workflowStepId?: true
    parentEngagementId?: true
    _all?: true
  }

  export type EngagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Engagement to aggregate.
     */
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     */
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Engagements
    **/
    _count?: true | EngagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EngagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EngagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementMaxAggregateInputType
  }

  export type GetEngagementAggregateType<T extends EngagementAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagement[P]>
      : GetScalarType<T[P], AggregateEngagement[P]>
  }




  export type EngagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementWhereInput
    orderBy?: EngagementOrderByWithAggregationInput | EngagementOrderByWithAggregationInput[]
    by: EngagementScalarFieldEnum[] | EngagementScalarFieldEnum
    having?: EngagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementCountAggregateInputType | true
    _avg?: EngagementAvgAggregateInputType
    _sum?: EngagementSumAggregateInputType
    _min?: EngagementMinAggregateInputType
    _max?: EngagementMaxAggregateInputType
  }

  export type EngagementGroupByOutputType = {
    id: string
    ligneCreditId: string | null
    typeFinancement: string
    montant: number | null
    devise: string | null
    dateEngagement: Date | null
    dateEcheance: Date | null
    statut: string
    referenceDossier: string
    createdAt: Date
    updatedAt: Date
    workflowTemplateId: string | null
    workflowStepId: string | null
    parentEngagementId: string | null
    _count: EngagementCountAggregateOutputType | null
    _avg: EngagementAvgAggregateOutputType | null
    _sum: EngagementSumAggregateOutputType | null
    _min: EngagementMinAggregateOutputType | null
    _max: EngagementMaxAggregateOutputType | null
  }

  type GetEngagementGroupByPayload<T extends EngagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EngagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementGroupByOutputType[P]>
        }
      >
    >


  export type EngagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ligneCreditId?: boolean
    typeFinancement?: boolean
    montant?: boolean
    devise?: boolean
    dateEngagement?: boolean
    dateEcheance?: boolean
    statut?: boolean
    referenceDossier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowTemplateId?: boolean
    workflowStepId?: boolean
    parentEngagementId?: boolean
    ligneCredit?: boolean | Engagement$ligneCreditArgs<ExtArgs>
    workflowTemplate?: boolean | Engagement$workflowTemplateArgs<ExtArgs>
    workflowStep?: boolean | Engagement$workflowStepArgs<ExtArgs>
    parentEngagement?: boolean | Engagement$parentEngagementArgs<ExtArgs>
    childEngagements?: boolean | Engagement$childEngagementsArgs<ExtArgs>
    stepCompletions?: boolean | Engagement$stepCompletionsArgs<ExtArgs>
    _count?: boolean | EngagementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagement"]>


  export type EngagementSelectScalar = {
    id?: boolean
    ligneCreditId?: boolean
    typeFinancement?: boolean
    montant?: boolean
    devise?: boolean
    dateEngagement?: boolean
    dateEcheance?: boolean
    statut?: boolean
    referenceDossier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowTemplateId?: boolean
    workflowStepId?: boolean
    parentEngagementId?: boolean
  }

  export type EngagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ligneCredit?: boolean | Engagement$ligneCreditArgs<ExtArgs>
    workflowTemplate?: boolean | Engagement$workflowTemplateArgs<ExtArgs>
    workflowStep?: boolean | Engagement$workflowStepArgs<ExtArgs>
    parentEngagement?: boolean | Engagement$parentEngagementArgs<ExtArgs>
    childEngagements?: boolean | Engagement$childEngagementsArgs<ExtArgs>
    stepCompletions?: boolean | Engagement$stepCompletionsArgs<ExtArgs>
    _count?: boolean | EngagementCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EngagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Engagement"
    objects: {
      ligneCredit: Prisma.$LigneCreditPayload<ExtArgs> | null
      workflowTemplate: Prisma.$WorkflowTemplatePayload<ExtArgs> | null
      workflowStep: Prisma.$WorkflowStepPayload<ExtArgs> | null
      parentEngagement: Prisma.$EngagementPayload<ExtArgs> | null
      childEngagements: Prisma.$EngagementPayload<ExtArgs>[]
      stepCompletions: Prisma.$StepCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ligneCreditId: string | null
      typeFinancement: string
      montant: number | null
      devise: string | null
      dateEngagement: Date | null
      dateEcheance: Date | null
      statut: string
      referenceDossier: string
      createdAt: Date
      updatedAt: Date
      workflowTemplateId: string | null
      workflowStepId: string | null
      parentEngagementId: string | null
    }, ExtArgs["result"]["engagement"]>
    composites: {}
  }

  type EngagementGetPayload<S extends boolean | null | undefined | EngagementDefaultArgs> = $Result.GetResult<Prisma.$EngagementPayload, S>

  type EngagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EngagementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EngagementCountAggregateInputType | true
    }

  export interface EngagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Engagement'], meta: { name: 'Engagement' } }
    /**
     * Find zero or one Engagement that matches the filter.
     * @param {EngagementFindUniqueArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EngagementFindUniqueArgs>(args: SelectSubset<T, EngagementFindUniqueArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Engagement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EngagementFindUniqueOrThrowArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EngagementFindUniqueOrThrowArgs>(args: SelectSubset<T, EngagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Engagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementFindFirstArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EngagementFindFirstArgs>(args?: SelectSubset<T, EngagementFindFirstArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Engagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementFindFirstOrThrowArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EngagementFindFirstOrThrowArgs>(args?: SelectSubset<T, EngagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Engagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Engagements
     * const engagements = await prisma.engagement.findMany()
     * 
     * // Get first 10 Engagements
     * const engagements = await prisma.engagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementWithIdOnly = await prisma.engagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EngagementFindManyArgs>(args?: SelectSubset<T, EngagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Engagement.
     * @param {EngagementCreateArgs} args - Arguments to create a Engagement.
     * @example
     * // Create one Engagement
     * const Engagement = await prisma.engagement.create({
     *   data: {
     *     // ... data to create a Engagement
     *   }
     * })
     * 
     */
    create<T extends EngagementCreateArgs>(args: SelectSubset<T, EngagementCreateArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Engagements.
     * @param {EngagementCreateManyArgs} args - Arguments to create many Engagements.
     * @example
     * // Create many Engagements
     * const engagement = await prisma.engagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EngagementCreateManyArgs>(args?: SelectSubset<T, EngagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Engagement.
     * @param {EngagementDeleteArgs} args - Arguments to delete one Engagement.
     * @example
     * // Delete one Engagement
     * const Engagement = await prisma.engagement.delete({
     *   where: {
     *     // ... filter to delete one Engagement
     *   }
     * })
     * 
     */
    delete<T extends EngagementDeleteArgs>(args: SelectSubset<T, EngagementDeleteArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Engagement.
     * @param {EngagementUpdateArgs} args - Arguments to update one Engagement.
     * @example
     * // Update one Engagement
     * const engagement = await prisma.engagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EngagementUpdateArgs>(args: SelectSubset<T, EngagementUpdateArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Engagements.
     * @param {EngagementDeleteManyArgs} args - Arguments to filter Engagements to delete.
     * @example
     * // Delete a few Engagements
     * const { count } = await prisma.engagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EngagementDeleteManyArgs>(args?: SelectSubset<T, EngagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Engagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Engagements
     * const engagement = await prisma.engagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EngagementUpdateManyArgs>(args: SelectSubset<T, EngagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Engagement.
     * @param {EngagementUpsertArgs} args - Arguments to update or create a Engagement.
     * @example
     * // Update or create a Engagement
     * const engagement = await prisma.engagement.upsert({
     *   create: {
     *     // ... data to create a Engagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Engagement we want to update
     *   }
     * })
     */
    upsert<T extends EngagementUpsertArgs>(args: SelectSubset<T, EngagementUpsertArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Engagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementCountArgs} args - Arguments to filter Engagements to count.
     * @example
     * // Count the number of Engagements
     * const count = await prisma.engagement.count({
     *   where: {
     *     // ... the filter for the Engagements we want to count
     *   }
     * })
    **/
    count<T extends EngagementCountArgs>(
      args?: Subset<T, EngagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Engagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementAggregateArgs>(args: Subset<T, EngagementAggregateArgs>): Prisma.PrismaPromise<GetEngagementAggregateType<T>>

    /**
     * Group by Engagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementGroupByArgs['orderBy'] }
        : { orderBy?: EngagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Engagement model
   */
  readonly fields: EngagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Engagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EngagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ligneCredit<T extends Engagement$ligneCreditArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$ligneCreditArgs<ExtArgs>>): Prisma__LigneCreditClient<$Result.GetResult<Prisma.$LigneCreditPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workflowTemplate<T extends Engagement$workflowTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$workflowTemplateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workflowStep<T extends Engagement$workflowStepArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$workflowStepArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parentEngagement<T extends Engagement$parentEngagementArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$parentEngagementArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childEngagements<T extends Engagement$childEngagementsArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$childEngagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findMany"> | Null>
    stepCompletions<T extends Engagement$stepCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, Engagement$stepCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Engagement model
   */ 
  interface EngagementFieldRefs {
    readonly id: FieldRef<"Engagement", 'String'>
    readonly ligneCreditId: FieldRef<"Engagement", 'String'>
    readonly typeFinancement: FieldRef<"Engagement", 'String'>
    readonly montant: FieldRef<"Engagement", 'Float'>
    readonly devise: FieldRef<"Engagement", 'String'>
    readonly dateEngagement: FieldRef<"Engagement", 'DateTime'>
    readonly dateEcheance: FieldRef<"Engagement", 'DateTime'>
    readonly statut: FieldRef<"Engagement", 'String'>
    readonly referenceDossier: FieldRef<"Engagement", 'String'>
    readonly createdAt: FieldRef<"Engagement", 'DateTime'>
    readonly updatedAt: FieldRef<"Engagement", 'DateTime'>
    readonly workflowTemplateId: FieldRef<"Engagement", 'String'>
    readonly workflowStepId: FieldRef<"Engagement", 'String'>
    readonly parentEngagementId: FieldRef<"Engagement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Engagement findUnique
   */
  export type EngagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter, which Engagement to fetch.
     */
    where: EngagementWhereUniqueInput
  }

  /**
   * Engagement findUniqueOrThrow
   */
  export type EngagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter, which Engagement to fetch.
     */
    where: EngagementWhereUniqueInput
  }

  /**
   * Engagement findFirst
   */
  export type EngagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter, which Engagement to fetch.
     */
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     */
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Engagements.
     */
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Engagements.
     */
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * Engagement findFirstOrThrow
   */
  export type EngagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter, which Engagement to fetch.
     */
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     */
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Engagements.
     */
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Engagements.
     */
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * Engagement findMany
   */
  export type EngagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter, which Engagements to fetch.
     */
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     */
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Engagements.
     */
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     */
    skip?: number
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * Engagement create
   */
  export type EngagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * The data needed to create a Engagement.
     */
    data: XOR<EngagementCreateInput, EngagementUncheckedCreateInput>
  }

  /**
   * Engagement createMany
   */
  export type EngagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Engagements.
     */
    data: EngagementCreateManyInput | EngagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Engagement update
   */
  export type EngagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * The data needed to update a Engagement.
     */
    data: XOR<EngagementUpdateInput, EngagementUncheckedUpdateInput>
    /**
     * Choose, which Engagement to update.
     */
    where: EngagementWhereUniqueInput
  }

  /**
   * Engagement updateMany
   */
  export type EngagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Engagements.
     */
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyInput>
    /**
     * Filter which Engagements to update
     */
    where?: EngagementWhereInput
  }

  /**
   * Engagement upsert
   */
  export type EngagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * The filter to search for the Engagement to update in case it exists.
     */
    where: EngagementWhereUniqueInput
    /**
     * In case the Engagement found by the `where` argument doesn't exist, create a new Engagement with this data.
     */
    create: XOR<EngagementCreateInput, EngagementUncheckedCreateInput>
    /**
     * In case the Engagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EngagementUpdateInput, EngagementUncheckedUpdateInput>
  }

  /**
   * Engagement delete
   */
  export type EngagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    /**
     * Filter which Engagement to delete.
     */
    where: EngagementWhereUniqueInput
  }

  /**
   * Engagement deleteMany
   */
  export type EngagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Engagements to delete
     */
    where?: EngagementWhereInput
  }

  /**
   * Engagement.ligneCredit
   */
  export type Engagement$ligneCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCredit
     */
    select?: LigneCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCreditInclude<ExtArgs> | null
    where?: LigneCreditWhereInput
  }

  /**
   * Engagement.workflowTemplate
   */
  export type Engagement$workflowTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    where?: WorkflowTemplateWhereInput
  }

  /**
   * Engagement.workflowStep
   */
  export type Engagement$workflowStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
  }

  /**
   * Engagement.parentEngagement
   */
  export type Engagement$parentEngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    where?: EngagementWhereInput
  }

  /**
   * Engagement.childEngagements
   */
  export type Engagement$childEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    where?: EngagementWhereInput
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    cursor?: EngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * Engagement.stepCompletions
   */
  export type Engagement$stepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    where?: StepCompletionWhereInput
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    cursor?: StepCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * Engagement without action
   */
  export type EngagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
  }


  /**
   * Model StepCompletion
   */

  export type AggregateStepCompletion = {
    _count: StepCompletionCountAggregateOutputType | null
    _min: StepCompletionMinAggregateOutputType | null
    _max: StepCompletionMaxAggregateOutputType | null
  }

  export type StepCompletionMinAggregateOutputType = {
    id: string | null
    engagementId: string | null
    workflowStepId: string | null
    fieldData: string | null
    documents: string | null
    completedBy: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    notes: string | null
  }

  export type StepCompletionMaxAggregateOutputType = {
    id: string | null
    engagementId: string | null
    workflowStepId: string | null
    fieldData: string | null
    documents: string | null
    completedBy: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    notes: string | null
  }

  export type StepCompletionCountAggregateOutputType = {
    id: number
    engagementId: number
    workflowStepId: number
    fieldData: number
    documents: number
    completedBy: number
    completedAt: number
    createdAt: number
    updatedAt: number
    notes: number
    _all: number
  }


  export type StepCompletionMinAggregateInputType = {
    id?: true
    engagementId?: true
    workflowStepId?: true
    fieldData?: true
    documents?: true
    completedBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
  }

  export type StepCompletionMaxAggregateInputType = {
    id?: true
    engagementId?: true
    workflowStepId?: true
    fieldData?: true
    documents?: true
    completedBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
  }

  export type StepCompletionCountAggregateInputType = {
    id?: true
    engagementId?: true
    workflowStepId?: true
    fieldData?: true
    documents?: true
    completedBy?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
    _all?: true
  }

  export type StepCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepCompletion to aggregate.
     */
    where?: StepCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepCompletions to fetch.
     */
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StepCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StepCompletions
    **/
    _count?: true | StepCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StepCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StepCompletionMaxAggregateInputType
  }

  export type GetStepCompletionAggregateType<T extends StepCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateStepCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStepCompletion[P]>
      : GetScalarType<T[P], AggregateStepCompletion[P]>
  }




  export type StepCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StepCompletionWhereInput
    orderBy?: StepCompletionOrderByWithAggregationInput | StepCompletionOrderByWithAggregationInput[]
    by: StepCompletionScalarFieldEnum[] | StepCompletionScalarFieldEnum
    having?: StepCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StepCompletionCountAggregateInputType | true
    _min?: StepCompletionMinAggregateInputType
    _max?: StepCompletionMaxAggregateInputType
  }

  export type StepCompletionGroupByOutputType = {
    id: string
    engagementId: string
    workflowStepId: string
    fieldData: string | null
    documents: string | null
    completedBy: string | null
    completedAt: Date
    createdAt: Date
    updatedAt: Date
    notes: string | null
    _count: StepCompletionCountAggregateOutputType | null
    _min: StepCompletionMinAggregateOutputType | null
    _max: StepCompletionMaxAggregateOutputType | null
  }

  type GetStepCompletionGroupByPayload<T extends StepCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StepCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StepCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StepCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], StepCompletionGroupByOutputType[P]>
        }
      >
    >


  export type StepCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    engagementId?: boolean
    workflowStepId?: boolean
    fieldData?: boolean
    documents?: boolean
    completedBy?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean
    engagement?: boolean | EngagementDefaultArgs<ExtArgs>
    workflowStep?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | StepCompletion$userArgs<ExtArgs>
  }, ExtArgs["result"]["stepCompletion"]>


  export type StepCompletionSelectScalar = {
    id?: boolean
    engagementId?: boolean
    workflowStepId?: boolean
    fieldData?: boolean
    documents?: boolean
    completedBy?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean
  }

  export type StepCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    engagement?: boolean | EngagementDefaultArgs<ExtArgs>
    workflowStep?: boolean | WorkflowStepDefaultArgs<ExtArgs>
    user?: boolean | StepCompletion$userArgs<ExtArgs>
  }

  export type $StepCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StepCompletion"
    objects: {
      engagement: Prisma.$EngagementPayload<ExtArgs>
      workflowStep: Prisma.$WorkflowStepPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      engagementId: string
      workflowStepId: string
      fieldData: string | null
      documents: string | null
      completedBy: string | null
      completedAt: Date
      createdAt: Date
      updatedAt: Date
      notes: string | null
    }, ExtArgs["result"]["stepCompletion"]>
    composites: {}
  }

  type StepCompletionGetPayload<S extends boolean | null | undefined | StepCompletionDefaultArgs> = $Result.GetResult<Prisma.$StepCompletionPayload, S>

  type StepCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StepCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StepCompletionCountAggregateInputType | true
    }

  export interface StepCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StepCompletion'], meta: { name: 'StepCompletion' } }
    /**
     * Find zero or one StepCompletion that matches the filter.
     * @param {StepCompletionFindUniqueArgs} args - Arguments to find a StepCompletion
     * @example
     * // Get one StepCompletion
     * const stepCompletion = await prisma.stepCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StepCompletionFindUniqueArgs>(args: SelectSubset<T, StepCompletionFindUniqueArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StepCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StepCompletionFindUniqueOrThrowArgs} args - Arguments to find a StepCompletion
     * @example
     * // Get one StepCompletion
     * const stepCompletion = await prisma.stepCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StepCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, StepCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StepCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionFindFirstArgs} args - Arguments to find a StepCompletion
     * @example
     * // Get one StepCompletion
     * const stepCompletion = await prisma.stepCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StepCompletionFindFirstArgs>(args?: SelectSubset<T, StepCompletionFindFirstArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StepCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionFindFirstOrThrowArgs} args - Arguments to find a StepCompletion
     * @example
     * // Get one StepCompletion
     * const stepCompletion = await prisma.stepCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StepCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, StepCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StepCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StepCompletions
     * const stepCompletions = await prisma.stepCompletion.findMany()
     * 
     * // Get first 10 StepCompletions
     * const stepCompletions = await prisma.stepCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stepCompletionWithIdOnly = await prisma.stepCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StepCompletionFindManyArgs>(args?: SelectSubset<T, StepCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StepCompletion.
     * @param {StepCompletionCreateArgs} args - Arguments to create a StepCompletion.
     * @example
     * // Create one StepCompletion
     * const StepCompletion = await prisma.stepCompletion.create({
     *   data: {
     *     // ... data to create a StepCompletion
     *   }
     * })
     * 
     */
    create<T extends StepCompletionCreateArgs>(args: SelectSubset<T, StepCompletionCreateArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StepCompletions.
     * @param {StepCompletionCreateManyArgs} args - Arguments to create many StepCompletions.
     * @example
     * // Create many StepCompletions
     * const stepCompletion = await prisma.stepCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StepCompletionCreateManyArgs>(args?: SelectSubset<T, StepCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StepCompletion.
     * @param {StepCompletionDeleteArgs} args - Arguments to delete one StepCompletion.
     * @example
     * // Delete one StepCompletion
     * const StepCompletion = await prisma.stepCompletion.delete({
     *   where: {
     *     // ... filter to delete one StepCompletion
     *   }
     * })
     * 
     */
    delete<T extends StepCompletionDeleteArgs>(args: SelectSubset<T, StepCompletionDeleteArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StepCompletion.
     * @param {StepCompletionUpdateArgs} args - Arguments to update one StepCompletion.
     * @example
     * // Update one StepCompletion
     * const stepCompletion = await prisma.stepCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StepCompletionUpdateArgs>(args: SelectSubset<T, StepCompletionUpdateArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StepCompletions.
     * @param {StepCompletionDeleteManyArgs} args - Arguments to filter StepCompletions to delete.
     * @example
     * // Delete a few StepCompletions
     * const { count } = await prisma.stepCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StepCompletionDeleteManyArgs>(args?: SelectSubset<T, StepCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StepCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StepCompletions
     * const stepCompletion = await prisma.stepCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StepCompletionUpdateManyArgs>(args: SelectSubset<T, StepCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StepCompletion.
     * @param {StepCompletionUpsertArgs} args - Arguments to update or create a StepCompletion.
     * @example
     * // Update or create a StepCompletion
     * const stepCompletion = await prisma.stepCompletion.upsert({
     *   create: {
     *     // ... data to create a StepCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StepCompletion we want to update
     *   }
     * })
     */
    upsert<T extends StepCompletionUpsertArgs>(args: SelectSubset<T, StepCompletionUpsertArgs<ExtArgs>>): Prisma__StepCompletionClient<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StepCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionCountArgs} args - Arguments to filter StepCompletions to count.
     * @example
     * // Count the number of StepCompletions
     * const count = await prisma.stepCompletion.count({
     *   where: {
     *     // ... the filter for the StepCompletions we want to count
     *   }
     * })
    **/
    count<T extends StepCompletionCountArgs>(
      args?: Subset<T, StepCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StepCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StepCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StepCompletionAggregateArgs>(args: Subset<T, StepCompletionAggregateArgs>): Prisma.PrismaPromise<GetStepCompletionAggregateType<T>>

    /**
     * Group by StepCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StepCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StepCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StepCompletionGroupByArgs['orderBy'] }
        : { orderBy?: StepCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StepCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStepCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StepCompletion model
   */
  readonly fields: StepCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StepCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StepCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    engagement<T extends EngagementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EngagementDefaultArgs<ExtArgs>>): Prisma__EngagementClient<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflowStep<T extends WorkflowStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepDefaultArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends StepCompletion$userArgs<ExtArgs> = {}>(args?: Subset<T, StepCompletion$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StepCompletion model
   */ 
  interface StepCompletionFieldRefs {
    readonly id: FieldRef<"StepCompletion", 'String'>
    readonly engagementId: FieldRef<"StepCompletion", 'String'>
    readonly workflowStepId: FieldRef<"StepCompletion", 'String'>
    readonly fieldData: FieldRef<"StepCompletion", 'String'>
    readonly documents: FieldRef<"StepCompletion", 'String'>
    readonly completedBy: FieldRef<"StepCompletion", 'String'>
    readonly completedAt: FieldRef<"StepCompletion", 'DateTime'>
    readonly createdAt: FieldRef<"StepCompletion", 'DateTime'>
    readonly updatedAt: FieldRef<"StepCompletion", 'DateTime'>
    readonly notes: FieldRef<"StepCompletion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StepCompletion findUnique
   */
  export type StepCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter, which StepCompletion to fetch.
     */
    where: StepCompletionWhereUniqueInput
  }

  /**
   * StepCompletion findUniqueOrThrow
   */
  export type StepCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter, which StepCompletion to fetch.
     */
    where: StepCompletionWhereUniqueInput
  }

  /**
   * StepCompletion findFirst
   */
  export type StepCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter, which StepCompletion to fetch.
     */
    where?: StepCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepCompletions to fetch.
     */
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepCompletions.
     */
    cursor?: StepCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepCompletions.
     */
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * StepCompletion findFirstOrThrow
   */
  export type StepCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter, which StepCompletion to fetch.
     */
    where?: StepCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepCompletions to fetch.
     */
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StepCompletions.
     */
    cursor?: StepCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StepCompletions.
     */
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * StepCompletion findMany
   */
  export type StepCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter, which StepCompletions to fetch.
     */
    where?: StepCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StepCompletions to fetch.
     */
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StepCompletions.
     */
    cursor?: StepCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StepCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StepCompletions.
     */
    skip?: number
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * StepCompletion create
   */
  export type StepCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a StepCompletion.
     */
    data: XOR<StepCompletionCreateInput, StepCompletionUncheckedCreateInput>
  }

  /**
   * StepCompletion createMany
   */
  export type StepCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StepCompletions.
     */
    data: StepCompletionCreateManyInput | StepCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StepCompletion update
   */
  export type StepCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a StepCompletion.
     */
    data: XOR<StepCompletionUpdateInput, StepCompletionUncheckedUpdateInput>
    /**
     * Choose, which StepCompletion to update.
     */
    where: StepCompletionWhereUniqueInput
  }

  /**
   * StepCompletion updateMany
   */
  export type StepCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StepCompletions.
     */
    data: XOR<StepCompletionUpdateManyMutationInput, StepCompletionUncheckedUpdateManyInput>
    /**
     * Filter which StepCompletions to update
     */
    where?: StepCompletionWhereInput
  }

  /**
   * StepCompletion upsert
   */
  export type StepCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the StepCompletion to update in case it exists.
     */
    where: StepCompletionWhereUniqueInput
    /**
     * In case the StepCompletion found by the `where` argument doesn't exist, create a new StepCompletion with this data.
     */
    create: XOR<StepCompletionCreateInput, StepCompletionUncheckedCreateInput>
    /**
     * In case the StepCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StepCompletionUpdateInput, StepCompletionUncheckedUpdateInput>
  }

  /**
   * StepCompletion delete
   */
  export type StepCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    /**
     * Filter which StepCompletion to delete.
     */
    where: StepCompletionWhereUniqueInput
  }

  /**
   * StepCompletion deleteMany
   */
  export type StepCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StepCompletions to delete
     */
    where?: StepCompletionWhereInput
  }

  /**
   * StepCompletion.user
   */
  export type StepCompletion$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * StepCompletion without action
   */
  export type StepCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
  }


  /**
   * Model SwiftMessage
   */

  export type AggregateSwiftMessage = {
    _count: SwiftMessageCountAggregateOutputType | null
    _min: SwiftMessageMinAggregateOutputType | null
    _max: SwiftMessageMaxAggregateOutputType | null
  }

  export type SwiftMessageMinAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    referenceDossier: string | null
    dateGeneration: Date | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwiftMessageMaxAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    referenceDossier: string | null
    dateGeneration: Date | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwiftMessageCountAggregateOutputType = {
    id: number
    type: number
    content: number
    referenceDossier: number
    dateGeneration: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SwiftMessageMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    referenceDossier?: true
    dateGeneration?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwiftMessageMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    referenceDossier?: true
    dateGeneration?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwiftMessageCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    referenceDossier?: true
    dateGeneration?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SwiftMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwiftMessage to aggregate.
     */
    where?: SwiftMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwiftMessages to fetch.
     */
    orderBy?: SwiftMessageOrderByWithRelationInput | SwiftMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SwiftMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwiftMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwiftMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SwiftMessages
    **/
    _count?: true | SwiftMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwiftMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwiftMessageMaxAggregateInputType
  }

  export type GetSwiftMessageAggregateType<T extends SwiftMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSwiftMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwiftMessage[P]>
      : GetScalarType<T[P], AggregateSwiftMessage[P]>
  }




  export type SwiftMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwiftMessageWhereInput
    orderBy?: SwiftMessageOrderByWithAggregationInput | SwiftMessageOrderByWithAggregationInput[]
    by: SwiftMessageScalarFieldEnum[] | SwiftMessageScalarFieldEnum
    having?: SwiftMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwiftMessageCountAggregateInputType | true
    _min?: SwiftMessageMinAggregateInputType
    _max?: SwiftMessageMaxAggregateInputType
  }

  export type SwiftMessageGroupByOutputType = {
    id: string
    type: string
    content: string
    referenceDossier: string
    dateGeneration: Date
    statut: string
    createdAt: Date
    updatedAt: Date
    _count: SwiftMessageCountAggregateOutputType | null
    _min: SwiftMessageMinAggregateOutputType | null
    _max: SwiftMessageMaxAggregateOutputType | null
  }

  type GetSwiftMessageGroupByPayload<T extends SwiftMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SwiftMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwiftMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwiftMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SwiftMessageGroupByOutputType[P]>
        }
      >
    >


  export type SwiftMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    referenceDossier?: boolean
    dateGeneration?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["swiftMessage"]>


  export type SwiftMessageSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    referenceDossier?: boolean
    dateGeneration?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SwiftMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SwiftMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      content: string
      referenceDossier: string
      dateGeneration: Date
      statut: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["swiftMessage"]>
    composites: {}
  }

  type SwiftMessageGetPayload<S extends boolean | null | undefined | SwiftMessageDefaultArgs> = $Result.GetResult<Prisma.$SwiftMessagePayload, S>

  type SwiftMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SwiftMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SwiftMessageCountAggregateInputType | true
    }

  export interface SwiftMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SwiftMessage'], meta: { name: 'SwiftMessage' } }
    /**
     * Find zero or one SwiftMessage that matches the filter.
     * @param {SwiftMessageFindUniqueArgs} args - Arguments to find a SwiftMessage
     * @example
     * // Get one SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SwiftMessageFindUniqueArgs>(args: SelectSubset<T, SwiftMessageFindUniqueArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SwiftMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SwiftMessageFindUniqueOrThrowArgs} args - Arguments to find a SwiftMessage
     * @example
     * // Get one SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SwiftMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SwiftMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SwiftMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageFindFirstArgs} args - Arguments to find a SwiftMessage
     * @example
     * // Get one SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SwiftMessageFindFirstArgs>(args?: SelectSubset<T, SwiftMessageFindFirstArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SwiftMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageFindFirstOrThrowArgs} args - Arguments to find a SwiftMessage
     * @example
     * // Get one SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SwiftMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SwiftMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SwiftMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SwiftMessages
     * const swiftMessages = await prisma.swiftMessage.findMany()
     * 
     * // Get first 10 SwiftMessages
     * const swiftMessages = await prisma.swiftMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const swiftMessageWithIdOnly = await prisma.swiftMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SwiftMessageFindManyArgs>(args?: SelectSubset<T, SwiftMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SwiftMessage.
     * @param {SwiftMessageCreateArgs} args - Arguments to create a SwiftMessage.
     * @example
     * // Create one SwiftMessage
     * const SwiftMessage = await prisma.swiftMessage.create({
     *   data: {
     *     // ... data to create a SwiftMessage
     *   }
     * })
     * 
     */
    create<T extends SwiftMessageCreateArgs>(args: SelectSubset<T, SwiftMessageCreateArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SwiftMessages.
     * @param {SwiftMessageCreateManyArgs} args - Arguments to create many SwiftMessages.
     * @example
     * // Create many SwiftMessages
     * const swiftMessage = await prisma.swiftMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SwiftMessageCreateManyArgs>(args?: SelectSubset<T, SwiftMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SwiftMessage.
     * @param {SwiftMessageDeleteArgs} args - Arguments to delete one SwiftMessage.
     * @example
     * // Delete one SwiftMessage
     * const SwiftMessage = await prisma.swiftMessage.delete({
     *   where: {
     *     // ... filter to delete one SwiftMessage
     *   }
     * })
     * 
     */
    delete<T extends SwiftMessageDeleteArgs>(args: SelectSubset<T, SwiftMessageDeleteArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SwiftMessage.
     * @param {SwiftMessageUpdateArgs} args - Arguments to update one SwiftMessage.
     * @example
     * // Update one SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SwiftMessageUpdateArgs>(args: SelectSubset<T, SwiftMessageUpdateArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SwiftMessages.
     * @param {SwiftMessageDeleteManyArgs} args - Arguments to filter SwiftMessages to delete.
     * @example
     * // Delete a few SwiftMessages
     * const { count } = await prisma.swiftMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SwiftMessageDeleteManyArgs>(args?: SelectSubset<T, SwiftMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwiftMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SwiftMessages
     * const swiftMessage = await prisma.swiftMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SwiftMessageUpdateManyArgs>(args: SelectSubset<T, SwiftMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SwiftMessage.
     * @param {SwiftMessageUpsertArgs} args - Arguments to update or create a SwiftMessage.
     * @example
     * // Update or create a SwiftMessage
     * const swiftMessage = await prisma.swiftMessage.upsert({
     *   create: {
     *     // ... data to create a SwiftMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SwiftMessage we want to update
     *   }
     * })
     */
    upsert<T extends SwiftMessageUpsertArgs>(args: SelectSubset<T, SwiftMessageUpsertArgs<ExtArgs>>): Prisma__SwiftMessageClient<$Result.GetResult<Prisma.$SwiftMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SwiftMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageCountArgs} args - Arguments to filter SwiftMessages to count.
     * @example
     * // Count the number of SwiftMessages
     * const count = await prisma.swiftMessage.count({
     *   where: {
     *     // ... the filter for the SwiftMessages we want to count
     *   }
     * })
    **/
    count<T extends SwiftMessageCountArgs>(
      args?: Subset<T, SwiftMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwiftMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SwiftMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwiftMessageAggregateArgs>(args: Subset<T, SwiftMessageAggregateArgs>): Prisma.PrismaPromise<GetSwiftMessageAggregateType<T>>

    /**
     * Group by SwiftMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwiftMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwiftMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwiftMessageGroupByArgs['orderBy'] }
        : { orderBy?: SwiftMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwiftMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwiftMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SwiftMessage model
   */
  readonly fields: SwiftMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SwiftMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SwiftMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SwiftMessage model
   */ 
  interface SwiftMessageFieldRefs {
    readonly id: FieldRef<"SwiftMessage", 'String'>
    readonly type: FieldRef<"SwiftMessage", 'String'>
    readonly content: FieldRef<"SwiftMessage", 'String'>
    readonly referenceDossier: FieldRef<"SwiftMessage", 'String'>
    readonly dateGeneration: FieldRef<"SwiftMessage", 'DateTime'>
    readonly statut: FieldRef<"SwiftMessage", 'String'>
    readonly createdAt: FieldRef<"SwiftMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"SwiftMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SwiftMessage findUnique
   */
  export type SwiftMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter, which SwiftMessage to fetch.
     */
    where: SwiftMessageWhereUniqueInput
  }

  /**
   * SwiftMessage findUniqueOrThrow
   */
  export type SwiftMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter, which SwiftMessage to fetch.
     */
    where: SwiftMessageWhereUniqueInput
  }

  /**
   * SwiftMessage findFirst
   */
  export type SwiftMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter, which SwiftMessage to fetch.
     */
    where?: SwiftMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwiftMessages to fetch.
     */
    orderBy?: SwiftMessageOrderByWithRelationInput | SwiftMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwiftMessages.
     */
    cursor?: SwiftMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwiftMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwiftMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwiftMessages.
     */
    distinct?: SwiftMessageScalarFieldEnum | SwiftMessageScalarFieldEnum[]
  }

  /**
   * SwiftMessage findFirstOrThrow
   */
  export type SwiftMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter, which SwiftMessage to fetch.
     */
    where?: SwiftMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwiftMessages to fetch.
     */
    orderBy?: SwiftMessageOrderByWithRelationInput | SwiftMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwiftMessages.
     */
    cursor?: SwiftMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwiftMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwiftMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwiftMessages.
     */
    distinct?: SwiftMessageScalarFieldEnum | SwiftMessageScalarFieldEnum[]
  }

  /**
   * SwiftMessage findMany
   */
  export type SwiftMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter, which SwiftMessages to fetch.
     */
    where?: SwiftMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwiftMessages to fetch.
     */
    orderBy?: SwiftMessageOrderByWithRelationInput | SwiftMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SwiftMessages.
     */
    cursor?: SwiftMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwiftMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwiftMessages.
     */
    skip?: number
    distinct?: SwiftMessageScalarFieldEnum | SwiftMessageScalarFieldEnum[]
  }

  /**
   * SwiftMessage create
   */
  export type SwiftMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * The data needed to create a SwiftMessage.
     */
    data: XOR<SwiftMessageCreateInput, SwiftMessageUncheckedCreateInput>
  }

  /**
   * SwiftMessage createMany
   */
  export type SwiftMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SwiftMessages.
     */
    data: SwiftMessageCreateManyInput | SwiftMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SwiftMessage update
   */
  export type SwiftMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * The data needed to update a SwiftMessage.
     */
    data: XOR<SwiftMessageUpdateInput, SwiftMessageUncheckedUpdateInput>
    /**
     * Choose, which SwiftMessage to update.
     */
    where: SwiftMessageWhereUniqueInput
  }

  /**
   * SwiftMessage updateMany
   */
  export type SwiftMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SwiftMessages.
     */
    data: XOR<SwiftMessageUpdateManyMutationInput, SwiftMessageUncheckedUpdateManyInput>
    /**
     * Filter which SwiftMessages to update
     */
    where?: SwiftMessageWhereInput
  }

  /**
   * SwiftMessage upsert
   */
  export type SwiftMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * The filter to search for the SwiftMessage to update in case it exists.
     */
    where: SwiftMessageWhereUniqueInput
    /**
     * In case the SwiftMessage found by the `where` argument doesn't exist, create a new SwiftMessage with this data.
     */
    create: XOR<SwiftMessageCreateInput, SwiftMessageUncheckedCreateInput>
    /**
     * In case the SwiftMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SwiftMessageUpdateInput, SwiftMessageUncheckedUpdateInput>
  }

  /**
   * SwiftMessage delete
   */
  export type SwiftMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
    /**
     * Filter which SwiftMessage to delete.
     */
    where: SwiftMessageWhereUniqueInput
  }

  /**
   * SwiftMessage deleteMany
   */
  export type SwiftMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwiftMessages to delete
     */
    where?: SwiftMessageWhereInput
  }

  /**
   * SwiftMessage without action
   */
  export type SwiftMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwiftMessage
     */
    select?: SwiftMessageSelect<ExtArgs> | null
  }


  /**
   * Model DocumentImport
   */

  export type AggregateDocumentImport = {
    _count: DocumentImportCountAggregateOutputType | null
    _min: DocumentImportMinAggregateOutputType | null
    _max: DocumentImportMaxAggregateOutputType | null
  }

  export type DocumentImportMinAggregateOutputType = {
    id: string | null
    type: string | null
    nomFichier: string | null
    cheminFichier: string | null
    dateUpload: Date | null
    metadata: string | null
    referenceDossier: string | null
    createdAt: Date | null
  }

  export type DocumentImportMaxAggregateOutputType = {
    id: string | null
    type: string | null
    nomFichier: string | null
    cheminFichier: string | null
    dateUpload: Date | null
    metadata: string | null
    referenceDossier: string | null
    createdAt: Date | null
  }

  export type DocumentImportCountAggregateOutputType = {
    id: number
    type: number
    nomFichier: number
    cheminFichier: number
    dateUpload: number
    metadata: number
    referenceDossier: number
    createdAt: number
    _all: number
  }


  export type DocumentImportMinAggregateInputType = {
    id?: true
    type?: true
    nomFichier?: true
    cheminFichier?: true
    dateUpload?: true
    metadata?: true
    referenceDossier?: true
    createdAt?: true
  }

  export type DocumentImportMaxAggregateInputType = {
    id?: true
    type?: true
    nomFichier?: true
    cheminFichier?: true
    dateUpload?: true
    metadata?: true
    referenceDossier?: true
    createdAt?: true
  }

  export type DocumentImportCountAggregateInputType = {
    id?: true
    type?: true
    nomFichier?: true
    cheminFichier?: true
    dateUpload?: true
    metadata?: true
    referenceDossier?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentImport to aggregate.
     */
    where?: DocumentImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentImports to fetch.
     */
    orderBy?: DocumentImportOrderByWithRelationInput | DocumentImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentImports
    **/
    _count?: true | DocumentImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentImportMaxAggregateInputType
  }

  export type GetDocumentImportAggregateType<T extends DocumentImportAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentImport[P]>
      : GetScalarType<T[P], AggregateDocumentImport[P]>
  }




  export type DocumentImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentImportWhereInput
    orderBy?: DocumentImportOrderByWithAggregationInput | DocumentImportOrderByWithAggregationInput[]
    by: DocumentImportScalarFieldEnum[] | DocumentImportScalarFieldEnum
    having?: DocumentImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentImportCountAggregateInputType | true
    _min?: DocumentImportMinAggregateInputType
    _max?: DocumentImportMaxAggregateInputType
  }

  export type DocumentImportGroupByOutputType = {
    id: string
    type: string
    nomFichier: string
    cheminFichier: string
    dateUpload: Date
    metadata: string | null
    referenceDossier: string
    createdAt: Date
    _count: DocumentImportCountAggregateOutputType | null
    _min: DocumentImportMinAggregateOutputType | null
    _max: DocumentImportMaxAggregateOutputType | null
  }

  type GetDocumentImportGroupByPayload<T extends DocumentImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentImportGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentImportGroupByOutputType[P]>
        }
      >
    >


  export type DocumentImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    nomFichier?: boolean
    cheminFichier?: boolean
    dateUpload?: boolean
    metadata?: boolean
    referenceDossier?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["documentImport"]>


  export type DocumentImportSelectScalar = {
    id?: boolean
    type?: boolean
    nomFichier?: boolean
    cheminFichier?: boolean
    dateUpload?: boolean
    metadata?: boolean
    referenceDossier?: boolean
    createdAt?: boolean
  }


  export type $DocumentImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentImport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      nomFichier: string
      cheminFichier: string
      dateUpload: Date
      metadata: string | null
      referenceDossier: string
      createdAt: Date
    }, ExtArgs["result"]["documentImport"]>
    composites: {}
  }

  type DocumentImportGetPayload<S extends boolean | null | undefined | DocumentImportDefaultArgs> = $Result.GetResult<Prisma.$DocumentImportPayload, S>

  type DocumentImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentImportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentImportCountAggregateInputType | true
    }

  export interface DocumentImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentImport'], meta: { name: 'DocumentImport' } }
    /**
     * Find zero or one DocumentImport that matches the filter.
     * @param {DocumentImportFindUniqueArgs} args - Arguments to find a DocumentImport
     * @example
     * // Get one DocumentImport
     * const documentImport = await prisma.documentImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentImportFindUniqueArgs>(args: SelectSubset<T, DocumentImportFindUniqueArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentImport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentImportFindUniqueOrThrowArgs} args - Arguments to find a DocumentImport
     * @example
     * // Get one DocumentImport
     * const documentImport = await prisma.documentImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentImportFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportFindFirstArgs} args - Arguments to find a DocumentImport
     * @example
     * // Get one DocumentImport
     * const documentImport = await prisma.documentImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentImportFindFirstArgs>(args?: SelectSubset<T, DocumentImportFindFirstArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportFindFirstOrThrowArgs} args - Arguments to find a DocumentImport
     * @example
     * // Get one DocumentImport
     * const documentImport = await prisma.documentImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentImportFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentImports
     * const documentImports = await prisma.documentImport.findMany()
     * 
     * // Get first 10 DocumentImports
     * const documentImports = await prisma.documentImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentImportWithIdOnly = await prisma.documentImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentImportFindManyArgs>(args?: SelectSubset<T, DocumentImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentImport.
     * @param {DocumentImportCreateArgs} args - Arguments to create a DocumentImport.
     * @example
     * // Create one DocumentImport
     * const DocumentImport = await prisma.documentImport.create({
     *   data: {
     *     // ... data to create a DocumentImport
     *   }
     * })
     * 
     */
    create<T extends DocumentImportCreateArgs>(args: SelectSubset<T, DocumentImportCreateArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentImports.
     * @param {DocumentImportCreateManyArgs} args - Arguments to create many DocumentImports.
     * @example
     * // Create many DocumentImports
     * const documentImport = await prisma.documentImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentImportCreateManyArgs>(args?: SelectSubset<T, DocumentImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentImport.
     * @param {DocumentImportDeleteArgs} args - Arguments to delete one DocumentImport.
     * @example
     * // Delete one DocumentImport
     * const DocumentImport = await prisma.documentImport.delete({
     *   where: {
     *     // ... filter to delete one DocumentImport
     *   }
     * })
     * 
     */
    delete<T extends DocumentImportDeleteArgs>(args: SelectSubset<T, DocumentImportDeleteArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentImport.
     * @param {DocumentImportUpdateArgs} args - Arguments to update one DocumentImport.
     * @example
     * // Update one DocumentImport
     * const documentImport = await prisma.documentImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentImportUpdateArgs>(args: SelectSubset<T, DocumentImportUpdateArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentImports.
     * @param {DocumentImportDeleteManyArgs} args - Arguments to filter DocumentImports to delete.
     * @example
     * // Delete a few DocumentImports
     * const { count } = await prisma.documentImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentImportDeleteManyArgs>(args?: SelectSubset<T, DocumentImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentImports
     * const documentImport = await prisma.documentImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentImportUpdateManyArgs>(args: SelectSubset<T, DocumentImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentImport.
     * @param {DocumentImportUpsertArgs} args - Arguments to update or create a DocumentImport.
     * @example
     * // Update or create a DocumentImport
     * const documentImport = await prisma.documentImport.upsert({
     *   create: {
     *     // ... data to create a DocumentImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentImport we want to update
     *   }
     * })
     */
    upsert<T extends DocumentImportUpsertArgs>(args: SelectSubset<T, DocumentImportUpsertArgs<ExtArgs>>): Prisma__DocumentImportClient<$Result.GetResult<Prisma.$DocumentImportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportCountArgs} args - Arguments to filter DocumentImports to count.
     * @example
     * // Count the number of DocumentImports
     * const count = await prisma.documentImport.count({
     *   where: {
     *     // ... the filter for the DocumentImports we want to count
     *   }
     * })
    **/
    count<T extends DocumentImportCountArgs>(
      args?: Subset<T, DocumentImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentImportAggregateArgs>(args: Subset<T, DocumentImportAggregateArgs>): Prisma.PrismaPromise<GetDocumentImportAggregateType<T>>

    /**
     * Group by DocumentImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentImportGroupByArgs['orderBy'] }
        : { orderBy?: DocumentImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentImport model
   */
  readonly fields: DocumentImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentImport model
   */ 
  interface DocumentImportFieldRefs {
    readonly id: FieldRef<"DocumentImport", 'String'>
    readonly type: FieldRef<"DocumentImport", 'String'>
    readonly nomFichier: FieldRef<"DocumentImport", 'String'>
    readonly cheminFichier: FieldRef<"DocumentImport", 'String'>
    readonly dateUpload: FieldRef<"DocumentImport", 'DateTime'>
    readonly metadata: FieldRef<"DocumentImport", 'String'>
    readonly referenceDossier: FieldRef<"DocumentImport", 'String'>
    readonly createdAt: FieldRef<"DocumentImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentImport findUnique
   */
  export type DocumentImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter, which DocumentImport to fetch.
     */
    where: DocumentImportWhereUniqueInput
  }

  /**
   * DocumentImport findUniqueOrThrow
   */
  export type DocumentImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter, which DocumentImport to fetch.
     */
    where: DocumentImportWhereUniqueInput
  }

  /**
   * DocumentImport findFirst
   */
  export type DocumentImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter, which DocumentImport to fetch.
     */
    where?: DocumentImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentImports to fetch.
     */
    orderBy?: DocumentImportOrderByWithRelationInput | DocumentImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentImports.
     */
    cursor?: DocumentImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentImports.
     */
    distinct?: DocumentImportScalarFieldEnum | DocumentImportScalarFieldEnum[]
  }

  /**
   * DocumentImport findFirstOrThrow
   */
  export type DocumentImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter, which DocumentImport to fetch.
     */
    where?: DocumentImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentImports to fetch.
     */
    orderBy?: DocumentImportOrderByWithRelationInput | DocumentImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentImports.
     */
    cursor?: DocumentImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentImports.
     */
    distinct?: DocumentImportScalarFieldEnum | DocumentImportScalarFieldEnum[]
  }

  /**
   * DocumentImport findMany
   */
  export type DocumentImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter, which DocumentImports to fetch.
     */
    where?: DocumentImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentImports to fetch.
     */
    orderBy?: DocumentImportOrderByWithRelationInput | DocumentImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentImports.
     */
    cursor?: DocumentImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentImports.
     */
    skip?: number
    distinct?: DocumentImportScalarFieldEnum | DocumentImportScalarFieldEnum[]
  }

  /**
   * DocumentImport create
   */
  export type DocumentImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * The data needed to create a DocumentImport.
     */
    data: XOR<DocumentImportCreateInput, DocumentImportUncheckedCreateInput>
  }

  /**
   * DocumentImport createMany
   */
  export type DocumentImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentImports.
     */
    data: DocumentImportCreateManyInput | DocumentImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentImport update
   */
  export type DocumentImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * The data needed to update a DocumentImport.
     */
    data: XOR<DocumentImportUpdateInput, DocumentImportUncheckedUpdateInput>
    /**
     * Choose, which DocumentImport to update.
     */
    where: DocumentImportWhereUniqueInput
  }

  /**
   * DocumentImport updateMany
   */
  export type DocumentImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentImports.
     */
    data: XOR<DocumentImportUpdateManyMutationInput, DocumentImportUncheckedUpdateManyInput>
    /**
     * Filter which DocumentImports to update
     */
    where?: DocumentImportWhereInput
  }

  /**
   * DocumentImport upsert
   */
  export type DocumentImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * The filter to search for the DocumentImport to update in case it exists.
     */
    where: DocumentImportWhereUniqueInput
    /**
     * In case the DocumentImport found by the `where` argument doesn't exist, create a new DocumentImport with this data.
     */
    create: XOR<DocumentImportCreateInput, DocumentImportUncheckedCreateInput>
    /**
     * In case the DocumentImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentImportUpdateInput, DocumentImportUncheckedUpdateInput>
  }

  /**
   * DocumentImport delete
   */
  export type DocumentImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
    /**
     * Filter which DocumentImport to delete.
     */
    where: DocumentImportWhereUniqueInput
  }

  /**
   * DocumentImport deleteMany
   */
  export type DocumentImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentImports to delete
     */
    where?: DocumentImportWhereInput
  }

  /**
   * DocumentImport without action
   */
  export type DocumentImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentImport
     */
    select?: DocumentImportSelect<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    address: string | null
    contactInfo: string | null
    parentCompanyId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    address: string | null
    contactInfo: string | null
    parentCompanyId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    address: number
    contactInfo: number
    parentCompanyId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    address?: true
    contactInfo?: true
    parentCompanyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    address?: true
    contactInfo?: true
    parentCompanyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    address?: true
    contactInfo?: true
    parentCompanyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    address: string | null
    contactInfo: string | null
    parentCompanyId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    address?: boolean
    contactInfo?: boolean
    parentCompanyId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentCompany?: boolean | Company$parentCompanyArgs<ExtArgs>
    subCompanies?: boolean | Company$subCompaniesArgs<ExtArgs>
    businessUnits?: boolean | Company$businessUnitsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    companySuppliers?: boolean | Company$companySuppliersArgs<ExtArgs>
    companyBanques?: boolean | Company$companyBanquesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>


  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    address?: boolean
    contactInfo?: boolean
    parentCompanyId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentCompany?: boolean | Company$parentCompanyArgs<ExtArgs>
    subCompanies?: boolean | Company$subCompaniesArgs<ExtArgs>
    businessUnits?: boolean | Company$businessUnitsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    companySuppliers?: boolean | Company$companySuppliersArgs<ExtArgs>
    companyBanques?: boolean | Company$companyBanquesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      parentCompany: Prisma.$CompanyPayload<ExtArgs> | null
      subCompanies: Prisma.$CompanyPayload<ExtArgs>[]
      businessUnits: Prisma.$BusinessUnitPayload<ExtArgs>[]
      users: Prisma.$userPayload<ExtArgs>[]
      companySuppliers: Prisma.$CompanySupplierPayload<ExtArgs>[]
      companyBanques: Prisma.$CompanyBanquePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      address: string | null
      contactInfo: string | null
      parentCompanyId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentCompany<T extends Company$parentCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Company$parentCompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subCompanies<T extends Company$subCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Company$subCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    businessUnits<T extends Company$businessUnitsArgs<ExtArgs> = {}>(args?: Subset<T, Company$businessUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany"> | Null>
    companySuppliers<T extends Company$companySuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Company$companySuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findMany"> | Null>
    companyBanques<T extends Company$companyBanquesArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyBanquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly code: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly contactInfo: FieldRef<"Company", 'String'>
    readonly parentCompanyId: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.parentCompany
   */
  export type Company$parentCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Company.subCompanies
   */
  export type Company$subCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company.businessUnits
   */
  export type Company$businessUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    where?: BusinessUnitWhereInput
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    cursor?: BusinessUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.companySuppliers
   */
  export type Company$companySuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    where?: CompanySupplierWhereInput
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    cursor?: CompanySupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanySupplierScalarFieldEnum | CompanySupplierScalarFieldEnum[]
  }

  /**
   * Company.companyBanques
   */
  export type Company$companyBanquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    where?: CompanyBanqueWhereInput
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    cursor?: CompanyBanqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBanqueScalarFieldEnum | CompanyBanqueScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnit
   */

  export type AggregateBusinessUnit = {
    _count: BusinessUnitCountAggregateOutputType | null
    _min: BusinessUnitMinAggregateOutputType | null
    _max: BusinessUnitMaxAggregateOutputType | null
  }

  export type BusinessUnitMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    companyId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessUnitMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    companyId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessUnitCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    companyId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessUnitMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    companyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessUnitMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    companyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessUnitCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    companyId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnit to aggregate.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnits
    **/
    _count?: true | BusinessUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitMaxAggregateInputType
  }

  export type GetBusinessUnitAggregateType<T extends BusinessUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnit[P]>
      : GetScalarType<T[P], AggregateBusinessUnit[P]>
  }




  export type BusinessUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitWhereInput
    orderBy?: BusinessUnitOrderByWithAggregationInput | BusinessUnitOrderByWithAggregationInput[]
    by: BusinessUnitScalarFieldEnum[] | BusinessUnitScalarFieldEnum
    having?: BusinessUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitCountAggregateInputType | true
    _min?: BusinessUnitMinAggregateInputType
    _max?: BusinessUnitMaxAggregateInputType
  }

  export type BusinessUnitGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    companyId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessUnitCountAggregateOutputType | null
    _min: BusinessUnitMinAggregateOutputType | null
    _max: BusinessUnitMaxAggregateOutputType | null
  }

  type GetBusinessUnitGroupByPayload<T extends BusinessUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    companyId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    users?: boolean | BusinessUnit$usersArgs<ExtArgs>
    businessUnitSuppliers?: boolean | BusinessUnit$businessUnitSuppliersArgs<ExtArgs>
    _count?: boolean | BusinessUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnit"]>


  export type BusinessUnitSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    companyId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    users?: boolean | BusinessUnit$usersArgs<ExtArgs>
    businessUnitSuppliers?: boolean | BusinessUnit$businessUnitSuppliersArgs<ExtArgs>
    _count?: boolean | BusinessUnitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BusinessUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnit"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      users: Prisma.$userPayload<ExtArgs>[]
      businessUnitSuppliers: Prisma.$BusinessUnitSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      companyId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessUnit"]>
    composites: {}
  }

  type BusinessUnitGetPayload<S extends boolean | null | undefined | BusinessUnitDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitPayload, S>

  type BusinessUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessUnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessUnitCountAggregateInputType | true
    }

  export interface BusinessUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnit'], meta: { name: 'BusinessUnit' } }
    /**
     * Find zero or one BusinessUnit that matches the filter.
     * @param {BusinessUnitFindUniqueArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitFindUniqueArgs>(args: SelectSubset<T, BusinessUnitFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessUnit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessUnitFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindFirstArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitFindFirstArgs>(args?: SelectSubset<T, BusinessUnitFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindFirstOrThrowArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnits
     * const businessUnits = await prisma.businessUnit.findMany()
     * 
     * // Get first 10 BusinessUnits
     * const businessUnits = await prisma.businessUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitWithIdOnly = await prisma.businessUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitFindManyArgs>(args?: SelectSubset<T, BusinessUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessUnit.
     * @param {BusinessUnitCreateArgs} args - Arguments to create a BusinessUnit.
     * @example
     * // Create one BusinessUnit
     * const BusinessUnit = await prisma.businessUnit.create({
     *   data: {
     *     // ... data to create a BusinessUnit
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitCreateArgs>(args: SelectSubset<T, BusinessUnitCreateArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessUnits.
     * @param {BusinessUnitCreateManyArgs} args - Arguments to create many BusinessUnits.
     * @example
     * // Create many BusinessUnits
     * const businessUnit = await prisma.businessUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitCreateManyArgs>(args?: SelectSubset<T, BusinessUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessUnit.
     * @param {BusinessUnitDeleteArgs} args - Arguments to delete one BusinessUnit.
     * @example
     * // Delete one BusinessUnit
     * const BusinessUnit = await prisma.businessUnit.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnit
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitDeleteArgs>(args: SelectSubset<T, BusinessUnitDeleteArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessUnit.
     * @param {BusinessUnitUpdateArgs} args - Arguments to update one BusinessUnit.
     * @example
     * // Update one BusinessUnit
     * const businessUnit = await prisma.businessUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitUpdateArgs>(args: SelectSubset<T, BusinessUnitUpdateArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessUnits.
     * @param {BusinessUnitDeleteManyArgs} args - Arguments to filter BusinessUnits to delete.
     * @example
     * // Delete a few BusinessUnits
     * const { count } = await prisma.businessUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnits
     * const businessUnit = await prisma.businessUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitUpdateManyArgs>(args: SelectSubset<T, BusinessUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessUnit.
     * @param {BusinessUnitUpsertArgs} args - Arguments to update or create a BusinessUnit.
     * @example
     * // Update or create a BusinessUnit
     * const businessUnit = await prisma.businessUnit.upsert({
     *   create: {
     *     // ... data to create a BusinessUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnit we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitUpsertArgs>(args: SelectSubset<T, BusinessUnitUpsertArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitCountArgs} args - Arguments to filter BusinessUnits to count.
     * @example
     * // Count the number of BusinessUnits
     * const count = await prisma.businessUnit.count({
     *   where: {
     *     // ... the filter for the BusinessUnits we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitCountArgs>(
      args?: Subset<T, BusinessUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitAggregateArgs>(args: Subset<T, BusinessUnitAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitAggregateType<T>>

    /**
     * Group by BusinessUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnit model
   */
  readonly fields: BusinessUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends BusinessUnit$usersArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany"> | Null>
    businessUnitSuppliers<T extends BusinessUnit$businessUnitSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$businessUnitSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnit model
   */ 
  interface BusinessUnitFieldRefs {
    readonly id: FieldRef<"BusinessUnit", 'String'>
    readonly name: FieldRef<"BusinessUnit", 'String'>
    readonly code: FieldRef<"BusinessUnit", 'String'>
    readonly description: FieldRef<"BusinessUnit", 'String'>
    readonly companyId: FieldRef<"BusinessUnit", 'String'>
    readonly isActive: FieldRef<"BusinessUnit", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnit findUnique
   */
  export type BusinessUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit findUniqueOrThrow
   */
  export type BusinessUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit findFirst
   */
  export type BusinessUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnits.
     */
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit findFirstOrThrow
   */
  export type BusinessUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnits.
     */
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit findMany
   */
  export type BusinessUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnits to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit create
   */
  export type BusinessUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnit.
     */
    data: XOR<BusinessUnitCreateInput, BusinessUnitUncheckedCreateInput>
  }

  /**
   * BusinessUnit createMany
   */
  export type BusinessUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnits.
     */
    data: BusinessUnitCreateManyInput | BusinessUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnit update
   */
  export type BusinessUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnit.
     */
    data: XOR<BusinessUnitUpdateInput, BusinessUnitUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnit to update.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit updateMany
   */
  export type BusinessUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnits.
     */
    data: XOR<BusinessUnitUpdateManyMutationInput, BusinessUnitUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnits to update
     */
    where?: BusinessUnitWhereInput
  }

  /**
   * BusinessUnit upsert
   */
  export type BusinessUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnit to update in case it exists.
     */
    where: BusinessUnitWhereUniqueInput
    /**
     * In case the BusinessUnit found by the `where` argument doesn't exist, create a new BusinessUnit with this data.
     */
    create: XOR<BusinessUnitCreateInput, BusinessUnitUncheckedCreateInput>
    /**
     * In case the BusinessUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitUpdateInput, BusinessUnitUncheckedUpdateInput>
  }

  /**
   * BusinessUnit delete
   */
  export type BusinessUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnit to delete.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit deleteMany
   */
  export type BusinessUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnits to delete
     */
    where?: BusinessUnitWhereInput
  }

  /**
   * BusinessUnit.users
   */
  export type BusinessUnit$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * BusinessUnit.businessUnitSuppliers
   */
  export type BusinessUnit$businessUnitSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    where?: BusinessUnitSupplierWhereInput
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    cursor?: BusinessUnitSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSupplierScalarFieldEnum | BusinessUnitSupplierScalarFieldEnum[]
  }

  /**
   * BusinessUnit without action
   */
  export type BusinessUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    contactInfo: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    contactInfo: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    contactInfo: number
    address: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    contactInfo?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    contactInfo?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    contactInfo?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    contactInfo: string | null
    address: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    contactInfo?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companySuppliers?: boolean | Supplier$companySuppliersArgs<ExtArgs>
    businessUnitSuppliers?: boolean | Supplier$businessUnitSuppliersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>


  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    contactInfo?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companySuppliers?: boolean | Supplier$companySuppliersArgs<ExtArgs>
    businessUnitSuppliers?: boolean | Supplier$businessUnitSuppliersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      companySuppliers: Prisma.$CompanySupplierPayload<ExtArgs>[]
      businessUnitSuppliers: Prisma.$BusinessUnitSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      contactInfo: string | null
      address: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companySuppliers<T extends Supplier$companySuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$companySuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findMany"> | Null>
    businessUnitSuppliers<T extends Supplier$businessUnitSuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$businessUnitSuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly description: FieldRef<"Supplier", 'String'>
    readonly contactInfo: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.companySuppliers
   */
  export type Supplier$companySuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    where?: CompanySupplierWhereInput
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    cursor?: CompanySupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanySupplierScalarFieldEnum | CompanySupplierScalarFieldEnum[]
  }

  /**
   * Supplier.businessUnitSuppliers
   */
  export type Supplier$businessUnitSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    where?: BusinessUnitSupplierWhereInput
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    cursor?: BusinessUnitSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSupplierScalarFieldEnum | BusinessUnitSupplierScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model CompanySupplier
   */

  export type AggregateCompanySupplier = {
    _count: CompanySupplierCountAggregateOutputType | null
    _min: CompanySupplierMinAggregateOutputType | null
    _max: CompanySupplierMaxAggregateOutputType | null
  }

  export type CompanySupplierMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    supplierId: string | null
    createdAt: Date | null
  }

  export type CompanySupplierMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    supplierId: string | null
    createdAt: Date | null
  }

  export type CompanySupplierCountAggregateOutputType = {
    id: number
    companyId: number
    supplierId: number
    createdAt: number
    _all: number
  }


  export type CompanySupplierMinAggregateInputType = {
    id?: true
    companyId?: true
    supplierId?: true
    createdAt?: true
  }

  export type CompanySupplierMaxAggregateInputType = {
    id?: true
    companyId?: true
    supplierId?: true
    createdAt?: true
  }

  export type CompanySupplierCountAggregateInputType = {
    id?: true
    companyId?: true
    supplierId?: true
    createdAt?: true
    _all?: true
  }

  export type CompanySupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySupplier to aggregate.
     */
    where?: CompanySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySuppliers to fetch.
     */
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanySuppliers
    **/
    _count?: true | CompanySupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanySupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanySupplierMaxAggregateInputType
  }

  export type GetCompanySupplierAggregateType<T extends CompanySupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanySupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanySupplier[P]>
      : GetScalarType<T[P], AggregateCompanySupplier[P]>
  }




  export type CompanySupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySupplierWhereInput
    orderBy?: CompanySupplierOrderByWithAggregationInput | CompanySupplierOrderByWithAggregationInput[]
    by: CompanySupplierScalarFieldEnum[] | CompanySupplierScalarFieldEnum
    having?: CompanySupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanySupplierCountAggregateInputType | true
    _min?: CompanySupplierMinAggregateInputType
    _max?: CompanySupplierMaxAggregateInputType
  }

  export type CompanySupplierGroupByOutputType = {
    id: string
    companyId: string
    supplierId: string
    createdAt: Date
    _count: CompanySupplierCountAggregateOutputType | null
    _min: CompanySupplierMinAggregateOutputType | null
    _max: CompanySupplierMaxAggregateOutputType | null
  }

  type GetCompanySupplierGroupByPayload<T extends CompanySupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanySupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanySupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanySupplierGroupByOutputType[P]>
            : GetScalarType<T[P], CompanySupplierGroupByOutputType[P]>
        }
      >
    >


  export type CompanySupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companySupplier"]>


  export type CompanySupplierSelectScalar = {
    id?: boolean
    companyId?: boolean
    supplierId?: boolean
    createdAt?: boolean
  }

  export type CompanySupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $CompanySupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanySupplier"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      supplierId: string
      createdAt: Date
    }, ExtArgs["result"]["companySupplier"]>
    composites: {}
  }

  type CompanySupplierGetPayload<S extends boolean | null | undefined | CompanySupplierDefaultArgs> = $Result.GetResult<Prisma.$CompanySupplierPayload, S>

  type CompanySupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanySupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanySupplierCountAggregateInputType | true
    }

  export interface CompanySupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanySupplier'], meta: { name: 'CompanySupplier' } }
    /**
     * Find zero or one CompanySupplier that matches the filter.
     * @param {CompanySupplierFindUniqueArgs} args - Arguments to find a CompanySupplier
     * @example
     * // Get one CompanySupplier
     * const companySupplier = await prisma.companySupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanySupplierFindUniqueArgs>(args: SelectSubset<T, CompanySupplierFindUniqueArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanySupplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanySupplierFindUniqueOrThrowArgs} args - Arguments to find a CompanySupplier
     * @example
     * // Get one CompanySupplier
     * const companySupplier = await prisma.companySupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanySupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanySupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanySupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierFindFirstArgs} args - Arguments to find a CompanySupplier
     * @example
     * // Get one CompanySupplier
     * const companySupplier = await prisma.companySupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanySupplierFindFirstArgs>(args?: SelectSubset<T, CompanySupplierFindFirstArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanySupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierFindFirstOrThrowArgs} args - Arguments to find a CompanySupplier
     * @example
     * // Get one CompanySupplier
     * const companySupplier = await prisma.companySupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanySupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanySupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanySuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanySuppliers
     * const companySuppliers = await prisma.companySupplier.findMany()
     * 
     * // Get first 10 CompanySuppliers
     * const companySuppliers = await prisma.companySupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companySupplierWithIdOnly = await prisma.companySupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanySupplierFindManyArgs>(args?: SelectSubset<T, CompanySupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanySupplier.
     * @param {CompanySupplierCreateArgs} args - Arguments to create a CompanySupplier.
     * @example
     * // Create one CompanySupplier
     * const CompanySupplier = await prisma.companySupplier.create({
     *   data: {
     *     // ... data to create a CompanySupplier
     *   }
     * })
     * 
     */
    create<T extends CompanySupplierCreateArgs>(args: SelectSubset<T, CompanySupplierCreateArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanySuppliers.
     * @param {CompanySupplierCreateManyArgs} args - Arguments to create many CompanySuppliers.
     * @example
     * // Create many CompanySuppliers
     * const companySupplier = await prisma.companySupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanySupplierCreateManyArgs>(args?: SelectSubset<T, CompanySupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanySupplier.
     * @param {CompanySupplierDeleteArgs} args - Arguments to delete one CompanySupplier.
     * @example
     * // Delete one CompanySupplier
     * const CompanySupplier = await prisma.companySupplier.delete({
     *   where: {
     *     // ... filter to delete one CompanySupplier
     *   }
     * })
     * 
     */
    delete<T extends CompanySupplierDeleteArgs>(args: SelectSubset<T, CompanySupplierDeleteArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanySupplier.
     * @param {CompanySupplierUpdateArgs} args - Arguments to update one CompanySupplier.
     * @example
     * // Update one CompanySupplier
     * const companySupplier = await prisma.companySupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanySupplierUpdateArgs>(args: SelectSubset<T, CompanySupplierUpdateArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanySuppliers.
     * @param {CompanySupplierDeleteManyArgs} args - Arguments to filter CompanySuppliers to delete.
     * @example
     * // Delete a few CompanySuppliers
     * const { count } = await prisma.companySupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanySupplierDeleteManyArgs>(args?: SelectSubset<T, CompanySupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanySuppliers
     * const companySupplier = await prisma.companySupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanySupplierUpdateManyArgs>(args: SelectSubset<T, CompanySupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanySupplier.
     * @param {CompanySupplierUpsertArgs} args - Arguments to update or create a CompanySupplier.
     * @example
     * // Update or create a CompanySupplier
     * const companySupplier = await prisma.companySupplier.upsert({
     *   create: {
     *     // ... data to create a CompanySupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanySupplier we want to update
     *   }
     * })
     */
    upsert<T extends CompanySupplierUpsertArgs>(args: SelectSubset<T, CompanySupplierUpsertArgs<ExtArgs>>): Prisma__CompanySupplierClient<$Result.GetResult<Prisma.$CompanySupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanySuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierCountArgs} args - Arguments to filter CompanySuppliers to count.
     * @example
     * // Count the number of CompanySuppliers
     * const count = await prisma.companySupplier.count({
     *   where: {
     *     // ... the filter for the CompanySuppliers we want to count
     *   }
     * })
    **/
    count<T extends CompanySupplierCountArgs>(
      args?: Subset<T, CompanySupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanySupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanySupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanySupplierAggregateArgs>(args: Subset<T, CompanySupplierAggregateArgs>): Prisma.PrismaPromise<GetCompanySupplierAggregateType<T>>

    /**
     * Group by CompanySupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanySupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanySupplierGroupByArgs['orderBy'] }
        : { orderBy?: CompanySupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanySupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanySupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanySupplier model
   */
  readonly fields: CompanySupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanySupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanySupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanySupplier model
   */ 
  interface CompanySupplierFieldRefs {
    readonly id: FieldRef<"CompanySupplier", 'String'>
    readonly companyId: FieldRef<"CompanySupplier", 'String'>
    readonly supplierId: FieldRef<"CompanySupplier", 'String'>
    readonly createdAt: FieldRef<"CompanySupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanySupplier findUnique
   */
  export type CompanySupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter, which CompanySupplier to fetch.
     */
    where: CompanySupplierWhereUniqueInput
  }

  /**
   * CompanySupplier findUniqueOrThrow
   */
  export type CompanySupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter, which CompanySupplier to fetch.
     */
    where: CompanySupplierWhereUniqueInput
  }

  /**
   * CompanySupplier findFirst
   */
  export type CompanySupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter, which CompanySupplier to fetch.
     */
    where?: CompanySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySuppliers to fetch.
     */
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySuppliers.
     */
    cursor?: CompanySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySuppliers.
     */
    distinct?: CompanySupplierScalarFieldEnum | CompanySupplierScalarFieldEnum[]
  }

  /**
   * CompanySupplier findFirstOrThrow
   */
  export type CompanySupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter, which CompanySupplier to fetch.
     */
    where?: CompanySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySuppliers to fetch.
     */
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySuppliers.
     */
    cursor?: CompanySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySuppliers.
     */
    distinct?: CompanySupplierScalarFieldEnum | CompanySupplierScalarFieldEnum[]
  }

  /**
   * CompanySupplier findMany
   */
  export type CompanySupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter, which CompanySuppliers to fetch.
     */
    where?: CompanySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySuppliers to fetch.
     */
    orderBy?: CompanySupplierOrderByWithRelationInput | CompanySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanySuppliers.
     */
    cursor?: CompanySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySuppliers.
     */
    skip?: number
    distinct?: CompanySupplierScalarFieldEnum | CompanySupplierScalarFieldEnum[]
  }

  /**
   * CompanySupplier create
   */
  export type CompanySupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanySupplier.
     */
    data: XOR<CompanySupplierCreateInput, CompanySupplierUncheckedCreateInput>
  }

  /**
   * CompanySupplier createMany
   */
  export type CompanySupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanySuppliers.
     */
    data: CompanySupplierCreateManyInput | CompanySupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySupplier update
   */
  export type CompanySupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanySupplier.
     */
    data: XOR<CompanySupplierUpdateInput, CompanySupplierUncheckedUpdateInput>
    /**
     * Choose, which CompanySupplier to update.
     */
    where: CompanySupplierWhereUniqueInput
  }

  /**
   * CompanySupplier updateMany
   */
  export type CompanySupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanySuppliers.
     */
    data: XOR<CompanySupplierUpdateManyMutationInput, CompanySupplierUncheckedUpdateManyInput>
    /**
     * Filter which CompanySuppliers to update
     */
    where?: CompanySupplierWhereInput
  }

  /**
   * CompanySupplier upsert
   */
  export type CompanySupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanySupplier to update in case it exists.
     */
    where: CompanySupplierWhereUniqueInput
    /**
     * In case the CompanySupplier found by the `where` argument doesn't exist, create a new CompanySupplier with this data.
     */
    create: XOR<CompanySupplierCreateInput, CompanySupplierUncheckedCreateInput>
    /**
     * In case the CompanySupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanySupplierUpdateInput, CompanySupplierUncheckedUpdateInput>
  }

  /**
   * CompanySupplier delete
   */
  export type CompanySupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
    /**
     * Filter which CompanySupplier to delete.
     */
    where: CompanySupplierWhereUniqueInput
  }

  /**
   * CompanySupplier deleteMany
   */
  export type CompanySupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySuppliers to delete
     */
    where?: CompanySupplierWhereInput
  }

  /**
   * CompanySupplier without action
   */
  export type CompanySupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySupplier
     */
    select?: CompanySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySupplierInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnitSupplier
   */

  export type AggregateBusinessUnitSupplier = {
    _count: BusinessUnitSupplierCountAggregateOutputType | null
    _min: BusinessUnitSupplierMinAggregateOutputType | null
    _max: BusinessUnitSupplierMaxAggregateOutputType | null
  }

  export type BusinessUnitSupplierMinAggregateOutputType = {
    id: string | null
    businessUnitId: string | null
    supplierId: string | null
    createdAt: Date | null
  }

  export type BusinessUnitSupplierMaxAggregateOutputType = {
    id: string | null
    businessUnitId: string | null
    supplierId: string | null
    createdAt: Date | null
  }

  export type BusinessUnitSupplierCountAggregateOutputType = {
    id: number
    businessUnitId: number
    supplierId: number
    createdAt: number
    _all: number
  }


  export type BusinessUnitSupplierMinAggregateInputType = {
    id?: true
    businessUnitId?: true
    supplierId?: true
    createdAt?: true
  }

  export type BusinessUnitSupplierMaxAggregateInputType = {
    id?: true
    businessUnitId?: true
    supplierId?: true
    createdAt?: true
  }

  export type BusinessUnitSupplierCountAggregateInputType = {
    id?: true
    businessUnitId?: true
    supplierId?: true
    createdAt?: true
    _all?: true
  }

  export type BusinessUnitSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitSupplier to aggregate.
     */
    where?: BusinessUnitSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSuppliers to fetch.
     */
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnitSuppliers
    **/
    _count?: true | BusinessUnitSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitSupplierMaxAggregateInputType
  }

  export type GetBusinessUnitSupplierAggregateType<T extends BusinessUnitSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnitSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnitSupplier[P]>
      : GetScalarType<T[P], AggregateBusinessUnitSupplier[P]>
  }




  export type BusinessUnitSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSupplierWhereInput
    orderBy?: BusinessUnitSupplierOrderByWithAggregationInput | BusinessUnitSupplierOrderByWithAggregationInput[]
    by: BusinessUnitSupplierScalarFieldEnum[] | BusinessUnitSupplierScalarFieldEnum
    having?: BusinessUnitSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitSupplierCountAggregateInputType | true
    _min?: BusinessUnitSupplierMinAggregateInputType
    _max?: BusinessUnitSupplierMaxAggregateInputType
  }

  export type BusinessUnitSupplierGroupByOutputType = {
    id: string
    businessUnitId: string
    supplierId: string
    createdAt: Date
    _count: BusinessUnitSupplierCountAggregateOutputType | null
    _min: BusinessUnitSupplierMinAggregateOutputType | null
    _max: BusinessUnitSupplierMaxAggregateOutputType | null
  }

  type GetBusinessUnitSupplierGroupByPayload<T extends BusinessUnitSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitSupplierGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitSupplier"]>


  export type BusinessUnitSupplierSelectScalar = {
    id?: boolean
    businessUnitId?: boolean
    supplierId?: boolean
    createdAt?: boolean
  }

  export type BusinessUnitSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $BusinessUnitSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnitSupplier"
    objects: {
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessUnitId: string
      supplierId: string
      createdAt: Date
    }, ExtArgs["result"]["businessUnitSupplier"]>
    composites: {}
  }

  type BusinessUnitSupplierGetPayload<S extends boolean | null | undefined | BusinessUnitSupplierDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitSupplierPayload, S>

  type BusinessUnitSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessUnitSupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessUnitSupplierCountAggregateInputType | true
    }

  export interface BusinessUnitSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnitSupplier'], meta: { name: 'BusinessUnitSupplier' } }
    /**
     * Find zero or one BusinessUnitSupplier that matches the filter.
     * @param {BusinessUnitSupplierFindUniqueArgs} args - Arguments to find a BusinessUnitSupplier
     * @example
     * // Get one BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitSupplierFindUniqueArgs>(args: SelectSubset<T, BusinessUnitSupplierFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessUnitSupplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessUnitSupplierFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnitSupplier
     * @example
     * // Get one BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessUnitSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierFindFirstArgs} args - Arguments to find a BusinessUnitSupplier
     * @example
     * // Get one BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitSupplierFindFirstArgs>(args?: SelectSubset<T, BusinessUnitSupplierFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessUnitSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierFindFirstOrThrowArgs} args - Arguments to find a BusinessUnitSupplier
     * @example
     * // Get one BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessUnitSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnitSuppliers
     * const businessUnitSuppliers = await prisma.businessUnitSupplier.findMany()
     * 
     * // Get first 10 BusinessUnitSuppliers
     * const businessUnitSuppliers = await prisma.businessUnitSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitSupplierWithIdOnly = await prisma.businessUnitSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitSupplierFindManyArgs>(args?: SelectSubset<T, BusinessUnitSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessUnitSupplier.
     * @param {BusinessUnitSupplierCreateArgs} args - Arguments to create a BusinessUnitSupplier.
     * @example
     * // Create one BusinessUnitSupplier
     * const BusinessUnitSupplier = await prisma.businessUnitSupplier.create({
     *   data: {
     *     // ... data to create a BusinessUnitSupplier
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitSupplierCreateArgs>(args: SelectSubset<T, BusinessUnitSupplierCreateArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessUnitSuppliers.
     * @param {BusinessUnitSupplierCreateManyArgs} args - Arguments to create many BusinessUnitSuppliers.
     * @example
     * // Create many BusinessUnitSuppliers
     * const businessUnitSupplier = await prisma.businessUnitSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitSupplierCreateManyArgs>(args?: SelectSubset<T, BusinessUnitSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessUnitSupplier.
     * @param {BusinessUnitSupplierDeleteArgs} args - Arguments to delete one BusinessUnitSupplier.
     * @example
     * // Delete one BusinessUnitSupplier
     * const BusinessUnitSupplier = await prisma.businessUnitSupplier.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnitSupplier
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitSupplierDeleteArgs>(args: SelectSubset<T, BusinessUnitSupplierDeleteArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessUnitSupplier.
     * @param {BusinessUnitSupplierUpdateArgs} args - Arguments to update one BusinessUnitSupplier.
     * @example
     * // Update one BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitSupplierUpdateArgs>(args: SelectSubset<T, BusinessUnitSupplierUpdateArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessUnitSuppliers.
     * @param {BusinessUnitSupplierDeleteManyArgs} args - Arguments to filter BusinessUnitSuppliers to delete.
     * @example
     * // Delete a few BusinessUnitSuppliers
     * const { count } = await prisma.businessUnitSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitSupplierDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnitSuppliers
     * const businessUnitSupplier = await prisma.businessUnitSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitSupplierUpdateManyArgs>(args: SelectSubset<T, BusinessUnitSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessUnitSupplier.
     * @param {BusinessUnitSupplierUpsertArgs} args - Arguments to update or create a BusinessUnitSupplier.
     * @example
     * // Update or create a BusinessUnitSupplier
     * const businessUnitSupplier = await prisma.businessUnitSupplier.upsert({
     *   create: {
     *     // ... data to create a BusinessUnitSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnitSupplier we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitSupplierUpsertArgs>(args: SelectSubset<T, BusinessUnitSupplierUpsertArgs<ExtArgs>>): Prisma__BusinessUnitSupplierClient<$Result.GetResult<Prisma.$BusinessUnitSupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessUnitSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierCountArgs} args - Arguments to filter BusinessUnitSuppliers to count.
     * @example
     * // Count the number of BusinessUnitSuppliers
     * const count = await prisma.businessUnitSupplier.count({
     *   where: {
     *     // ... the filter for the BusinessUnitSuppliers we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitSupplierCountArgs>(
      args?: Subset<T, BusinessUnitSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnitSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitSupplierAggregateArgs>(args: Subset<T, BusinessUnitSupplierAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitSupplierAggregateType<T>>

    /**
     * Group by BusinessUnitSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitSupplierGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnitSupplier model
   */
  readonly fields: BusinessUnitSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnitSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessUnit<T extends BusinessUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnitDefaultArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnitSupplier model
   */ 
  interface BusinessUnitSupplierFieldRefs {
    readonly id: FieldRef<"BusinessUnitSupplier", 'String'>
    readonly businessUnitId: FieldRef<"BusinessUnitSupplier", 'String'>
    readonly supplierId: FieldRef<"BusinessUnitSupplier", 'String'>
    readonly createdAt: FieldRef<"BusinessUnitSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnitSupplier findUnique
   */
  export type BusinessUnitSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSupplier to fetch.
     */
    where: BusinessUnitSupplierWhereUniqueInput
  }

  /**
   * BusinessUnitSupplier findUniqueOrThrow
   */
  export type BusinessUnitSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSupplier to fetch.
     */
    where: BusinessUnitSupplierWhereUniqueInput
  }

  /**
   * BusinessUnitSupplier findFirst
   */
  export type BusinessUnitSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSupplier to fetch.
     */
    where?: BusinessUnitSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSuppliers to fetch.
     */
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitSuppliers.
     */
    cursor?: BusinessUnitSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitSuppliers.
     */
    distinct?: BusinessUnitSupplierScalarFieldEnum | BusinessUnitSupplierScalarFieldEnum[]
  }

  /**
   * BusinessUnitSupplier findFirstOrThrow
   */
  export type BusinessUnitSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSupplier to fetch.
     */
    where?: BusinessUnitSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSuppliers to fetch.
     */
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitSuppliers.
     */
    cursor?: BusinessUnitSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitSuppliers.
     */
    distinct?: BusinessUnitSupplierScalarFieldEnum | BusinessUnitSupplierScalarFieldEnum[]
  }

  /**
   * BusinessUnitSupplier findMany
   */
  export type BusinessUnitSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSuppliers to fetch.
     */
    where?: BusinessUnitSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSuppliers to fetch.
     */
    orderBy?: BusinessUnitSupplierOrderByWithRelationInput | BusinessUnitSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnitSuppliers.
     */
    cursor?: BusinessUnitSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSuppliers.
     */
    skip?: number
    distinct?: BusinessUnitSupplierScalarFieldEnum | BusinessUnitSupplierScalarFieldEnum[]
  }

  /**
   * BusinessUnitSupplier create
   */
  export type BusinessUnitSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnitSupplier.
     */
    data: XOR<BusinessUnitSupplierCreateInput, BusinessUnitSupplierUncheckedCreateInput>
  }

  /**
   * BusinessUnitSupplier createMany
   */
  export type BusinessUnitSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnitSuppliers.
     */
    data: BusinessUnitSupplierCreateManyInput | BusinessUnitSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnitSupplier update
   */
  export type BusinessUnitSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnitSupplier.
     */
    data: XOR<BusinessUnitSupplierUpdateInput, BusinessUnitSupplierUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnitSupplier to update.
     */
    where: BusinessUnitSupplierWhereUniqueInput
  }

  /**
   * BusinessUnitSupplier updateMany
   */
  export type BusinessUnitSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnitSuppliers.
     */
    data: XOR<BusinessUnitSupplierUpdateManyMutationInput, BusinessUnitSupplierUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitSuppliers to update
     */
    where?: BusinessUnitSupplierWhereInput
  }

  /**
   * BusinessUnitSupplier upsert
   */
  export type BusinessUnitSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnitSupplier to update in case it exists.
     */
    where: BusinessUnitSupplierWhereUniqueInput
    /**
     * In case the BusinessUnitSupplier found by the `where` argument doesn't exist, create a new BusinessUnitSupplier with this data.
     */
    create: XOR<BusinessUnitSupplierCreateInput, BusinessUnitSupplierUncheckedCreateInput>
    /**
     * In case the BusinessUnitSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitSupplierUpdateInput, BusinessUnitSupplierUncheckedUpdateInput>
  }

  /**
   * BusinessUnitSupplier delete
   */
  export type BusinessUnitSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnitSupplier to delete.
     */
    where: BusinessUnitSupplierWhereUniqueInput
  }

  /**
   * BusinessUnitSupplier deleteMany
   */
  export type BusinessUnitSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitSuppliers to delete
     */
    where?: BusinessUnitSupplierWhereInput
  }

  /**
   * BusinessUnitSupplier without action
   */
  export type BusinessUnitSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSupplier
     */
    select?: BusinessUnitSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSupplierInclude<ExtArgs> | null
  }


  /**
   * Model CompanyBanque
   */

  export type AggregateCompanyBanque = {
    _count: CompanyBanqueCountAggregateOutputType | null
    _min: CompanyBanqueMinAggregateOutputType | null
    _max: CompanyBanqueMaxAggregateOutputType | null
  }

  export type CompanyBanqueMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    banqueId: string | null
    createdAt: Date | null
  }

  export type CompanyBanqueMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    banqueId: string | null
    createdAt: Date | null
  }

  export type CompanyBanqueCountAggregateOutputType = {
    id: number
    companyId: number
    banqueId: number
    createdAt: number
    _all: number
  }


  export type CompanyBanqueMinAggregateInputType = {
    id?: true
    companyId?: true
    banqueId?: true
    createdAt?: true
  }

  export type CompanyBanqueMaxAggregateInputType = {
    id?: true
    companyId?: true
    banqueId?: true
    createdAt?: true
  }

  export type CompanyBanqueCountAggregateInputType = {
    id?: true
    companyId?: true
    banqueId?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyBanqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBanque to aggregate.
     */
    where?: CompanyBanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBanques to fetch.
     */
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyBanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBanques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBanques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyBanques
    **/
    _count?: true | CompanyBanqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyBanqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyBanqueMaxAggregateInputType
  }

  export type GetCompanyBanqueAggregateType<T extends CompanyBanqueAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyBanque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyBanque[P]>
      : GetScalarType<T[P], AggregateCompanyBanque[P]>
  }




  export type CompanyBanqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBanqueWhereInput
    orderBy?: CompanyBanqueOrderByWithAggregationInput | CompanyBanqueOrderByWithAggregationInput[]
    by: CompanyBanqueScalarFieldEnum[] | CompanyBanqueScalarFieldEnum
    having?: CompanyBanqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyBanqueCountAggregateInputType | true
    _min?: CompanyBanqueMinAggregateInputType
    _max?: CompanyBanqueMaxAggregateInputType
  }

  export type CompanyBanqueGroupByOutputType = {
    id: string
    companyId: string
    banqueId: string
    createdAt: Date
    _count: CompanyBanqueCountAggregateOutputType | null
    _min: CompanyBanqueMinAggregateOutputType | null
    _max: CompanyBanqueMaxAggregateOutputType | null
  }

  type GetCompanyBanqueGroupByPayload<T extends CompanyBanqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyBanqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyBanqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyBanqueGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyBanqueGroupByOutputType[P]>
        }
      >
    >


  export type CompanyBanqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    banqueId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBanque"]>


  export type CompanyBanqueSelectScalar = {
    id?: boolean
    companyId?: boolean
    banqueId?: boolean
    createdAt?: boolean
  }

  export type CompanyBanqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    banque?: boolean | BanqueDefaultArgs<ExtArgs>
  }

  export type $CompanyBanquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyBanque"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      banque: Prisma.$BanquePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      banqueId: string
      createdAt: Date
    }, ExtArgs["result"]["companyBanque"]>
    composites: {}
  }

  type CompanyBanqueGetPayload<S extends boolean | null | undefined | CompanyBanqueDefaultArgs> = $Result.GetResult<Prisma.$CompanyBanquePayload, S>

  type CompanyBanqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyBanqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyBanqueCountAggregateInputType | true
    }

  export interface CompanyBanqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyBanque'], meta: { name: 'CompanyBanque' } }
    /**
     * Find zero or one CompanyBanque that matches the filter.
     * @param {CompanyBanqueFindUniqueArgs} args - Arguments to find a CompanyBanque
     * @example
     * // Get one CompanyBanque
     * const companyBanque = await prisma.companyBanque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyBanqueFindUniqueArgs>(args: SelectSubset<T, CompanyBanqueFindUniqueArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyBanque that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyBanqueFindUniqueOrThrowArgs} args - Arguments to find a CompanyBanque
     * @example
     * // Get one CompanyBanque
     * const companyBanque = await prisma.companyBanque.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyBanqueFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyBanqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyBanque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueFindFirstArgs} args - Arguments to find a CompanyBanque
     * @example
     * // Get one CompanyBanque
     * const companyBanque = await prisma.companyBanque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyBanqueFindFirstArgs>(args?: SelectSubset<T, CompanyBanqueFindFirstArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyBanque that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueFindFirstOrThrowArgs} args - Arguments to find a CompanyBanque
     * @example
     * // Get one CompanyBanque
     * const companyBanque = await prisma.companyBanque.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyBanqueFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyBanqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyBanques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyBanques
     * const companyBanques = await prisma.companyBanque.findMany()
     * 
     * // Get first 10 CompanyBanques
     * const companyBanques = await prisma.companyBanque.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyBanqueWithIdOnly = await prisma.companyBanque.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyBanqueFindManyArgs>(args?: SelectSubset<T, CompanyBanqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyBanque.
     * @param {CompanyBanqueCreateArgs} args - Arguments to create a CompanyBanque.
     * @example
     * // Create one CompanyBanque
     * const CompanyBanque = await prisma.companyBanque.create({
     *   data: {
     *     // ... data to create a CompanyBanque
     *   }
     * })
     * 
     */
    create<T extends CompanyBanqueCreateArgs>(args: SelectSubset<T, CompanyBanqueCreateArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyBanques.
     * @param {CompanyBanqueCreateManyArgs} args - Arguments to create many CompanyBanques.
     * @example
     * // Create many CompanyBanques
     * const companyBanque = await prisma.companyBanque.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyBanqueCreateManyArgs>(args?: SelectSubset<T, CompanyBanqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyBanque.
     * @param {CompanyBanqueDeleteArgs} args - Arguments to delete one CompanyBanque.
     * @example
     * // Delete one CompanyBanque
     * const CompanyBanque = await prisma.companyBanque.delete({
     *   where: {
     *     // ... filter to delete one CompanyBanque
     *   }
     * })
     * 
     */
    delete<T extends CompanyBanqueDeleteArgs>(args: SelectSubset<T, CompanyBanqueDeleteArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyBanque.
     * @param {CompanyBanqueUpdateArgs} args - Arguments to update one CompanyBanque.
     * @example
     * // Update one CompanyBanque
     * const companyBanque = await prisma.companyBanque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyBanqueUpdateArgs>(args: SelectSubset<T, CompanyBanqueUpdateArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyBanques.
     * @param {CompanyBanqueDeleteManyArgs} args - Arguments to filter CompanyBanques to delete.
     * @example
     * // Delete a few CompanyBanques
     * const { count } = await prisma.companyBanque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyBanqueDeleteManyArgs>(args?: SelectSubset<T, CompanyBanqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyBanques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyBanques
     * const companyBanque = await prisma.companyBanque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyBanqueUpdateManyArgs>(args: SelectSubset<T, CompanyBanqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyBanque.
     * @param {CompanyBanqueUpsertArgs} args - Arguments to update or create a CompanyBanque.
     * @example
     * // Update or create a CompanyBanque
     * const companyBanque = await prisma.companyBanque.upsert({
     *   create: {
     *     // ... data to create a CompanyBanque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyBanque we want to update
     *   }
     * })
     */
    upsert<T extends CompanyBanqueUpsertArgs>(args: SelectSubset<T, CompanyBanqueUpsertArgs<ExtArgs>>): Prisma__CompanyBanqueClient<$Result.GetResult<Prisma.$CompanyBanquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyBanques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueCountArgs} args - Arguments to filter CompanyBanques to count.
     * @example
     * // Count the number of CompanyBanques
     * const count = await prisma.companyBanque.count({
     *   where: {
     *     // ... the filter for the CompanyBanques we want to count
     *   }
     * })
    **/
    count<T extends CompanyBanqueCountArgs>(
      args?: Subset<T, CompanyBanqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyBanqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyBanque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyBanqueAggregateArgs>(args: Subset<T, CompanyBanqueAggregateArgs>): Prisma.PrismaPromise<GetCompanyBanqueAggregateType<T>>

    /**
     * Group by CompanyBanque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBanqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyBanqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyBanqueGroupByArgs['orderBy'] }
        : { orderBy?: CompanyBanqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyBanqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyBanqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyBanque model
   */
  readonly fields: CompanyBanqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyBanque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyBanqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    banque<T extends BanqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BanqueDefaultArgs<ExtArgs>>): Prisma__BanqueClient<$Result.GetResult<Prisma.$BanquePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyBanque model
   */ 
  interface CompanyBanqueFieldRefs {
    readonly id: FieldRef<"CompanyBanque", 'String'>
    readonly companyId: FieldRef<"CompanyBanque", 'String'>
    readonly banqueId: FieldRef<"CompanyBanque", 'String'>
    readonly createdAt: FieldRef<"CompanyBanque", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyBanque findUnique
   */
  export type CompanyBanqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBanque to fetch.
     */
    where: CompanyBanqueWhereUniqueInput
  }

  /**
   * CompanyBanque findUniqueOrThrow
   */
  export type CompanyBanqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBanque to fetch.
     */
    where: CompanyBanqueWhereUniqueInput
  }

  /**
   * CompanyBanque findFirst
   */
  export type CompanyBanqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBanque to fetch.
     */
    where?: CompanyBanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBanques to fetch.
     */
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBanques.
     */
    cursor?: CompanyBanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBanques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBanques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBanques.
     */
    distinct?: CompanyBanqueScalarFieldEnum | CompanyBanqueScalarFieldEnum[]
  }

  /**
   * CompanyBanque findFirstOrThrow
   */
  export type CompanyBanqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBanque to fetch.
     */
    where?: CompanyBanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBanques to fetch.
     */
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBanques.
     */
    cursor?: CompanyBanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBanques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBanques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBanques.
     */
    distinct?: CompanyBanqueScalarFieldEnum | CompanyBanqueScalarFieldEnum[]
  }

  /**
   * CompanyBanque findMany
   */
  export type CompanyBanqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBanques to fetch.
     */
    where?: CompanyBanqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBanques to fetch.
     */
    orderBy?: CompanyBanqueOrderByWithRelationInput | CompanyBanqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyBanques.
     */
    cursor?: CompanyBanqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBanques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBanques.
     */
    skip?: number
    distinct?: CompanyBanqueScalarFieldEnum | CompanyBanqueScalarFieldEnum[]
  }

  /**
   * CompanyBanque create
   */
  export type CompanyBanqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyBanque.
     */
    data: XOR<CompanyBanqueCreateInput, CompanyBanqueUncheckedCreateInput>
  }

  /**
   * CompanyBanque createMany
   */
  export type CompanyBanqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyBanques.
     */
    data: CompanyBanqueCreateManyInput | CompanyBanqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyBanque update
   */
  export type CompanyBanqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyBanque.
     */
    data: XOR<CompanyBanqueUpdateInput, CompanyBanqueUncheckedUpdateInput>
    /**
     * Choose, which CompanyBanque to update.
     */
    where: CompanyBanqueWhereUniqueInput
  }

  /**
   * CompanyBanque updateMany
   */
  export type CompanyBanqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyBanques.
     */
    data: XOR<CompanyBanqueUpdateManyMutationInput, CompanyBanqueUncheckedUpdateManyInput>
    /**
     * Filter which CompanyBanques to update
     */
    where?: CompanyBanqueWhereInput
  }

  /**
   * CompanyBanque upsert
   */
  export type CompanyBanqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyBanque to update in case it exists.
     */
    where: CompanyBanqueWhereUniqueInput
    /**
     * In case the CompanyBanque found by the `where` argument doesn't exist, create a new CompanyBanque with this data.
     */
    create: XOR<CompanyBanqueCreateInput, CompanyBanqueUncheckedCreateInput>
    /**
     * In case the CompanyBanque was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyBanqueUpdateInput, CompanyBanqueUncheckedUpdateInput>
  }

  /**
   * CompanyBanque delete
   */
  export type CompanyBanqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
    /**
     * Filter which CompanyBanque to delete.
     */
    where: CompanyBanqueWhereUniqueInput
  }

  /**
   * CompanyBanque deleteMany
   */
  export type CompanyBanqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBanques to delete
     */
    where?: CompanyBanqueWhereInput
  }

  /**
   * CompanyBanque without action
   */
  export type CompanyBanqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBanque
     */
    select?: CompanyBanqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBanqueInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly code: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    resource: string | null
    action: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    resource: string | null
    action: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    resource: number
    action: number
    scope: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    resource?: true
    action?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    resource?: true
    action?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    resource?: true
    action?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    resource: string
    action: string
    scope: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>


  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      resource: string
      action: string
      scope: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly scope: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    companyId: string | null
    businessUnitId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    companyId: string | null
    businessUnitId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    companyId: number
    businessUnitId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
    businessUnitId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
    businessUnitId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
    businessUnitId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    companyId: string | null
    businessUnitId: string | null
    assignedAt: Date
    assignedBy: string | null
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    companyId?: boolean
    businessUnitId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>


  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    companyId?: boolean
    businessUnitId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      companyId: string | null
      businessUnitId: string | null
      assignedAt: Date
      assignedBy: string | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly companyId: FieldRef<"UserRole", 'String'>
    readonly businessUnitId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>


  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entity: number
    entityId: number
    userId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    userId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entity: string
    entityId: string
    userId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    userId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entity: string
      entityId: string
      userId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowTemplate
   */

  export type AggregateWorkflowTemplate = {
    _count: WorkflowTemplateCountAggregateOutputType | null
    _avg: WorkflowTemplateAvgAggregateOutputType | null
    _sum: WorkflowTemplateSumAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  export type WorkflowTemplateAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type WorkflowTemplateSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type WorkflowTemplateMinAggregateOutputType = {
    id: string | null
    code: string | null
    label: string | null
    description: string | null
    icon: string | null
    color: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowTemplateMaxAggregateOutputType = {
    id: string | null
    code: string | null
    label: string | null
    description: string | null
    icon: string | null
    color: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowTemplateCountAggregateOutputType = {
    id: number
    code: number
    label: number
    description: number
    icon: number
    color: number
    displayOrder: number
    formSchema: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowTemplateAvgAggregateInputType = {
    displayOrder?: true
  }

  export type WorkflowTemplateSumAggregateInputType = {
    displayOrder?: true
  }

  export type WorkflowTemplateMinAggregateInputType = {
    id?: true
    code?: true
    label?: true
    description?: true
    icon?: true
    color?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowTemplateMaxAggregateInputType = {
    id?: true
    code?: true
    label?: true
    description?: true
    icon?: true
    color?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowTemplateCountAggregateInputType = {
    id?: true
    code?: true
    label?: true
    description?: true
    icon?: true
    color?: true
    displayOrder?: true
    formSchema?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplate to aggregate.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowTemplates
    **/
    _count?: true | WorkflowTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type GetWorkflowTemplateAggregateType<T extends WorkflowTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
      : GetScalarType<T[P], AggregateWorkflowTemplate[P]>
  }




  export type WorkflowTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowTemplateWhereInput
    orderBy?: WorkflowTemplateOrderByWithAggregationInput | WorkflowTemplateOrderByWithAggregationInput[]
    by: WorkflowTemplateScalarFieldEnum[] | WorkflowTemplateScalarFieldEnum
    having?: WorkflowTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowTemplateCountAggregateInputType | true
    _avg?: WorkflowTemplateAvgAggregateInputType
    _sum?: WorkflowTemplateSumAggregateInputType
    _min?: WorkflowTemplateMinAggregateInputType
    _max?: WorkflowTemplateMaxAggregateInputType
  }

  export type WorkflowTemplateGroupByOutputType = {
    id: string
    code: string
    label: string
    description: string | null
    icon: string | null
    color: string | null
    displayOrder: number
    formSchema: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkflowTemplateCountAggregateOutputType | null
    _avg: WorkflowTemplateAvgAggregateOutputType | null
    _sum: WorkflowTemplateSumAggregateOutputType | null
    _min: WorkflowTemplateMinAggregateOutputType | null
    _max: WorkflowTemplateMaxAggregateOutputType | null
  }

  type GetWorkflowTemplateGroupByPayload<T extends WorkflowTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowTemplateGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    displayOrder?: boolean
    formSchema?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steps?: boolean | WorkflowTemplate$stepsArgs<ExtArgs>
    engagements?: boolean | WorkflowTemplate$engagementsArgs<ExtArgs>
    _count?: boolean | WorkflowTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowTemplate"]>


  export type WorkflowTemplateSelectScalar = {
    id?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    displayOrder?: boolean
    formSchema?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | WorkflowTemplate$stepsArgs<ExtArgs>
    engagements?: boolean | WorkflowTemplate$engagementsArgs<ExtArgs>
    _count?: boolean | WorkflowTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WorkflowTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowTemplate"
    objects: {
      steps: Prisma.$WorkflowStepPayload<ExtArgs>[]
      engagements: Prisma.$EngagementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      label: string
      description: string | null
      icon: string | null
      color: string | null
      displayOrder: number
      formSchema: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowTemplate"]>
    composites: {}
  }

  type WorkflowTemplateGetPayload<S extends boolean | null | undefined | WorkflowTemplateDefaultArgs> = $Result.GetResult<Prisma.$WorkflowTemplatePayload, S>

  type WorkflowTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowTemplateCountAggregateInputType | true
    }

  export interface WorkflowTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowTemplate'], meta: { name: 'WorkflowTemplate' } }
    /**
     * Find zero or one WorkflowTemplate that matches the filter.
     * @param {WorkflowTemplateFindUniqueArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowTemplateFindUniqueArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowTemplateFindUniqueOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowTemplateFindFirstArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindFirstOrThrowArgs} args - Arguments to find a WorkflowTemplate
     * @example
     * // Get one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany()
     * 
     * // Get first 10 WorkflowTemplates
     * const workflowTemplates = await prisma.workflowTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowTemplateWithIdOnly = await prisma.workflowTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowTemplateFindManyArgs>(args?: SelectSubset<T, WorkflowTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowTemplate.
     * @param {WorkflowTemplateCreateArgs} args - Arguments to create a WorkflowTemplate.
     * @example
     * // Create one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.create({
     *   data: {
     *     // ... data to create a WorkflowTemplate
     *   }
     * })
     * 
     */
    create<T extends WorkflowTemplateCreateArgs>(args: SelectSubset<T, WorkflowTemplateCreateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowTemplates.
     * @param {WorkflowTemplateCreateManyArgs} args - Arguments to create many WorkflowTemplates.
     * @example
     * // Create many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowTemplateCreateManyArgs>(args?: SelectSubset<T, WorkflowTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkflowTemplate.
     * @param {WorkflowTemplateDeleteArgs} args - Arguments to delete one WorkflowTemplate.
     * @example
     * // Delete one WorkflowTemplate
     * const WorkflowTemplate = await prisma.workflowTemplate.delete({
     *   where: {
     *     // ... filter to delete one WorkflowTemplate
     *   }
     * })
     * 
     */
    delete<T extends WorkflowTemplateDeleteArgs>(args: SelectSubset<T, WorkflowTemplateDeleteArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowTemplate.
     * @param {WorkflowTemplateUpdateArgs} args - Arguments to update one WorkflowTemplate.
     * @example
     * // Update one WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowTemplateUpdateArgs>(args: SelectSubset<T, WorkflowTemplateUpdateArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowTemplates.
     * @param {WorkflowTemplateDeleteManyArgs} args - Arguments to filter WorkflowTemplates to delete.
     * @example
     * // Delete a few WorkflowTemplates
     * const { count } = await prisma.workflowTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowTemplateDeleteManyArgs>(args?: SelectSubset<T, WorkflowTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowTemplates
     * const workflowTemplate = await prisma.workflowTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowTemplateUpdateManyArgs>(args: SelectSubset<T, WorkflowTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowTemplate.
     * @param {WorkflowTemplateUpsertArgs} args - Arguments to update or create a WorkflowTemplate.
     * @example
     * // Update or create a WorkflowTemplate
     * const workflowTemplate = await prisma.workflowTemplate.upsert({
     *   create: {
     *     // ... data to create a WorkflowTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowTemplate we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowTemplateUpsertArgs>(args: SelectSubset<T, WorkflowTemplateUpsertArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateCountArgs} args - Arguments to filter WorkflowTemplates to count.
     * @example
     * // Count the number of WorkflowTemplates
     * const count = await prisma.workflowTemplate.count({
     *   where: {
     *     // ... the filter for the WorkflowTemplates we want to count
     *   }
     * })
    **/
    count<T extends WorkflowTemplateCountArgs>(
      args?: Subset<T, WorkflowTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowTemplateAggregateArgs>(args: Subset<T, WorkflowTemplateAggregateArgs>): Prisma.PrismaPromise<GetWorkflowTemplateAggregateType<T>>

    /**
     * Group by WorkflowTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowTemplateGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowTemplate model
   */
  readonly fields: WorkflowTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steps<T extends WorkflowTemplate$stepsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowTemplate$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany"> | Null>
    engagements<T extends WorkflowTemplate$engagementsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowTemplate$engagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowTemplate model
   */ 
  interface WorkflowTemplateFieldRefs {
    readonly id: FieldRef<"WorkflowTemplate", 'String'>
    readonly code: FieldRef<"WorkflowTemplate", 'String'>
    readonly label: FieldRef<"WorkflowTemplate", 'String'>
    readonly description: FieldRef<"WorkflowTemplate", 'String'>
    readonly icon: FieldRef<"WorkflowTemplate", 'String'>
    readonly color: FieldRef<"WorkflowTemplate", 'String'>
    readonly displayOrder: FieldRef<"WorkflowTemplate", 'Int'>
    readonly formSchema: FieldRef<"WorkflowTemplate", 'Json'>
    readonly isActive: FieldRef<"WorkflowTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"WorkflowTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowTemplate findUnique
   */
  export type WorkflowTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findUniqueOrThrow
   */
  export type WorkflowTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate findFirst
   */
  export type WorkflowTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findFirstOrThrow
   */
  export type WorkflowTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplate to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowTemplates.
     */
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate findMany
   */
  export type WorkflowTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowTemplates to fetch.
     */
    where?: WorkflowTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowTemplates to fetch.
     */
    orderBy?: WorkflowTemplateOrderByWithRelationInput | WorkflowTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowTemplates.
     */
    cursor?: WorkflowTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowTemplates.
     */
    skip?: number
    distinct?: WorkflowTemplateScalarFieldEnum | WorkflowTemplateScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate create
   */
  export type WorkflowTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
  }

  /**
   * WorkflowTemplate createMany
   */
  export type WorkflowTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowTemplates.
     */
    data: WorkflowTemplateCreateManyInput | WorkflowTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowTemplate update
   */
  export type WorkflowTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowTemplate.
     */
    data: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
    /**
     * Choose, which WorkflowTemplate to update.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate updateMany
   */
  export type WorkflowTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowTemplates.
     */
    data: XOR<WorkflowTemplateUpdateManyMutationInput, WorkflowTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowTemplates to update
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate upsert
   */
  export type WorkflowTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowTemplate to update in case it exists.
     */
    where: WorkflowTemplateWhereUniqueInput
    /**
     * In case the WorkflowTemplate found by the `where` argument doesn't exist, create a new WorkflowTemplate with this data.
     */
    create: XOR<WorkflowTemplateCreateInput, WorkflowTemplateUncheckedCreateInput>
    /**
     * In case the WorkflowTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowTemplateUpdateInput, WorkflowTemplateUncheckedUpdateInput>
  }

  /**
   * WorkflowTemplate delete
   */
  export type WorkflowTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
    /**
     * Filter which WorkflowTemplate to delete.
     */
    where: WorkflowTemplateWhereUniqueInput
  }

  /**
   * WorkflowTemplate deleteMany
   */
  export type WorkflowTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowTemplates to delete
     */
    where?: WorkflowTemplateWhereInput
  }

  /**
   * WorkflowTemplate.steps
   */
  export type WorkflowTemplate$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    cursor?: WorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate.engagements
   */
  export type WorkflowTemplate$engagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    where?: EngagementWhereInput
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    cursor?: EngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * WorkflowTemplate without action
   */
  export type WorkflowTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowTemplate
     */
    select?: WorkflowTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowTemplateInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStep
   */

  export type AggregateWorkflowStep = {
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  export type WorkflowStepAvgAggregateOutputType = {
    stepOrder: number | null
  }

  export type WorkflowStepSumAggregateOutputType = {
    stepOrder: number | null
  }

  export type WorkflowStepMinAggregateOutputType = {
    id: string | null
    workflowTemplateId: string | null
    stepOrder: number | null
    code: string | null
    label: string | null
    description: string | null
    requiresApproval: boolean | null
    triggerAction: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepMaxAggregateOutputType = {
    id: string | null
    workflowTemplateId: string | null
    stepOrder: number | null
    code: string | null
    label: string | null
    description: string | null
    requiresApproval: boolean | null
    triggerAction: string | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepCountAggregateOutputType = {
    id: number
    workflowTemplateId: number
    stepOrder: number
    code: number
    label: number
    description: number
    requiredFields: number
    requiredDocuments: number
    requiresApproval: number
    approvalRoles: number
    triggerAction: number
    icon: number
    color: number
    allowedRoles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowStepAvgAggregateInputType = {
    stepOrder?: true
  }

  export type WorkflowStepSumAggregateInputType = {
    stepOrder?: true
  }

  export type WorkflowStepMinAggregateInputType = {
    id?: true
    workflowTemplateId?: true
    stepOrder?: true
    code?: true
    label?: true
    description?: true
    requiresApproval?: true
    triggerAction?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepMaxAggregateInputType = {
    id?: true
    workflowTemplateId?: true
    stepOrder?: true
    code?: true
    label?: true
    description?: true
    requiresApproval?: true
    triggerAction?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepCountAggregateInputType = {
    id?: true
    workflowTemplateId?: true
    stepOrder?: true
    code?: true
    label?: true
    description?: true
    requiredFields?: true
    requiredDocuments?: true
    requiresApproval?: true
    approvalRoles?: true
    triggerAction?: true
    icon?: true
    color?: true
    allowedRoles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStep to aggregate.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowSteps
    **/
    _count?: true | WorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type GetWorkflowStepAggregateType<T extends WorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStep[P]>
      : GetScalarType<T[P], AggregateWorkflowStep[P]>
  }




  export type WorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithAggregationInput | WorkflowStepOrderByWithAggregationInput[]
    by: WorkflowStepScalarFieldEnum[] | WorkflowStepScalarFieldEnum
    having?: WorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepCountAggregateInputType | true
    _avg?: WorkflowStepAvgAggregateInputType
    _sum?: WorkflowStepSumAggregateInputType
    _min?: WorkflowStepMinAggregateInputType
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type WorkflowStepGroupByOutputType = {
    id: string
    workflowTemplateId: string
    stepOrder: number
    code: string
    label: string
    description: string | null
    requiredFields: JsonValue | null
    requiredDocuments: JsonValue | null
    requiresApproval: boolean
    approvalRoles: JsonValue | null
    triggerAction: string | null
    icon: string | null
    color: string | null
    allowedRoles: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  type GetWorkflowStepGroupByPayload<T extends WorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowTemplateId?: boolean
    stepOrder?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    requiredFields?: boolean
    requiredDocuments?: boolean
    requiresApproval?: boolean
    approvalRoles?: boolean
    triggerAction?: boolean
    icon?: boolean
    color?: boolean
    allowedRoles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | WorkflowTemplateDefaultArgs<ExtArgs>
    engagements?: boolean | WorkflowStep$engagementsArgs<ExtArgs>
    stepCompletions?: boolean | WorkflowStep$stepCompletionsArgs<ExtArgs>
    _count?: boolean | WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>


  export type WorkflowStepSelectScalar = {
    id?: boolean
    workflowTemplateId?: boolean
    stepOrder?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    requiredFields?: boolean
    requiredDocuments?: boolean
    requiresApproval?: boolean
    approvalRoles?: boolean
    triggerAction?: boolean
    icon?: boolean
    color?: boolean
    allowedRoles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | WorkflowTemplateDefaultArgs<ExtArgs>
    engagements?: boolean | WorkflowStep$engagementsArgs<ExtArgs>
    stepCompletions?: boolean | WorkflowStep$stepCompletionsArgs<ExtArgs>
    _count?: boolean | WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStep"
    objects: {
      template: Prisma.$WorkflowTemplatePayload<ExtArgs>
      engagements: Prisma.$EngagementPayload<ExtArgs>[]
      stepCompletions: Prisma.$StepCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowTemplateId: string
      stepOrder: number
      code: string
      label: string
      description: string | null
      requiredFields: Prisma.JsonValue | null
      requiredDocuments: Prisma.JsonValue | null
      requiresApproval: boolean
      approvalRoles: Prisma.JsonValue | null
      triggerAction: string | null
      icon: string | null
      color: string | null
      allowedRoles: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowStep"]>
    composites: {}
  }

  type WorkflowStepGetPayload<S extends boolean | null | undefined | WorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepPayload, S>

  type WorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepCountAggregateInputType | true
    }

  export interface WorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStep'], meta: { name: 'WorkflowStep' } }
    /**
     * Find zero or one WorkflowStep that matches the filter.
     * @param {WorkflowStepFindUniqueArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepFindUniqueArgs>(args: SelectSubset<T, WorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepFindFirstArgs>(args?: SelectSubset<T, WorkflowStepFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany()
     * 
     * // Get first 10 WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepFindManyArgs>(args?: SelectSubset<T, WorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStep.
     * @param {WorkflowStepCreateArgs} args - Arguments to create a WorkflowStep.
     * @example
     * // Create one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.create({
     *   data: {
     *     // ... data to create a WorkflowStep
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepCreateArgs>(args: SelectSubset<T, WorkflowStepCreateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowSteps.
     * @param {WorkflowStepCreateManyArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepCreateManyArgs>(args?: SelectSubset<T, WorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkflowStep.
     * @param {WorkflowStepDeleteArgs} args - Arguments to delete one WorkflowStep.
     * @example
     * // Delete one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepDeleteArgs>(args: SelectSubset<T, WorkflowStepDeleteArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStep.
     * @param {WorkflowStepUpdateArgs} args - Arguments to update one WorkflowStep.
     * @example
     * // Update one WorkflowStep
     * const workflowStep = await prisma.workflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepUpdateArgs>(args: SelectSubset<T, WorkflowStepUpdateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowSteps.
     * @param {WorkflowStepDeleteManyArgs} args - Arguments to filter WorkflowSteps to delete.
     * @example
     * // Delete a few WorkflowSteps
     * const { count } = await prisma.workflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepUpdateManyArgs>(args: SelectSubset<T, WorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStep.
     * @param {WorkflowStepUpsertArgs} args - Arguments to update or create a WorkflowStep.
     * @example
     * // Update or create a WorkflowStep
     * const workflowStep = await prisma.workflowStep.upsert({
     *   create: {
     *     // ... data to create a WorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepUpsertArgs>(args: SelectSubset<T, WorkflowStepUpsertArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepCountArgs} args - Arguments to filter WorkflowSteps to count.
     * @example
     * // Count the number of WorkflowSteps
     * const count = await prisma.workflowStep.count({
     *   where: {
     *     // ... the filter for the WorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepCountArgs>(
      args?: Subset<T, WorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepAggregateArgs>(args: Subset<T, WorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepAggregateType<T>>

    /**
     * Group by WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStep model
   */
  readonly fields: WorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends WorkflowTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowTemplateDefaultArgs<ExtArgs>>): Prisma__WorkflowTemplateClient<$Result.GetResult<Prisma.$WorkflowTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    engagements<T extends WorkflowStep$engagementsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStep$engagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementPayload<ExtArgs>, T, "findMany"> | Null>
    stepCompletions<T extends WorkflowStep$stepCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStep$stepCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StepCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStep model
   */ 
  interface WorkflowStepFieldRefs {
    readonly id: FieldRef<"WorkflowStep", 'String'>
    readonly workflowTemplateId: FieldRef<"WorkflowStep", 'String'>
    readonly stepOrder: FieldRef<"WorkflowStep", 'Int'>
    readonly code: FieldRef<"WorkflowStep", 'String'>
    readonly label: FieldRef<"WorkflowStep", 'String'>
    readonly description: FieldRef<"WorkflowStep", 'String'>
    readonly requiredFields: FieldRef<"WorkflowStep", 'Json'>
    readonly requiredDocuments: FieldRef<"WorkflowStep", 'Json'>
    readonly requiresApproval: FieldRef<"WorkflowStep", 'Boolean'>
    readonly approvalRoles: FieldRef<"WorkflowStep", 'Json'>
    readonly triggerAction: FieldRef<"WorkflowStep", 'String'>
    readonly icon: FieldRef<"WorkflowStep", 'String'>
    readonly color: FieldRef<"WorkflowStep", 'String'>
    readonly allowedRoles: FieldRef<"WorkflowStep", 'Json'>
    readonly createdAt: FieldRef<"WorkflowStep", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStep findUnique
   */
  export type WorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findUniqueOrThrow
   */
  export type WorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findFirst
   */
  export type WorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findFirstOrThrow
   */
  export type WorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findMany
   */
  export type WorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowSteps to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep create
   */
  export type WorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStep.
     */
    data: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
  }

  /**
   * WorkflowStep createMany
   */
  export type WorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStep update
   */
  export type WorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStep.
     */
    data: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStep to update.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep updateMany
   */
  export type WorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowSteps.
     */
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowSteps to update
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep upsert
   */
  export type WorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStep to update in case it exists.
     */
    where: WorkflowStepWhereUniqueInput
    /**
     * In case the WorkflowStep found by the `where` argument doesn't exist, create a new WorkflowStep with this data.
     */
    create: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
    /**
     * In case the WorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
  }

  /**
   * WorkflowStep delete
   */
  export type WorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStep to delete.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep deleteMany
   */
  export type WorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowSteps to delete
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep.engagements
   */
  export type WorkflowStep$engagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Engagement
     */
    select?: EngagementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementInclude<ExtArgs> | null
    where?: EngagementWhereInput
    orderBy?: EngagementOrderByWithRelationInput | EngagementOrderByWithRelationInput[]
    cursor?: EngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementScalarFieldEnum | EngagementScalarFieldEnum[]
  }

  /**
   * WorkflowStep.stepCompletions
   */
  export type WorkflowStep$stepCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StepCompletion
     */
    select?: StepCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StepCompletionInclude<ExtArgs> | null
    where?: StepCompletionWhereInput
    orderBy?: StepCompletionOrderByWithRelationInput | StepCompletionOrderByWithRelationInput[]
    cursor?: StepCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StepCompletionScalarFieldEnum | StepCompletionScalarFieldEnum[]
  }

  /**
   * WorkflowStep without action
   */
  export type WorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role: 'role',
    status: 'status',
    emailVerified: 'emailVerified',
    emailVerifiedAt: 'emailVerifiedAt',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    lastLoginAt: 'lastLoginAt',
    companyId: 'companyId',
    businessUnitId: 'businessUnitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BanqueScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    codeSwift: 'codeSwift',
    codeGuichet: 'codeGuichet',
    adresse: 'adresse',
    contactInfo: 'contactInfo',
    establishment: 'establishment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BanqueScalarFieldEnum = (typeof BanqueScalarFieldEnum)[keyof typeof BanqueScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    accountNumber: 'accountNumber',
    keyAccount: 'keyAccount',
    currency: 'currency',
    rib: 'rib',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy',
    banqueId: 'banqueId'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const LigneCreditScalarFieldEnum: {
    id: 'id',
    no: 'no',
    description: 'description',
    banqueId: 'banqueId',
    autorisationNo: 'autorisationNo',
    bankAccountNo: 'bankAccountNo',
    montantPlafond: 'montantPlafond',
    montantDevise: 'montantDevise',
    taux: 'taux',
    commitmentCommissionRate: 'commitmentCommissionRate',
    estimatedOutstanding: 'estimatedOutstanding',
    consumption: 'consumption',
    outstanding: 'outstanding',
    startDate: 'startDate',
    expiryDate: 'expiryDate',
    renewalDate: 'renewalDate',
    statut: 'statut',
    responsibilityCenter: 'responsibilityCenter',
    seuilAvanceSurStock: 'seuilAvanceSurStock',
    seuilAvanceSurFacture: 'seuilAvanceSurFacture',
    seuilEscompte: 'seuilEscompte',
    seuilLC: 'seuilLC',
    seuilObligtDouane: 'seuilObligtDouane',
    seuilCautionAdmin: 'seuilCautionAdmin',
    seuilDcvrtMobile: 'seuilDcvrtMobile',
    seuilTrsfrLibre: 'seuilTrsfrLibre',
    seuilLeasing: 'seuilLeasing',
    seuilCMT: 'seuilCMT',
    seuilFraisMission: 'seuilFraisMission',
    seuilLCAS: 'seuilLCAS',
    avanceSurStock: 'avanceSurStock',
    avanceFacture: 'avanceFacture',
    escompte: 'escompte',
    obligatDouane: 'obligatDouane',
    cautionAdmin: 'cautionAdmin',
    dcvrtMobile: 'dcvrtMobile',
    trsfrLibre: 'trsfrLibre',
    leasing: 'leasing',
    CMT: 'CMT',
    fraisMission: 'fraisMission',
    LCAS: 'LCAS',
    faciliteCaissier: 'faciliteCaissier',
    typeFinancement: 'typeFinancement',
    maxConsumptionTolerance: 'maxConsumptionTolerance',
    minConsumptionTolerance: 'minConsumptionTolerance',
    noSeries: 'noSeries',
    refinancing: 'refinancing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LigneCreditScalarFieldEnum = (typeof LigneCreditScalarFieldEnum)[keyof typeof LigneCreditScalarFieldEnum]


  export const GarantieScalarFieldEnum: {
    id: 'id',
    ligneCreditId: 'ligneCreditId',
    type: 'type',
    montant: 'montant',
    dateExpiration: 'dateExpiration',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type GarantieScalarFieldEnum = (typeof GarantieScalarFieldEnum)[keyof typeof GarantieScalarFieldEnum]


  export const EngagementScalarFieldEnum: {
    id: 'id',
    ligneCreditId: 'ligneCreditId',
    typeFinancement: 'typeFinancement',
    montant: 'montant',
    devise: 'devise',
    dateEngagement: 'dateEngagement',
    dateEcheance: 'dateEcheance',
    statut: 'statut',
    referenceDossier: 'referenceDossier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workflowTemplateId: 'workflowTemplateId',
    workflowStepId: 'workflowStepId',
    parentEngagementId: 'parentEngagementId'
  };

  export type EngagementScalarFieldEnum = (typeof EngagementScalarFieldEnum)[keyof typeof EngagementScalarFieldEnum]


  export const StepCompletionScalarFieldEnum: {
    id: 'id',
    engagementId: 'engagementId',
    workflowStepId: 'workflowStepId',
    fieldData: 'fieldData',
    documents: 'documents',
    completedBy: 'completedBy',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    notes: 'notes'
  };

  export type StepCompletionScalarFieldEnum = (typeof StepCompletionScalarFieldEnum)[keyof typeof StepCompletionScalarFieldEnum]


  export const SwiftMessageScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    referenceDossier: 'referenceDossier',
    dateGeneration: 'dateGeneration',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SwiftMessageScalarFieldEnum = (typeof SwiftMessageScalarFieldEnum)[keyof typeof SwiftMessageScalarFieldEnum]


  export const DocumentImportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    nomFichier: 'nomFichier',
    cheminFichier: 'cheminFichier',
    dateUpload: 'dateUpload',
    metadata: 'metadata',
    referenceDossier: 'referenceDossier',
    createdAt: 'createdAt'
  };

  export type DocumentImportScalarFieldEnum = (typeof DocumentImportScalarFieldEnum)[keyof typeof DocumentImportScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    address: 'address',
    contactInfo: 'contactInfo',
    parentCompanyId: 'parentCompanyId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const BusinessUnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    companyId: 'companyId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessUnitScalarFieldEnum = (typeof BusinessUnitScalarFieldEnum)[keyof typeof BusinessUnitScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    contactInfo: 'contactInfo',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const CompanySupplierScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    supplierId: 'supplierId',
    createdAt: 'createdAt'
  };

  export type CompanySupplierScalarFieldEnum = (typeof CompanySupplierScalarFieldEnum)[keyof typeof CompanySupplierScalarFieldEnum]


  export const BusinessUnitSupplierScalarFieldEnum: {
    id: 'id',
    businessUnitId: 'businessUnitId',
    supplierId: 'supplierId',
    createdAt: 'createdAt'
  };

  export type BusinessUnitSupplierScalarFieldEnum = (typeof BusinessUnitSupplierScalarFieldEnum)[keyof typeof BusinessUnitSupplierScalarFieldEnum]


  export const CompanyBanqueScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    banqueId: 'banqueId',
    createdAt: 'createdAt'
  };

  export type CompanyBanqueScalarFieldEnum = (typeof CompanyBanqueScalarFieldEnum)[keyof typeof CompanyBanqueScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    resource: 'resource',
    action: 'action',
    scope: 'scope',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    companyId: 'companyId',
    businessUnitId: 'businessUnitId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    userId: 'userId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const WorkflowTemplateScalarFieldEnum: {
    id: 'id',
    code: 'code',
    label: 'label',
    description: 'description',
    icon: 'icon',
    color: 'color',
    displayOrder: 'displayOrder',
    formSchema: 'formSchema',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowTemplateScalarFieldEnum = (typeof WorkflowTemplateScalarFieldEnum)[keyof typeof WorkflowTemplateScalarFieldEnum]


  export const WorkflowStepScalarFieldEnum: {
    id: 'id',
    workflowTemplateId: 'workflowTemplateId',
    stepOrder: 'stepOrder',
    code: 'code',
    label: 'label',
    description: 'description',
    requiredFields: 'requiredFields',
    requiredDocuments: 'requiredDocuments',
    requiresApproval: 'requiresApproval',
    approvalRoles: 'approvalRoles',
    triggerAction: 'triggerAction',
    icon: 'icon',
    color: 'color',
    allowedRoles: 'allowedRoles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowStepScalarFieldEnum = (typeof WorkflowStepScalarFieldEnum)[keyof typeof WorkflowStepScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    phone?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    failedLoginAttempts?: IntFilter<"user"> | number
    lockedUntil?: DateTimeNullableFilter<"user"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"user"> | Date | string | null
    companyId?: StringNullableFilter<"user"> | string | null
    businessUnitId?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    businessUnit?: XOR<BusinessUnitNullableRelationFilter, BusinessUnitWhereInput> | null
    userRoles?: UserRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    businessUnitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    businessUnit?: BusinessUnitOrderByWithRelationInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    stepCompletions?: StepCompletionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    phone?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    failedLoginAttempts?: IntFilter<"user"> | number
    lockedUntil?: DateTimeNullableFilter<"user"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"user"> | Date | string | null
    companyId?: StringNullableFilter<"user"> | string | null
    businessUnitId?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    businessUnit?: XOR<BusinessUnitNullableRelationFilter, BusinessUnitWhereInput> | null
    userRoles?: UserRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    businessUnitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    phone?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringWithAggregatesFilter<"user"> | string
    role?: StringWithAggregatesFilter<"user"> | string
    status?: StringWithAggregatesFilter<"user"> | string
    emailVerified?: BoolWithAggregatesFilter<"user"> | boolean
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"user"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    companyId?: StringNullableWithAggregatesFilter<"user"> | string | null
    businessUnitId?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type BanqueWhereInput = {
    AND?: BanqueWhereInput | BanqueWhereInput[]
    OR?: BanqueWhereInput[]
    NOT?: BanqueWhereInput | BanqueWhereInput[]
    id?: StringFilter<"Banque"> | string
    nom?: StringFilter<"Banque"> | string
    codeSwift?: StringFilter<"Banque"> | string
    codeGuichet?: StringNullableFilter<"Banque"> | string | null
    adresse?: StringFilter<"Banque"> | string
    contactInfo?: StringNullableFilter<"Banque"> | string | null
    establishment?: StringNullableFilter<"Banque"> | string | null
    createdAt?: DateTimeFilter<"Banque"> | Date | string
    updatedAt?: DateTimeFilter<"Banque"> | Date | string
    lignesCredit?: LigneCreditListRelationFilter
    companies?: CompanyBanqueListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
  }

  export type BanqueOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    codeSwift?: SortOrder
    codeGuichet?: SortOrderInput | SortOrder
    adresse?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    establishment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lignesCredit?: LigneCreditOrderByRelationAggregateInput
    companies?: CompanyBanqueOrderByRelationAggregateInput
    bankAccounts?: BankAccountOrderByRelationAggregateInput
  }

  export type BanqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codeSwift?: string
    AND?: BanqueWhereInput | BanqueWhereInput[]
    OR?: BanqueWhereInput[]
    NOT?: BanqueWhereInput | BanqueWhereInput[]
    nom?: StringFilter<"Banque"> | string
    codeGuichet?: StringNullableFilter<"Banque"> | string | null
    adresse?: StringFilter<"Banque"> | string
    contactInfo?: StringNullableFilter<"Banque"> | string | null
    establishment?: StringNullableFilter<"Banque"> | string | null
    createdAt?: DateTimeFilter<"Banque"> | Date | string
    updatedAt?: DateTimeFilter<"Banque"> | Date | string
    lignesCredit?: LigneCreditListRelationFilter
    companies?: CompanyBanqueListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
  }, "id" | "codeSwift">

  export type BanqueOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    codeSwift?: SortOrder
    codeGuichet?: SortOrderInput | SortOrder
    adresse?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    establishment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BanqueCountOrderByAggregateInput
    _max?: BanqueMaxOrderByAggregateInput
    _min?: BanqueMinOrderByAggregateInput
  }

  export type BanqueScalarWhereWithAggregatesInput = {
    AND?: BanqueScalarWhereWithAggregatesInput | BanqueScalarWhereWithAggregatesInput[]
    OR?: BanqueScalarWhereWithAggregatesInput[]
    NOT?: BanqueScalarWhereWithAggregatesInput | BanqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banque"> | string
    nom?: StringWithAggregatesFilter<"Banque"> | string
    codeSwift?: StringWithAggregatesFilter<"Banque"> | string
    codeGuichet?: StringNullableWithAggregatesFilter<"Banque"> | string | null
    adresse?: StringWithAggregatesFilter<"Banque"> | string
    contactInfo?: StringNullableWithAggregatesFilter<"Banque"> | string | null
    establishment?: StringNullableWithAggregatesFilter<"Banque"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Banque"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banque"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    accountNumber?: StringFilter<"BankAccount"> | string
    keyAccount?: StringFilter<"BankAccount"> | string
    currency?: StringFilter<"BankAccount"> | string
    rib?: StringNullableFilter<"BankAccount"> | string | null
    isActive?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    createdBy?: StringFilter<"BankAccount"> | string
    updatedBy?: StringFilter<"BankAccount"> | string
    deletedBy?: StringNullableFilter<"BankAccount"> | string | null
    banqueId?: StringFilter<"BankAccount"> | string
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    keyAccount?: SortOrder
    currency?: SortOrder
    rib?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    banqueId?: SortOrder
    banque?: BanqueOrderByWithRelationInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    accountNumber?: StringFilter<"BankAccount"> | string
    keyAccount?: StringFilter<"BankAccount"> | string
    currency?: StringFilter<"BankAccount"> | string
    rib?: StringNullableFilter<"BankAccount"> | string | null
    isActive?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    createdBy?: StringFilter<"BankAccount"> | string
    updatedBy?: StringFilter<"BankAccount"> | string
    deletedBy?: StringNullableFilter<"BankAccount"> | string | null
    banqueId?: StringFilter<"BankAccount"> | string
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
  }, "id">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    keyAccount?: SortOrder
    currency?: SortOrder
    rib?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    banqueId?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    accountNumber?: StringWithAggregatesFilter<"BankAccount"> | string
    keyAccount?: StringWithAggregatesFilter<"BankAccount"> | string
    currency?: StringWithAggregatesFilter<"BankAccount"> | string
    rib?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BankAccount"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"BankAccount"> | string
    updatedBy?: StringWithAggregatesFilter<"BankAccount"> | string
    deletedBy?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    banqueId?: StringWithAggregatesFilter<"BankAccount"> | string
  }

  export type LigneCreditWhereInput = {
    AND?: LigneCreditWhereInput | LigneCreditWhereInput[]
    OR?: LigneCreditWhereInput[]
    NOT?: LigneCreditWhereInput | LigneCreditWhereInput[]
    id?: StringFilter<"LigneCredit"> | string
    no?: StringFilter<"LigneCredit"> | string
    description?: StringNullableFilter<"LigneCredit"> | string | null
    banqueId?: StringFilter<"LigneCredit"> | string
    autorisationNo?: StringFilter<"LigneCredit"> | string
    bankAccountNo?: StringFilter<"LigneCredit"> | string
    montantPlafond?: FloatFilter<"LigneCredit"> | number
    montantDevise?: StringFilter<"LigneCredit"> | string
    taux?: FloatFilter<"LigneCredit"> | number
    commitmentCommissionRate?: FloatFilter<"LigneCredit"> | number
    estimatedOutstanding?: FloatFilter<"LigneCredit"> | number
    consumption?: FloatFilter<"LigneCredit"> | number
    outstanding?: FloatFilter<"LigneCredit"> | number
    startDate?: DateTimeFilter<"LigneCredit"> | Date | string
    expiryDate?: DateTimeFilter<"LigneCredit"> | Date | string
    renewalDate?: DateTimeNullableFilter<"LigneCredit"> | Date | string | null
    statut?: StringFilter<"LigneCredit"> | string
    responsibilityCenter?: StringNullableFilter<"LigneCredit"> | string | null
    seuilAvanceSurStock?: FloatFilter<"LigneCredit"> | number
    seuilAvanceSurFacture?: FloatFilter<"LigneCredit"> | number
    seuilEscompte?: FloatFilter<"LigneCredit"> | number
    seuilLC?: FloatFilter<"LigneCredit"> | number
    seuilObligtDouane?: FloatFilter<"LigneCredit"> | number
    seuilCautionAdmin?: FloatFilter<"LigneCredit"> | number
    seuilDcvrtMobile?: FloatFilter<"LigneCredit"> | number
    seuilTrsfrLibre?: FloatFilter<"LigneCredit"> | number
    seuilLeasing?: FloatFilter<"LigneCredit"> | number
    seuilCMT?: FloatFilter<"LigneCredit"> | number
    seuilFraisMission?: FloatFilter<"LigneCredit"> | number
    seuilLCAS?: FloatFilter<"LigneCredit"> | number
    avanceSurStock?: FloatFilter<"LigneCredit"> | number
    avanceFacture?: FloatFilter<"LigneCredit"> | number
    escompte?: FloatFilter<"LigneCredit"> | number
    obligatDouane?: FloatFilter<"LigneCredit"> | number
    cautionAdmin?: FloatFilter<"LigneCredit"> | number
    dcvrtMobile?: FloatFilter<"LigneCredit"> | number
    trsfrLibre?: FloatFilter<"LigneCredit"> | number
    leasing?: FloatFilter<"LigneCredit"> | number
    CMT?: FloatFilter<"LigneCredit"> | number
    fraisMission?: FloatFilter<"LigneCredit"> | number
    LCAS?: FloatFilter<"LigneCredit"> | number
    faciliteCaissier?: FloatFilter<"LigneCredit"> | number
    typeFinancement?: StringFilter<"LigneCredit"> | string
    maxConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    minConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    noSeries?: StringFilter<"LigneCredit"> | string
    refinancing?: FloatFilter<"LigneCredit"> | number
    createdAt?: DateTimeFilter<"LigneCredit"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCredit"> | Date | string
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
    garanties?: GarantieListRelationFilter
    engagements?: EngagementListRelationFilter
  }

  export type LigneCreditOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    description?: SortOrderInput | SortOrder
    banqueId?: SortOrder
    autorisationNo?: SortOrder
    bankAccountNo?: SortOrder
    montantPlafond?: SortOrder
    montantDevise?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrderInput | SortOrder
    statut?: SortOrder
    responsibilityCenter?: SortOrderInput | SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    typeFinancement?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    noSeries?: SortOrder
    refinancing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banque?: BanqueOrderByWithRelationInput
    garanties?: GarantieOrderByRelationAggregateInput
    engagements?: EngagementOrderByRelationAggregateInput
  }

  export type LigneCreditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    no?: string
    AND?: LigneCreditWhereInput | LigneCreditWhereInput[]
    OR?: LigneCreditWhereInput[]
    NOT?: LigneCreditWhereInput | LigneCreditWhereInput[]
    description?: StringNullableFilter<"LigneCredit"> | string | null
    banqueId?: StringFilter<"LigneCredit"> | string
    autorisationNo?: StringFilter<"LigneCredit"> | string
    bankAccountNo?: StringFilter<"LigneCredit"> | string
    montantPlafond?: FloatFilter<"LigneCredit"> | number
    montantDevise?: StringFilter<"LigneCredit"> | string
    taux?: FloatFilter<"LigneCredit"> | number
    commitmentCommissionRate?: FloatFilter<"LigneCredit"> | number
    estimatedOutstanding?: FloatFilter<"LigneCredit"> | number
    consumption?: FloatFilter<"LigneCredit"> | number
    outstanding?: FloatFilter<"LigneCredit"> | number
    startDate?: DateTimeFilter<"LigneCredit"> | Date | string
    expiryDate?: DateTimeFilter<"LigneCredit"> | Date | string
    renewalDate?: DateTimeNullableFilter<"LigneCredit"> | Date | string | null
    statut?: StringFilter<"LigneCredit"> | string
    responsibilityCenter?: StringNullableFilter<"LigneCredit"> | string | null
    seuilAvanceSurStock?: FloatFilter<"LigneCredit"> | number
    seuilAvanceSurFacture?: FloatFilter<"LigneCredit"> | number
    seuilEscompte?: FloatFilter<"LigneCredit"> | number
    seuilLC?: FloatFilter<"LigneCredit"> | number
    seuilObligtDouane?: FloatFilter<"LigneCredit"> | number
    seuilCautionAdmin?: FloatFilter<"LigneCredit"> | number
    seuilDcvrtMobile?: FloatFilter<"LigneCredit"> | number
    seuilTrsfrLibre?: FloatFilter<"LigneCredit"> | number
    seuilLeasing?: FloatFilter<"LigneCredit"> | number
    seuilCMT?: FloatFilter<"LigneCredit"> | number
    seuilFraisMission?: FloatFilter<"LigneCredit"> | number
    seuilLCAS?: FloatFilter<"LigneCredit"> | number
    avanceSurStock?: FloatFilter<"LigneCredit"> | number
    avanceFacture?: FloatFilter<"LigneCredit"> | number
    escompte?: FloatFilter<"LigneCredit"> | number
    obligatDouane?: FloatFilter<"LigneCredit"> | number
    cautionAdmin?: FloatFilter<"LigneCredit"> | number
    dcvrtMobile?: FloatFilter<"LigneCredit"> | number
    trsfrLibre?: FloatFilter<"LigneCredit"> | number
    leasing?: FloatFilter<"LigneCredit"> | number
    CMT?: FloatFilter<"LigneCredit"> | number
    fraisMission?: FloatFilter<"LigneCredit"> | number
    LCAS?: FloatFilter<"LigneCredit"> | number
    faciliteCaissier?: FloatFilter<"LigneCredit"> | number
    typeFinancement?: StringFilter<"LigneCredit"> | string
    maxConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    minConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    noSeries?: StringFilter<"LigneCredit"> | string
    refinancing?: FloatFilter<"LigneCredit"> | number
    createdAt?: DateTimeFilter<"LigneCredit"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCredit"> | Date | string
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
    garanties?: GarantieListRelationFilter
    engagements?: EngagementListRelationFilter
  }, "id" | "no">

  export type LigneCreditOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    description?: SortOrderInput | SortOrder
    banqueId?: SortOrder
    autorisationNo?: SortOrder
    bankAccountNo?: SortOrder
    montantPlafond?: SortOrder
    montantDevise?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrderInput | SortOrder
    statut?: SortOrder
    responsibilityCenter?: SortOrderInput | SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    typeFinancement?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    noSeries?: SortOrder
    refinancing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LigneCreditCountOrderByAggregateInput
    _avg?: LigneCreditAvgOrderByAggregateInput
    _max?: LigneCreditMaxOrderByAggregateInput
    _min?: LigneCreditMinOrderByAggregateInput
    _sum?: LigneCreditSumOrderByAggregateInput
  }

  export type LigneCreditScalarWhereWithAggregatesInput = {
    AND?: LigneCreditScalarWhereWithAggregatesInput | LigneCreditScalarWhereWithAggregatesInput[]
    OR?: LigneCreditScalarWhereWithAggregatesInput[]
    NOT?: LigneCreditScalarWhereWithAggregatesInput | LigneCreditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneCredit"> | string
    no?: StringWithAggregatesFilter<"LigneCredit"> | string
    description?: StringNullableWithAggregatesFilter<"LigneCredit"> | string | null
    banqueId?: StringWithAggregatesFilter<"LigneCredit"> | string
    autorisationNo?: StringWithAggregatesFilter<"LigneCredit"> | string
    bankAccountNo?: StringWithAggregatesFilter<"LigneCredit"> | string
    montantPlafond?: FloatWithAggregatesFilter<"LigneCredit"> | number
    montantDevise?: StringWithAggregatesFilter<"LigneCredit"> | string
    taux?: FloatWithAggregatesFilter<"LigneCredit"> | number
    commitmentCommissionRate?: FloatWithAggregatesFilter<"LigneCredit"> | number
    estimatedOutstanding?: FloatWithAggregatesFilter<"LigneCredit"> | number
    consumption?: FloatWithAggregatesFilter<"LigneCredit"> | number
    outstanding?: FloatWithAggregatesFilter<"LigneCredit"> | number
    startDate?: DateTimeWithAggregatesFilter<"LigneCredit"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"LigneCredit"> | Date | string
    renewalDate?: DateTimeNullableWithAggregatesFilter<"LigneCredit"> | Date | string | null
    statut?: StringWithAggregatesFilter<"LigneCredit"> | string
    responsibilityCenter?: StringNullableWithAggregatesFilter<"LigneCredit"> | string | null
    seuilAvanceSurStock?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilAvanceSurFacture?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilEscompte?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilLC?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilObligtDouane?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilCautionAdmin?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilDcvrtMobile?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilTrsfrLibre?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilLeasing?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilCMT?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilFraisMission?: FloatWithAggregatesFilter<"LigneCredit"> | number
    seuilLCAS?: FloatWithAggregatesFilter<"LigneCredit"> | number
    avanceSurStock?: FloatWithAggregatesFilter<"LigneCredit"> | number
    avanceFacture?: FloatWithAggregatesFilter<"LigneCredit"> | number
    escompte?: FloatWithAggregatesFilter<"LigneCredit"> | number
    obligatDouane?: FloatWithAggregatesFilter<"LigneCredit"> | number
    cautionAdmin?: FloatWithAggregatesFilter<"LigneCredit"> | number
    dcvrtMobile?: FloatWithAggregatesFilter<"LigneCredit"> | number
    trsfrLibre?: FloatWithAggregatesFilter<"LigneCredit"> | number
    leasing?: FloatWithAggregatesFilter<"LigneCredit"> | number
    CMT?: FloatWithAggregatesFilter<"LigneCredit"> | number
    fraisMission?: FloatWithAggregatesFilter<"LigneCredit"> | number
    LCAS?: FloatWithAggregatesFilter<"LigneCredit"> | number
    faciliteCaissier?: FloatWithAggregatesFilter<"LigneCredit"> | number
    typeFinancement?: StringWithAggregatesFilter<"LigneCredit"> | string
    maxConsumptionTolerance?: FloatWithAggregatesFilter<"LigneCredit"> | number
    minConsumptionTolerance?: FloatWithAggregatesFilter<"LigneCredit"> | number
    noSeries?: StringWithAggregatesFilter<"LigneCredit"> | string
    refinancing?: FloatWithAggregatesFilter<"LigneCredit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LigneCredit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneCredit"> | Date | string
  }

  export type GarantieWhereInput = {
    AND?: GarantieWhereInput | GarantieWhereInput[]
    OR?: GarantieWhereInput[]
    NOT?: GarantieWhereInput | GarantieWhereInput[]
    id?: StringFilter<"Garantie"> | string
    ligneCreditId?: StringFilter<"Garantie"> | string
    type?: StringFilter<"Garantie"> | string
    montant?: FloatFilter<"Garantie"> | number
    dateExpiration?: DateTimeFilter<"Garantie"> | Date | string
    description?: StringNullableFilter<"Garantie"> | string | null
    createdAt?: DateTimeFilter<"Garantie"> | Date | string
    ligneCredit?: XOR<LigneCreditRelationFilter, LigneCreditWhereInput>
  }

  export type GarantieOrderByWithRelationInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateExpiration?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ligneCredit?: LigneCreditOrderByWithRelationInput
  }

  export type GarantieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GarantieWhereInput | GarantieWhereInput[]
    OR?: GarantieWhereInput[]
    NOT?: GarantieWhereInput | GarantieWhereInput[]
    ligneCreditId?: StringFilter<"Garantie"> | string
    type?: StringFilter<"Garantie"> | string
    montant?: FloatFilter<"Garantie"> | number
    dateExpiration?: DateTimeFilter<"Garantie"> | Date | string
    description?: StringNullableFilter<"Garantie"> | string | null
    createdAt?: DateTimeFilter<"Garantie"> | Date | string
    ligneCredit?: XOR<LigneCreditRelationFilter, LigneCreditWhereInput>
  }, "id">

  export type GarantieOrderByWithAggregationInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateExpiration?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GarantieCountOrderByAggregateInput
    _avg?: GarantieAvgOrderByAggregateInput
    _max?: GarantieMaxOrderByAggregateInput
    _min?: GarantieMinOrderByAggregateInput
    _sum?: GarantieSumOrderByAggregateInput
  }

  export type GarantieScalarWhereWithAggregatesInput = {
    AND?: GarantieScalarWhereWithAggregatesInput | GarantieScalarWhereWithAggregatesInput[]
    OR?: GarantieScalarWhereWithAggregatesInput[]
    NOT?: GarantieScalarWhereWithAggregatesInput | GarantieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Garantie"> | string
    ligneCreditId?: StringWithAggregatesFilter<"Garantie"> | string
    type?: StringWithAggregatesFilter<"Garantie"> | string
    montant?: FloatWithAggregatesFilter<"Garantie"> | number
    dateExpiration?: DateTimeWithAggregatesFilter<"Garantie"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Garantie"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Garantie"> | Date | string
  }

  export type EngagementWhereInput = {
    AND?: EngagementWhereInput | EngagementWhereInput[]
    OR?: EngagementWhereInput[]
    NOT?: EngagementWhereInput | EngagementWhereInput[]
    id?: StringFilter<"Engagement"> | string
    ligneCreditId?: StringNullableFilter<"Engagement"> | string | null
    typeFinancement?: StringFilter<"Engagement"> | string
    montant?: FloatNullableFilter<"Engagement"> | number | null
    devise?: StringNullableFilter<"Engagement"> | string | null
    dateEngagement?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    dateEcheance?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    statut?: StringFilter<"Engagement"> | string
    referenceDossier?: StringFilter<"Engagement"> | string
    createdAt?: DateTimeFilter<"Engagement"> | Date | string
    updatedAt?: DateTimeFilter<"Engagement"> | Date | string
    workflowTemplateId?: StringNullableFilter<"Engagement"> | string | null
    workflowStepId?: StringNullableFilter<"Engagement"> | string | null
    parentEngagementId?: StringNullableFilter<"Engagement"> | string | null
    ligneCredit?: XOR<LigneCreditNullableRelationFilter, LigneCreditWhereInput> | null
    workflowTemplate?: XOR<WorkflowTemplateNullableRelationFilter, WorkflowTemplateWhereInput> | null
    workflowStep?: XOR<WorkflowStepNullableRelationFilter, WorkflowStepWhereInput> | null
    parentEngagement?: XOR<EngagementNullableRelationFilter, EngagementWhereInput> | null
    childEngagements?: EngagementListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }

  export type EngagementOrderByWithRelationInput = {
    id?: SortOrder
    ligneCreditId?: SortOrderInput | SortOrder
    typeFinancement?: SortOrder
    montant?: SortOrderInput | SortOrder
    devise?: SortOrderInput | SortOrder
    dateEngagement?: SortOrderInput | SortOrder
    dateEcheance?: SortOrderInput | SortOrder
    statut?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowTemplateId?: SortOrderInput | SortOrder
    workflowStepId?: SortOrderInput | SortOrder
    parentEngagementId?: SortOrderInput | SortOrder
    ligneCredit?: LigneCreditOrderByWithRelationInput
    workflowTemplate?: WorkflowTemplateOrderByWithRelationInput
    workflowStep?: WorkflowStepOrderByWithRelationInput
    parentEngagement?: EngagementOrderByWithRelationInput
    childEngagements?: EngagementOrderByRelationAggregateInput
    stepCompletions?: StepCompletionOrderByRelationAggregateInput
  }

  export type EngagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EngagementWhereInput | EngagementWhereInput[]
    OR?: EngagementWhereInput[]
    NOT?: EngagementWhereInput | EngagementWhereInput[]
    ligneCreditId?: StringNullableFilter<"Engagement"> | string | null
    typeFinancement?: StringFilter<"Engagement"> | string
    montant?: FloatNullableFilter<"Engagement"> | number | null
    devise?: StringNullableFilter<"Engagement"> | string | null
    dateEngagement?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    dateEcheance?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    statut?: StringFilter<"Engagement"> | string
    referenceDossier?: StringFilter<"Engagement"> | string
    createdAt?: DateTimeFilter<"Engagement"> | Date | string
    updatedAt?: DateTimeFilter<"Engagement"> | Date | string
    workflowTemplateId?: StringNullableFilter<"Engagement"> | string | null
    workflowStepId?: StringNullableFilter<"Engagement"> | string | null
    parentEngagementId?: StringNullableFilter<"Engagement"> | string | null
    ligneCredit?: XOR<LigneCreditNullableRelationFilter, LigneCreditWhereInput> | null
    workflowTemplate?: XOR<WorkflowTemplateNullableRelationFilter, WorkflowTemplateWhereInput> | null
    workflowStep?: XOR<WorkflowStepNullableRelationFilter, WorkflowStepWhereInput> | null
    parentEngagement?: XOR<EngagementNullableRelationFilter, EngagementWhereInput> | null
    childEngagements?: EngagementListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }, "id">

  export type EngagementOrderByWithAggregationInput = {
    id?: SortOrder
    ligneCreditId?: SortOrderInput | SortOrder
    typeFinancement?: SortOrder
    montant?: SortOrderInput | SortOrder
    devise?: SortOrderInput | SortOrder
    dateEngagement?: SortOrderInput | SortOrder
    dateEcheance?: SortOrderInput | SortOrder
    statut?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowTemplateId?: SortOrderInput | SortOrder
    workflowStepId?: SortOrderInput | SortOrder
    parentEngagementId?: SortOrderInput | SortOrder
    _count?: EngagementCountOrderByAggregateInput
    _avg?: EngagementAvgOrderByAggregateInput
    _max?: EngagementMaxOrderByAggregateInput
    _min?: EngagementMinOrderByAggregateInput
    _sum?: EngagementSumOrderByAggregateInput
  }

  export type EngagementScalarWhereWithAggregatesInput = {
    AND?: EngagementScalarWhereWithAggregatesInput | EngagementScalarWhereWithAggregatesInput[]
    OR?: EngagementScalarWhereWithAggregatesInput[]
    NOT?: EngagementScalarWhereWithAggregatesInput | EngagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Engagement"> | string
    ligneCreditId?: StringNullableWithAggregatesFilter<"Engagement"> | string | null
    typeFinancement?: StringWithAggregatesFilter<"Engagement"> | string
    montant?: FloatNullableWithAggregatesFilter<"Engagement"> | number | null
    devise?: StringNullableWithAggregatesFilter<"Engagement"> | string | null
    dateEngagement?: DateTimeNullableWithAggregatesFilter<"Engagement"> | Date | string | null
    dateEcheance?: DateTimeNullableWithAggregatesFilter<"Engagement"> | Date | string | null
    statut?: StringWithAggregatesFilter<"Engagement"> | string
    referenceDossier?: StringWithAggregatesFilter<"Engagement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Engagement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Engagement"> | Date | string
    workflowTemplateId?: StringNullableWithAggregatesFilter<"Engagement"> | string | null
    workflowStepId?: StringNullableWithAggregatesFilter<"Engagement"> | string | null
    parentEngagementId?: StringNullableWithAggregatesFilter<"Engagement"> | string | null
  }

  export type StepCompletionWhereInput = {
    AND?: StepCompletionWhereInput | StepCompletionWhereInput[]
    OR?: StepCompletionWhereInput[]
    NOT?: StepCompletionWhereInput | StepCompletionWhereInput[]
    id?: StringFilter<"StepCompletion"> | string
    engagementId?: StringFilter<"StepCompletion"> | string
    workflowStepId?: StringFilter<"StepCompletion"> | string
    fieldData?: StringNullableFilter<"StepCompletion"> | string | null
    documents?: StringNullableFilter<"StepCompletion"> | string | null
    completedBy?: StringNullableFilter<"StepCompletion"> | string | null
    completedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    createdAt?: DateTimeFilter<"StepCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    notes?: StringNullableFilter<"StepCompletion"> | string | null
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput>
    workflowStep?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type StepCompletionOrderByWithRelationInput = {
    id?: SortOrder
    engagementId?: SortOrder
    workflowStepId?: SortOrder
    fieldData?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    engagement?: EngagementOrderByWithRelationInput
    workflowStep?: WorkflowStepOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type StepCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StepCompletionWhereInput | StepCompletionWhereInput[]
    OR?: StepCompletionWhereInput[]
    NOT?: StepCompletionWhereInput | StepCompletionWhereInput[]
    engagementId?: StringFilter<"StepCompletion"> | string
    workflowStepId?: StringFilter<"StepCompletion"> | string
    fieldData?: StringNullableFilter<"StepCompletion"> | string | null
    documents?: StringNullableFilter<"StepCompletion"> | string | null
    completedBy?: StringNullableFilter<"StepCompletion"> | string | null
    completedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    createdAt?: DateTimeFilter<"StepCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    notes?: StringNullableFilter<"StepCompletion"> | string | null
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput>
    workflowStep?: XOR<WorkflowStepRelationFilter, WorkflowStepWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type StepCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    engagementId?: SortOrder
    workflowStepId?: SortOrder
    fieldData?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: StepCompletionCountOrderByAggregateInput
    _max?: StepCompletionMaxOrderByAggregateInput
    _min?: StepCompletionMinOrderByAggregateInput
  }

  export type StepCompletionScalarWhereWithAggregatesInput = {
    AND?: StepCompletionScalarWhereWithAggregatesInput | StepCompletionScalarWhereWithAggregatesInput[]
    OR?: StepCompletionScalarWhereWithAggregatesInput[]
    NOT?: StepCompletionScalarWhereWithAggregatesInput | StepCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StepCompletion"> | string
    engagementId?: StringWithAggregatesFilter<"StepCompletion"> | string
    workflowStepId?: StringWithAggregatesFilter<"StepCompletion"> | string
    fieldData?: StringNullableWithAggregatesFilter<"StepCompletion"> | string | null
    documents?: StringNullableWithAggregatesFilter<"StepCompletion"> | string | null
    completedBy?: StringNullableWithAggregatesFilter<"StepCompletion"> | string | null
    completedAt?: DateTimeWithAggregatesFilter<"StepCompletion"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StepCompletion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StepCompletion"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"StepCompletion"> | string | null
  }

  export type SwiftMessageWhereInput = {
    AND?: SwiftMessageWhereInput | SwiftMessageWhereInput[]
    OR?: SwiftMessageWhereInput[]
    NOT?: SwiftMessageWhereInput | SwiftMessageWhereInput[]
    id?: StringFilter<"SwiftMessage"> | string
    type?: StringFilter<"SwiftMessage"> | string
    content?: StringFilter<"SwiftMessage"> | string
    referenceDossier?: StringFilter<"SwiftMessage"> | string
    dateGeneration?: DateTimeFilter<"SwiftMessage"> | Date | string
    statut?: StringFilter<"SwiftMessage"> | string
    createdAt?: DateTimeFilter<"SwiftMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SwiftMessage"> | Date | string
  }

  export type SwiftMessageOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    referenceDossier?: SortOrder
    dateGeneration?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwiftMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SwiftMessageWhereInput | SwiftMessageWhereInput[]
    OR?: SwiftMessageWhereInput[]
    NOT?: SwiftMessageWhereInput | SwiftMessageWhereInput[]
    type?: StringFilter<"SwiftMessage"> | string
    content?: StringFilter<"SwiftMessage"> | string
    referenceDossier?: StringFilter<"SwiftMessage"> | string
    dateGeneration?: DateTimeFilter<"SwiftMessage"> | Date | string
    statut?: StringFilter<"SwiftMessage"> | string
    createdAt?: DateTimeFilter<"SwiftMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SwiftMessage"> | Date | string
  }, "id">

  export type SwiftMessageOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    referenceDossier?: SortOrder
    dateGeneration?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SwiftMessageCountOrderByAggregateInput
    _max?: SwiftMessageMaxOrderByAggregateInput
    _min?: SwiftMessageMinOrderByAggregateInput
  }

  export type SwiftMessageScalarWhereWithAggregatesInput = {
    AND?: SwiftMessageScalarWhereWithAggregatesInput | SwiftMessageScalarWhereWithAggregatesInput[]
    OR?: SwiftMessageScalarWhereWithAggregatesInput[]
    NOT?: SwiftMessageScalarWhereWithAggregatesInput | SwiftMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SwiftMessage"> | string
    type?: StringWithAggregatesFilter<"SwiftMessage"> | string
    content?: StringWithAggregatesFilter<"SwiftMessage"> | string
    referenceDossier?: StringWithAggregatesFilter<"SwiftMessage"> | string
    dateGeneration?: DateTimeWithAggregatesFilter<"SwiftMessage"> | Date | string
    statut?: StringWithAggregatesFilter<"SwiftMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SwiftMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SwiftMessage"> | Date | string
  }

  export type DocumentImportWhereInput = {
    AND?: DocumentImportWhereInput | DocumentImportWhereInput[]
    OR?: DocumentImportWhereInput[]
    NOT?: DocumentImportWhereInput | DocumentImportWhereInput[]
    id?: StringFilter<"DocumentImport"> | string
    type?: StringFilter<"DocumentImport"> | string
    nomFichier?: StringFilter<"DocumentImport"> | string
    cheminFichier?: StringFilter<"DocumentImport"> | string
    dateUpload?: DateTimeFilter<"DocumentImport"> | Date | string
    metadata?: StringNullableFilter<"DocumentImport"> | string | null
    referenceDossier?: StringFilter<"DocumentImport"> | string
    createdAt?: DateTimeFilter<"DocumentImport"> | Date | string
  }

  export type DocumentImportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    nomFichier?: SortOrder
    cheminFichier?: SortOrder
    dateUpload?: SortOrder
    metadata?: SortOrderInput | SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentImportWhereInput | DocumentImportWhereInput[]
    OR?: DocumentImportWhereInput[]
    NOT?: DocumentImportWhereInput | DocumentImportWhereInput[]
    type?: StringFilter<"DocumentImport"> | string
    nomFichier?: StringFilter<"DocumentImport"> | string
    cheminFichier?: StringFilter<"DocumentImport"> | string
    dateUpload?: DateTimeFilter<"DocumentImport"> | Date | string
    metadata?: StringNullableFilter<"DocumentImport"> | string | null
    referenceDossier?: StringFilter<"DocumentImport"> | string
    createdAt?: DateTimeFilter<"DocumentImport"> | Date | string
  }, "id">

  export type DocumentImportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    nomFichier?: SortOrder
    cheminFichier?: SortOrder
    dateUpload?: SortOrder
    metadata?: SortOrderInput | SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentImportCountOrderByAggregateInput
    _max?: DocumentImportMaxOrderByAggregateInput
    _min?: DocumentImportMinOrderByAggregateInput
  }

  export type DocumentImportScalarWhereWithAggregatesInput = {
    AND?: DocumentImportScalarWhereWithAggregatesInput | DocumentImportScalarWhereWithAggregatesInput[]
    OR?: DocumentImportScalarWhereWithAggregatesInput[]
    NOT?: DocumentImportScalarWhereWithAggregatesInput | DocumentImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentImport"> | string
    type?: StringWithAggregatesFilter<"DocumentImport"> | string
    nomFichier?: StringWithAggregatesFilter<"DocumentImport"> | string
    cheminFichier?: StringWithAggregatesFilter<"DocumentImport"> | string
    dateUpload?: DateTimeWithAggregatesFilter<"DocumentImport"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"DocumentImport"> | string | null
    referenceDossier?: StringWithAggregatesFilter<"DocumentImport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentImport"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    contactInfo?: StringNullableFilter<"Company"> | string | null
    parentCompanyId?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    parentCompany?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    subCompanies?: CompanyListRelationFilter
    businessUnits?: BusinessUnitListRelationFilter
    users?: UserListRelationFilter
    companySuppliers?: CompanySupplierListRelationFilter
    companyBanques?: CompanyBanqueListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    parentCompanyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCompany?: CompanyOrderByWithRelationInput
    subCompanies?: CompanyOrderByRelationAggregateInput
    businessUnits?: BusinessUnitOrderByRelationAggregateInput
    users?: userOrderByRelationAggregateInput
    companySuppliers?: CompanySupplierOrderByRelationAggregateInput
    companyBanques?: CompanyBanqueOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    contactInfo?: StringNullableFilter<"Company"> | string | null
    parentCompanyId?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    parentCompany?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    subCompanies?: CompanyListRelationFilter
    businessUnits?: BusinessUnitListRelationFilter
    users?: UserListRelationFilter
    companySuppliers?: CompanySupplierListRelationFilter
    companyBanques?: CompanyBanqueListRelationFilter
  }, "id" | "code">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    parentCompanyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    code?: StringWithAggregatesFilter<"Company"> | string
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    contactInfo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    parentCompanyId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type BusinessUnitWhereInput = {
    AND?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    OR?: BusinessUnitWhereInput[]
    NOT?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    id?: StringFilter<"BusinessUnit"> | string
    name?: StringFilter<"BusinessUnit"> | string
    code?: StringFilter<"BusinessUnit"> | string
    description?: StringNullableFilter<"BusinessUnit"> | string | null
    companyId?: StringFilter<"BusinessUnit"> | string
    isActive?: BoolFilter<"BusinessUnit"> | boolean
    createdAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    users?: UserListRelationFilter
    businessUnitSuppliers?: BusinessUnitSupplierListRelationFilter
  }

  export type BusinessUnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    users?: userOrderByRelationAggregateInput
    businessUnitSuppliers?: BusinessUnitSupplierOrderByRelationAggregateInput
  }

  export type BusinessUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code_companyId?: BusinessUnitCodeCompanyIdCompoundUniqueInput
    AND?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    OR?: BusinessUnitWhereInput[]
    NOT?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    name?: StringFilter<"BusinessUnit"> | string
    code?: StringFilter<"BusinessUnit"> | string
    description?: StringNullableFilter<"BusinessUnit"> | string | null
    companyId?: StringFilter<"BusinessUnit"> | string
    isActive?: BoolFilter<"BusinessUnit"> | boolean
    createdAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    users?: UserListRelationFilter
    businessUnitSuppliers?: BusinessUnitSupplierListRelationFilter
  }, "id" | "code_companyId">

  export type BusinessUnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    companyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessUnitCountOrderByAggregateInput
    _max?: BusinessUnitMaxOrderByAggregateInput
    _min?: BusinessUnitMinOrderByAggregateInput
  }

  export type BusinessUnitScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitScalarWhereWithAggregatesInput | BusinessUnitScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitScalarWhereWithAggregatesInput | BusinessUnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessUnit"> | string
    name?: StringWithAggregatesFilter<"BusinessUnit"> | string
    code?: StringWithAggregatesFilter<"BusinessUnit"> | string
    description?: StringNullableWithAggregatesFilter<"BusinessUnit"> | string | null
    companyId?: StringWithAggregatesFilter<"BusinessUnit"> | string
    isActive?: BoolWithAggregatesFilter<"BusinessUnit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessUnit"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    code?: StringFilter<"Supplier"> | string
    description?: StringNullableFilter<"Supplier"> | string | null
    contactInfo?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    companySuppliers?: CompanySupplierListRelationFilter
    businessUnitSuppliers?: BusinessUnitSupplierListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companySuppliers?: CompanySupplierOrderByRelationAggregateInput
    businessUnitSuppliers?: BusinessUnitSupplierOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    description?: StringNullableFilter<"Supplier"> | string | null
    contactInfo?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    companySuppliers?: CompanySupplierListRelationFilter
    businessUnitSuppliers?: BusinessUnitSupplierListRelationFilter
  }, "id" | "code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    code?: StringWithAggregatesFilter<"Supplier"> | string
    description?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    contactInfo?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type CompanySupplierWhereInput = {
    AND?: CompanySupplierWhereInput | CompanySupplierWhereInput[]
    OR?: CompanySupplierWhereInput[]
    NOT?: CompanySupplierWhereInput | CompanySupplierWhereInput[]
    id?: StringFilter<"CompanySupplier"> | string
    companyId?: StringFilter<"CompanySupplier"> | string
    supplierId?: StringFilter<"CompanySupplier"> | string
    createdAt?: DateTimeFilter<"CompanySupplier"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }

  export type CompanySupplierOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type CompanySupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_supplierId?: CompanySupplierCompanyIdSupplierIdCompoundUniqueInput
    AND?: CompanySupplierWhereInput | CompanySupplierWhereInput[]
    OR?: CompanySupplierWhereInput[]
    NOT?: CompanySupplierWhereInput | CompanySupplierWhereInput[]
    companyId?: StringFilter<"CompanySupplier"> | string
    supplierId?: StringFilter<"CompanySupplier"> | string
    createdAt?: DateTimeFilter<"CompanySupplier"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }, "id" | "companyId_supplierId">

  export type CompanySupplierOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    _count?: CompanySupplierCountOrderByAggregateInput
    _max?: CompanySupplierMaxOrderByAggregateInput
    _min?: CompanySupplierMinOrderByAggregateInput
  }

  export type CompanySupplierScalarWhereWithAggregatesInput = {
    AND?: CompanySupplierScalarWhereWithAggregatesInput | CompanySupplierScalarWhereWithAggregatesInput[]
    OR?: CompanySupplierScalarWhereWithAggregatesInput[]
    NOT?: CompanySupplierScalarWhereWithAggregatesInput | CompanySupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanySupplier"> | string
    companyId?: StringWithAggregatesFilter<"CompanySupplier"> | string
    supplierId?: StringWithAggregatesFilter<"CompanySupplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanySupplier"> | Date | string
  }

  export type BusinessUnitSupplierWhereInput = {
    AND?: BusinessUnitSupplierWhereInput | BusinessUnitSupplierWhereInput[]
    OR?: BusinessUnitSupplierWhereInput[]
    NOT?: BusinessUnitSupplierWhereInput | BusinessUnitSupplierWhereInput[]
    id?: StringFilter<"BusinessUnitSupplier"> | string
    businessUnitId?: StringFilter<"BusinessUnitSupplier"> | string
    supplierId?: StringFilter<"BusinessUnitSupplier"> | string
    createdAt?: DateTimeFilter<"BusinessUnitSupplier"> | Date | string
    businessUnit?: XOR<BusinessUnitRelationFilter, BusinessUnitWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }

  export type BusinessUnitSupplierOrderByWithRelationInput = {
    id?: SortOrder
    businessUnitId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    businessUnit?: BusinessUnitOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type BusinessUnitSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessUnitId_supplierId?: BusinessUnitSupplierBusinessUnitIdSupplierIdCompoundUniqueInput
    AND?: BusinessUnitSupplierWhereInput | BusinessUnitSupplierWhereInput[]
    OR?: BusinessUnitSupplierWhereInput[]
    NOT?: BusinessUnitSupplierWhereInput | BusinessUnitSupplierWhereInput[]
    businessUnitId?: StringFilter<"BusinessUnitSupplier"> | string
    supplierId?: StringFilter<"BusinessUnitSupplier"> | string
    createdAt?: DateTimeFilter<"BusinessUnitSupplier"> | Date | string
    businessUnit?: XOR<BusinessUnitRelationFilter, BusinessUnitWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }, "id" | "businessUnitId_supplierId">

  export type BusinessUnitSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    businessUnitId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    _count?: BusinessUnitSupplierCountOrderByAggregateInput
    _max?: BusinessUnitSupplierMaxOrderByAggregateInput
    _min?: BusinessUnitSupplierMinOrderByAggregateInput
  }

  export type BusinessUnitSupplierScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitSupplierScalarWhereWithAggregatesInput | BusinessUnitSupplierScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitSupplierScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitSupplierScalarWhereWithAggregatesInput | BusinessUnitSupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessUnitSupplier"> | string
    businessUnitId?: StringWithAggregatesFilter<"BusinessUnitSupplier"> | string
    supplierId?: StringWithAggregatesFilter<"BusinessUnitSupplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessUnitSupplier"> | Date | string
  }

  export type CompanyBanqueWhereInput = {
    AND?: CompanyBanqueWhereInput | CompanyBanqueWhereInput[]
    OR?: CompanyBanqueWhereInput[]
    NOT?: CompanyBanqueWhereInput | CompanyBanqueWhereInput[]
    id?: StringFilter<"CompanyBanque"> | string
    companyId?: StringFilter<"CompanyBanque"> | string
    banqueId?: StringFilter<"CompanyBanque"> | string
    createdAt?: DateTimeFilter<"CompanyBanque"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
  }

  export type CompanyBanqueOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    banqueId?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    banque?: BanqueOrderByWithRelationInput
  }

  export type CompanyBanqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_banqueId?: CompanyBanqueCompanyIdBanqueIdCompoundUniqueInput
    AND?: CompanyBanqueWhereInput | CompanyBanqueWhereInput[]
    OR?: CompanyBanqueWhereInput[]
    NOT?: CompanyBanqueWhereInput | CompanyBanqueWhereInput[]
    companyId?: StringFilter<"CompanyBanque"> | string
    banqueId?: StringFilter<"CompanyBanque"> | string
    createdAt?: DateTimeFilter<"CompanyBanque"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    banque?: XOR<BanqueRelationFilter, BanqueWhereInput>
  }, "id" | "companyId_banqueId">

  export type CompanyBanqueOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    banqueId?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyBanqueCountOrderByAggregateInput
    _max?: CompanyBanqueMaxOrderByAggregateInput
    _min?: CompanyBanqueMinOrderByAggregateInput
  }

  export type CompanyBanqueScalarWhereWithAggregatesInput = {
    AND?: CompanyBanqueScalarWhereWithAggregatesInput | CompanyBanqueScalarWhereWithAggregatesInput[]
    OR?: CompanyBanqueScalarWhereWithAggregatesInput[]
    NOT?: CompanyBanqueScalarWhereWithAggregatesInput | CompanyBanqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyBanque"> | string
    companyId?: StringWithAggregatesFilter<"CompanyBanque"> | string
    banqueId?: StringWithAggregatesFilter<"CompanyBanque"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyBanque"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    code?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name" | "code">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    code?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    scope?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    scope?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrder
    action?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    code?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    scope?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    companyId?: StringNullableFilter<"UserRole"> | string | null
    businessUnitId?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    businessUnitId?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId_companyId_businessUnitId?: UserRoleUserIdRoleIdCompanyIdBusinessUnitIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    companyId?: StringNullableFilter<"UserRole"> | string | null
    businessUnitId?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId_companyId_businessUnitId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    businessUnitId?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    companyId?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    businessUnitId?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedBy?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type WorkflowTemplateWhereInput = {
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    id?: StringFilter<"WorkflowTemplate"> | string
    code?: StringFilter<"WorkflowTemplate"> | string
    label?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    icon?: StringNullableFilter<"WorkflowTemplate"> | string | null
    color?: StringNullableFilter<"WorkflowTemplate"> | string | null
    displayOrder?: IntFilter<"WorkflowTemplate"> | number
    formSchema?: JsonNullableFilter<"WorkflowTemplate">
    isActive?: BoolFilter<"WorkflowTemplate"> | boolean
    createdAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    steps?: WorkflowStepListRelationFilter
    engagements?: EngagementListRelationFilter
  }

  export type WorkflowTemplateOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    formSchema?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    steps?: WorkflowStepOrderByRelationAggregateInput
    engagements?: EngagementOrderByRelationAggregateInput
  }

  export type WorkflowTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    OR?: WorkflowTemplateWhereInput[]
    NOT?: WorkflowTemplateWhereInput | WorkflowTemplateWhereInput[]
    label?: StringFilter<"WorkflowTemplate"> | string
    description?: StringNullableFilter<"WorkflowTemplate"> | string | null
    icon?: StringNullableFilter<"WorkflowTemplate"> | string | null
    color?: StringNullableFilter<"WorkflowTemplate"> | string | null
    displayOrder?: IntFilter<"WorkflowTemplate"> | number
    formSchema?: JsonNullableFilter<"WorkflowTemplate">
    isActive?: BoolFilter<"WorkflowTemplate"> | boolean
    createdAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowTemplate"> | Date | string
    steps?: WorkflowStepListRelationFilter
    engagements?: EngagementListRelationFilter
  }, "id" | "code">

  export type WorkflowTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    formSchema?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowTemplateCountOrderByAggregateInput
    _avg?: WorkflowTemplateAvgOrderByAggregateInput
    _max?: WorkflowTemplateMaxOrderByAggregateInput
    _min?: WorkflowTemplateMinOrderByAggregateInput
    _sum?: WorkflowTemplateSumOrderByAggregateInput
  }

  export type WorkflowTemplateScalarWhereWithAggregatesInput = {
    AND?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    OR?: WorkflowTemplateScalarWhereWithAggregatesInput[]
    NOT?: WorkflowTemplateScalarWhereWithAggregatesInput | WorkflowTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    code?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    label?: StringWithAggregatesFilter<"WorkflowTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    icon?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    color?: StringNullableWithAggregatesFilter<"WorkflowTemplate"> | string | null
    displayOrder?: IntWithAggregatesFilter<"WorkflowTemplate"> | number
    formSchema?: JsonNullableWithAggregatesFilter<"WorkflowTemplate">
    isActive?: BoolWithAggregatesFilter<"WorkflowTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowTemplate"> | Date | string
  }

  export type WorkflowStepWhereInput = {
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowTemplateId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    code?: StringFilter<"WorkflowStep"> | string
    label?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredFields?: JsonNullableFilter<"WorkflowStep">
    requiredDocuments?: JsonNullableFilter<"WorkflowStep">
    requiresApproval?: BoolFilter<"WorkflowStep"> | boolean
    approvalRoles?: JsonNullableFilter<"WorkflowStep">
    triggerAction?: StringNullableFilter<"WorkflowStep"> | string | null
    icon?: StringNullableFilter<"WorkflowStep"> | string | null
    color?: StringNullableFilter<"WorkflowStep"> | string | null
    allowedRoles?: JsonNullableFilter<"WorkflowStep">
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    template?: XOR<WorkflowTemplateRelationFilter, WorkflowTemplateWhereInput>
    engagements?: EngagementListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }

  export type WorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    workflowTemplateId?: SortOrder
    stepOrder?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredFields?: SortOrderInput | SortOrder
    requiredDocuments?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    approvalRoles?: SortOrderInput | SortOrder
    triggerAction?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    allowedRoles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: WorkflowTemplateOrderByWithRelationInput
    engagements?: EngagementOrderByRelationAggregateInput
    stepCompletions?: StepCompletionOrderByRelationAggregateInput
  }

  export type WorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workflowTemplateId_stepOrder?: WorkflowStepWorkflowTemplateIdStepOrderCompoundUniqueInput
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    workflowTemplateId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    code?: StringFilter<"WorkflowStep"> | string
    label?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredFields?: JsonNullableFilter<"WorkflowStep">
    requiredDocuments?: JsonNullableFilter<"WorkflowStep">
    requiresApproval?: BoolFilter<"WorkflowStep"> | boolean
    approvalRoles?: JsonNullableFilter<"WorkflowStep">
    triggerAction?: StringNullableFilter<"WorkflowStep"> | string | null
    icon?: StringNullableFilter<"WorkflowStep"> | string | null
    color?: StringNullableFilter<"WorkflowStep"> | string | null
    allowedRoles?: JsonNullableFilter<"WorkflowStep">
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    template?: XOR<WorkflowTemplateRelationFilter, WorkflowTemplateWhereInput>
    engagements?: EngagementListRelationFilter
    stepCompletions?: StepCompletionListRelationFilter
  }, "id" | "workflowTemplateId_stepOrder">

  export type WorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    workflowTemplateId?: SortOrder
    stepOrder?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredFields?: SortOrderInput | SortOrder
    requiredDocuments?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    approvalRoles?: SortOrderInput | SortOrder
    triggerAction?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    allowedRoles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowStepCountOrderByAggregateInput
    _avg?: WorkflowStepAvgOrderByAggregateInput
    _max?: WorkflowStepMaxOrderByAggregateInput
    _min?: WorkflowStepMinOrderByAggregateInput
    _sum?: WorkflowStepSumOrderByAggregateInput
  }

  export type WorkflowStepScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStep"> | string
    workflowTemplateId?: StringWithAggregatesFilter<"WorkflowStep"> | string
    stepOrder?: IntWithAggregatesFilter<"WorkflowStep"> | number
    code?: StringWithAggregatesFilter<"WorkflowStep"> | string
    label?: StringWithAggregatesFilter<"WorkflowStep"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    requiredFields?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    requiredDocuments?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    requiresApproval?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
    approvalRoles?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    triggerAction?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    icon?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    color?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    allowedRoles?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
  }

  export type userCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    businessUnit?: BusinessUnitCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    businessUnit?: BusinessUnitUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanqueCreateInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditCreateNestedManyWithoutBanqueInput
    companies?: CompanyBanqueCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountCreateNestedManyWithoutBanqueInput
  }

  export type BanqueUncheckedCreateInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditUncheckedCreateNestedManyWithoutBanqueInput
    companies?: CompanyBanqueUncheckedCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutBanqueInput
  }

  export type BanqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUpdateManyWithoutBanqueNestedInput
    companies?: CompanyBanqueUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUncheckedUpdateManyWithoutBanqueNestedInput
    companies?: CompanyBanqueUncheckedUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueCreateManyInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BanqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
    banque: BanqueCreateNestedOneWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
    banqueId: string
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    banque?: BanqueUpdateOneRequiredWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
  }

  export type BankAccountCreateManyInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
    banqueId: string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
  }

  export type LigneCreditCreateInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    banque: BanqueCreateNestedOneWithoutLignesCreditInput
    garanties?: GarantieCreateNestedManyWithoutLigneCreditInput
    engagements?: EngagementCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditUncheckedCreateInput = {
    id?: string
    no: string
    description?: string | null
    banqueId: string
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    garanties?: GarantieUncheckedCreateNestedManyWithoutLigneCreditInput
    engagements?: EngagementUncheckedCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banque?: BanqueUpdateOneRequiredWithoutLignesCreditNestedInput
    garanties?: GarantieUpdateManyWithoutLigneCreditNestedInput
    engagements?: EngagementUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garanties?: GarantieUncheckedUpdateManyWithoutLigneCreditNestedInput
    engagements?: EngagementUncheckedUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditCreateManyInput = {
    id?: string
    no: string
    description?: string | null
    banqueId: string
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GarantieCreateInput = {
    id?: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
    ligneCredit: LigneCreditCreateNestedOneWithoutGarantiesInput
  }

  export type GarantieUncheckedCreateInput = {
    id?: string
    ligneCreditId: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type GarantieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneRequiredWithoutGarantiesNestedInput
  }

  export type GarantieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GarantieCreateManyInput = {
    id?: string
    ligneCreditId: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type GarantieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GarantieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementCreateInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementCreateManyInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
  }

  export type EngagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionCreateInput = {
    id?: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    engagement: EngagementCreateNestedOneWithoutStepCompletionsInput
    workflowStep: WorkflowStepCreateNestedOneWithoutStepCompletionsInput
    user?: userCreateNestedOneWithoutStepCompletionsInput
  }

  export type StepCompletionUncheckedCreateInput = {
    id?: string
    engagementId: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type StepCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: EngagementUpdateOneRequiredWithoutStepCompletionsNestedInput
    workflowStep?: WorkflowStepUpdateOneRequiredWithoutStepCompletionsNestedInput
    user?: userUpdateOneWithoutStepCompletionsNestedInput
  }

  export type StepCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionCreateManyInput = {
    id?: string
    engagementId: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type StepCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SwiftMessageCreateInput = {
    id?: string
    type: string
    content: string
    referenceDossier: string
    dateGeneration: Date | string
    statut: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwiftMessageUncheckedCreateInput = {
    id?: string
    type: string
    content: string
    referenceDossier: string
    dateGeneration: Date | string
    statut: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwiftMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwiftMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwiftMessageCreateManyInput = {
    id?: string
    type: string
    content: string
    referenceDossier: string
    dateGeneration: Date | string
    statut: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwiftMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwiftMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentImportCreateInput = {
    id?: string
    type: string
    nomFichier: string
    cheminFichier: string
    dateUpload: Date | string
    metadata?: string | null
    referenceDossier: string
    createdAt?: Date | string
  }

  export type DocumentImportUncheckedCreateInput = {
    id?: string
    type: string
    nomFichier: string
    cheminFichier: string
    dateUpload: Date | string
    metadata?: string | null
    referenceDossier: string
    createdAt?: Date | string
  }

  export type DocumentImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    cheminFichier?: StringFieldUpdateOperationsInput | string
    dateUpload?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    cheminFichier?: StringFieldUpdateOperationsInput | string
    dateUpload?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentImportCreateManyInput = {
    id?: string
    type: string
    nomFichier: string
    cheminFichier: string
    dateUpload: Date | string
    metadata?: string | null
    referenceDossier: string
    createdAt?: Date | string
  }

  export type DocumentImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    cheminFichier?: StringFieldUpdateOperationsInput | string
    dateUpload?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    cheminFichier?: StringFieldUpdateOperationsInput | string
    dateUpload?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBusinessUnitsInput
    users?: userCreateNestedManyWithoutBusinessUnitInput
    businessUnitSuppliers?: BusinessUnitSupplierCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    companyId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: userUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBusinessUnitsNestedInput
    users?: userUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    companyId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companySuppliers?: CompanySupplierCreateNestedManyWithoutSupplierInput
    businessUnitSuppliers?: BusinessUnitSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutSupplierInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySuppliers?: CompanySupplierUpdateManyWithoutSupplierNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutSupplierNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierCreateInput = {
    id?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanySuppliersInput
    supplier: SupplierCreateNestedOneWithoutCompanySuppliersInput
  }

  export type CompanySupplierUncheckedCreateInput = {
    id?: string
    companyId: string
    supplierId: string
    createdAt?: Date | string
  }

  export type CompanySupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanySuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutCompanySuppliersNestedInput
  }

  export type CompanySupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierCreateManyInput = {
    id?: string
    companyId: string
    supplierId: string
    createdAt?: Date | string
  }

  export type CompanySupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierCreateInput = {
    id?: string
    createdAt?: Date | string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSuppliersInput
    supplier: SupplierCreateNestedOneWithoutBusinessUnitSuppliersInput
  }

  export type BusinessUnitSupplierUncheckedCreateInput = {
    id?: string
    businessUnitId: string
    supplierId: string
    createdAt?: Date | string
  }

  export type BusinessUnitSupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput
  }

  export type BusinessUnitSupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierCreateManyInput = {
    id?: string
    businessUnitId: string
    supplierId: string
    createdAt?: Date | string
  }

  export type BusinessUnitSupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueCreateInput = {
    id?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanyBanquesInput
    banque: BanqueCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyBanqueUncheckedCreateInput = {
    id?: string
    companyId: string
    banqueId: string
    createdAt?: Date | string
  }

  export type CompanyBanqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyBanquesNestedInput
    banque?: BanqueUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyBanqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    banqueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueCreateManyInput = {
    id?: string
    companyId: string
    banqueId: string
    createdAt?: Date | string
  }

  export type CompanyBanqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    banqueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    resource: string
    action: string
    scope?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    resource: string
    action: string
    scope?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    resource: string
    action: string
    scope?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
    user: userCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: userCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    userId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    userId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowTemplateCreateInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepCreateNestedManyWithoutTemplateInput
    engagements?: EngagementCreateNestedManyWithoutWorkflowTemplateInput
  }

  export type WorkflowTemplateUncheckedCreateInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutTemplateInput
    engagements?: EngagementUncheckedCreateNestedManyWithoutWorkflowTemplateInput
  }

  export type WorkflowTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUpdateManyWithoutTemplateNestedInput
    engagements?: EngagementUpdateManyWithoutWorkflowTemplateNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutTemplateNestedInput
    engagements?: EngagementUncheckedUpdateManyWithoutWorkflowTemplateNestedInput
  }

  export type WorkflowTemplateCreateManyInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template: WorkflowTemplateCreateNestedOneWithoutStepsInput
    engagements?: EngagementCreateNestedManyWithoutWorkflowStepInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepUncheckedCreateInput = {
    id?: string
    workflowTemplateId: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutWorkflowStepInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: WorkflowTemplateUpdateOneRequiredWithoutStepsNestedInput
    engagements?: EngagementUpdateManyWithoutWorkflowStepNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowTemplateId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutWorkflowStepNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepCreateManyInput = {
    id?: string
    workflowTemplateId: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowTemplateId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type BusinessUnitNullableRelationFilter = {
    is?: BusinessUnitWhereInput | null
    isNot?: BusinessUnitWhereInput | null
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type StepCompletionListRelationFilter = {
    every?: StepCompletionWhereInput
    some?: StepCompletionWhereInput
    none?: StepCompletionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StepCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastLoginAt?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LigneCreditListRelationFilter = {
    every?: LigneCreditWhereInput
    some?: LigneCreditWhereInput
    none?: LigneCreditWhereInput
  }

  export type CompanyBanqueListRelationFilter = {
    every?: CompanyBanqueWhereInput
    some?: CompanyBanqueWhereInput
    none?: CompanyBanqueWhereInput
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type LigneCreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyBanqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BanqueCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    codeSwift?: SortOrder
    codeGuichet?: SortOrder
    adresse?: SortOrder
    contactInfo?: SortOrder
    establishment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanqueMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    codeSwift?: SortOrder
    codeGuichet?: SortOrder
    adresse?: SortOrder
    contactInfo?: SortOrder
    establishment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanqueMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    codeSwift?: SortOrder
    codeGuichet?: SortOrder
    adresse?: SortOrder
    contactInfo?: SortOrder
    establishment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanqueRelationFilter = {
    is?: BanqueWhereInput
    isNot?: BanqueWhereInput
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    keyAccount?: SortOrder
    currency?: SortOrder
    rib?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    banqueId?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    keyAccount?: SortOrder
    currency?: SortOrder
    rib?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    banqueId?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    keyAccount?: SortOrder
    currency?: SortOrder
    rib?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedBy?: SortOrder
    banqueId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GarantieListRelationFilter = {
    every?: GarantieWhereInput
    some?: GarantieWhereInput
    none?: GarantieWhereInput
  }

  export type EngagementListRelationFilter = {
    every?: EngagementWhereInput
    some?: EngagementWhereInput
    none?: EngagementWhereInput
  }

  export type GarantieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneCreditCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    description?: SortOrder
    banqueId?: SortOrder
    autorisationNo?: SortOrder
    bankAccountNo?: SortOrder
    montantPlafond?: SortOrder
    montantDevise?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    statut?: SortOrder
    responsibilityCenter?: SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    typeFinancement?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    noSeries?: SortOrder
    refinancing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCreditAvgOrderByAggregateInput = {
    montantPlafond?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    refinancing?: SortOrder
  }

  export type LigneCreditMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    description?: SortOrder
    banqueId?: SortOrder
    autorisationNo?: SortOrder
    bankAccountNo?: SortOrder
    montantPlafond?: SortOrder
    montantDevise?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    statut?: SortOrder
    responsibilityCenter?: SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    typeFinancement?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    noSeries?: SortOrder
    refinancing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCreditMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    description?: SortOrder
    banqueId?: SortOrder
    autorisationNo?: SortOrder
    bankAccountNo?: SortOrder
    montantPlafond?: SortOrder
    montantDevise?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    statut?: SortOrder
    responsibilityCenter?: SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    typeFinancement?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    noSeries?: SortOrder
    refinancing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCreditSumOrderByAggregateInput = {
    montantPlafond?: SortOrder
    taux?: SortOrder
    commitmentCommissionRate?: SortOrder
    estimatedOutstanding?: SortOrder
    consumption?: SortOrder
    outstanding?: SortOrder
    seuilAvanceSurStock?: SortOrder
    seuilAvanceSurFacture?: SortOrder
    seuilEscompte?: SortOrder
    seuilLC?: SortOrder
    seuilObligtDouane?: SortOrder
    seuilCautionAdmin?: SortOrder
    seuilDcvrtMobile?: SortOrder
    seuilTrsfrLibre?: SortOrder
    seuilLeasing?: SortOrder
    seuilCMT?: SortOrder
    seuilFraisMission?: SortOrder
    seuilLCAS?: SortOrder
    avanceSurStock?: SortOrder
    avanceFacture?: SortOrder
    escompte?: SortOrder
    obligatDouane?: SortOrder
    cautionAdmin?: SortOrder
    dcvrtMobile?: SortOrder
    trsfrLibre?: SortOrder
    leasing?: SortOrder
    CMT?: SortOrder
    fraisMission?: SortOrder
    LCAS?: SortOrder
    faciliteCaissier?: SortOrder
    maxConsumptionTolerance?: SortOrder
    minConsumptionTolerance?: SortOrder
    refinancing?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LigneCreditRelationFilter = {
    is?: LigneCreditWhereInput
    isNot?: LigneCreditWhereInput
  }

  export type GarantieCountOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateExpiration?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GarantieAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type GarantieMaxOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateExpiration?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GarantieMinOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateExpiration?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GarantieSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LigneCreditNullableRelationFilter = {
    is?: LigneCreditWhereInput | null
    isNot?: LigneCreditWhereInput | null
  }

  export type WorkflowTemplateNullableRelationFilter = {
    is?: WorkflowTemplateWhereInput | null
    isNot?: WorkflowTemplateWhereInput | null
  }

  export type WorkflowStepNullableRelationFilter = {
    is?: WorkflowStepWhereInput | null
    isNot?: WorkflowStepWhereInput | null
  }

  export type EngagementNullableRelationFilter = {
    is?: EngagementWhereInput | null
    isNot?: EngagementWhereInput | null
  }

  export type EngagementCountOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    typeFinancement?: SortOrder
    montant?: SortOrder
    devise?: SortOrder
    dateEngagement?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowTemplateId?: SortOrder
    workflowStepId?: SortOrder
    parentEngagementId?: SortOrder
  }

  export type EngagementAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type EngagementMaxOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    typeFinancement?: SortOrder
    montant?: SortOrder
    devise?: SortOrder
    dateEngagement?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowTemplateId?: SortOrder
    workflowStepId?: SortOrder
    parentEngagementId?: SortOrder
  }

  export type EngagementMinOrderByAggregateInput = {
    id?: SortOrder
    ligneCreditId?: SortOrder
    typeFinancement?: SortOrder
    montant?: SortOrder
    devise?: SortOrder
    dateEngagement?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowTemplateId?: SortOrder
    workflowStepId?: SortOrder
    parentEngagementId?: SortOrder
  }

  export type EngagementSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EngagementRelationFilter = {
    is?: EngagementWhereInput
    isNot?: EngagementWhereInput
  }

  export type WorkflowStepRelationFilter = {
    is?: WorkflowStepWhereInput
    isNot?: WorkflowStepWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type StepCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    workflowStepId?: SortOrder
    fieldData?: SortOrder
    documents?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type StepCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    workflowStepId?: SortOrder
    fieldData?: SortOrder
    documents?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type StepCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    workflowStepId?: SortOrder
    fieldData?: SortOrder
    documents?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type SwiftMessageCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    referenceDossier?: SortOrder
    dateGeneration?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwiftMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    referenceDossier?: SortOrder
    dateGeneration?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwiftMessageMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    referenceDossier?: SortOrder
    dateGeneration?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentImportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nomFichier?: SortOrder
    cheminFichier?: SortOrder
    dateUpload?: SortOrder
    metadata?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentImportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nomFichier?: SortOrder
    cheminFichier?: SortOrder
    dateUpload?: SortOrder
    metadata?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentImportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nomFichier?: SortOrder
    cheminFichier?: SortOrder
    dateUpload?: SortOrder
    metadata?: SortOrder
    referenceDossier?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type BusinessUnitListRelationFilter = {
    every?: BusinessUnitWhereInput
    some?: BusinessUnitWhereInput
    none?: BusinessUnitWhereInput
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type CompanySupplierListRelationFilter = {
    every?: CompanySupplierWhereInput
    some?: CompanySupplierWhereInput
    none?: CompanySupplierWhereInput
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanySupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    address?: SortOrder
    contactInfo?: SortOrder
    parentCompanyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    address?: SortOrder
    contactInfo?: SortOrder
    parentCompanyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    address?: SortOrder
    contactInfo?: SortOrder
    parentCompanyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type BusinessUnitSupplierListRelationFilter = {
    every?: BusinessUnitSupplierWhereInput
    some?: BusinessUnitSupplierWhereInput
    none?: BusinessUnitSupplierWhereInput
  }

  export type BusinessUnitSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUnitCodeCompanyIdCompoundUniqueInput = {
    code: string
    companyId: string
  }

  export type BusinessUnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessUnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type CompanySupplierCompanyIdSupplierIdCompoundUniqueInput = {
    companyId: string
    supplierId: string
  }

  export type CompanySupplierCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanySupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanySupplierMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessUnitRelationFilter = {
    is?: BusinessUnitWhereInput
    isNot?: BusinessUnitWhereInput
  }

  export type BusinessUnitSupplierBusinessUnitIdSupplierIdCompoundUniqueInput = {
    businessUnitId: string
    supplierId: string
  }

  export type BusinessUnitSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    businessUnitId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessUnitSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    businessUnitId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessUnitSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    businessUnitId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyBanqueCompanyIdBanqueIdCompoundUniqueInput = {
    companyId: string
    banqueId: string
  }

  export type CompanyBanqueCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    banqueId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyBanqueMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    banqueId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyBanqueMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    banqueId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompanyIdBusinessUnitIdCompoundUniqueInput = {
    userId: string
    roleId: string
    companyId: string
    businessUnitId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
    businessUnitId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type WorkflowStepListRelationFilter = {
    every?: WorkflowStepWhereInput
    some?: WorkflowStepWhereInput
    none?: WorkflowStepWhereInput
  }

  export type WorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    displayOrder?: SortOrder
    formSchema?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowTemplateAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type WorkflowTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowTemplateSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type WorkflowTemplateRelationFilter = {
    is?: WorkflowTemplateWhereInput
    isNot?: WorkflowTemplateWhereInput
  }

  export type WorkflowStepWorkflowTemplateIdStepOrderCompoundUniqueInput = {
    workflowTemplateId: string
    stepOrder: number
  }

  export type WorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    workflowTemplateId?: SortOrder
    stepOrder?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    requiredFields?: SortOrder
    requiredDocuments?: SortOrder
    requiresApproval?: SortOrder
    approvalRoles?: SortOrder
    triggerAction?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    allowedRoles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepAvgOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type WorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowTemplateId?: SortOrder
    stepOrder?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    requiresApproval?: SortOrder
    triggerAction?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    workflowTemplateId?: SortOrder
    stepOrder?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    requiresApproval?: SortOrder
    triggerAction?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepSumOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type BusinessUnitCreateNestedOneWithoutUsersInput = {
    create?: XOR<BusinessUnitCreateWithoutUsersInput, BusinessUnitUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutUsersInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StepCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput> | StepCompletionCreateWithoutUserInput[] | StepCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutUserInput | StepCompletionCreateOrConnectWithoutUserInput[]
    createMany?: StepCompletionCreateManyUserInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StepCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput> | StepCompletionCreateWithoutUserInput[] | StepCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutUserInput | StepCompletionCreateOrConnectWithoutUserInput[]
    createMany?: StepCompletionCreateManyUserInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type BusinessUnitUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutUsersInput, BusinessUnitUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutUsersInput
    upsert?: BusinessUnitUpsertWithoutUsersInput
    disconnect?: BusinessUnitWhereInput | boolean
    delete?: BusinessUnitWhereInput | boolean
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutUsersInput, BusinessUnitUpdateWithoutUsersInput>, BusinessUnitUncheckedUpdateWithoutUsersInput>
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StepCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput> | StepCompletionCreateWithoutUserInput[] | StepCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutUserInput | StepCompletionCreateOrConnectWithoutUserInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutUserInput | StepCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StepCompletionCreateManyUserInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutUserInput | StepCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutUserInput | StepCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StepCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput> | StepCompletionCreateWithoutUserInput[] | StepCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutUserInput | StepCompletionCreateOrConnectWithoutUserInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutUserInput | StepCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StepCompletionCreateManyUserInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutUserInput | StepCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutUserInput | StepCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type LigneCreditCreateNestedManyWithoutBanqueInput = {
    create?: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput> | LigneCreditCreateWithoutBanqueInput[] | LigneCreditUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: LigneCreditCreateOrConnectWithoutBanqueInput | LigneCreditCreateOrConnectWithoutBanqueInput[]
    createMany?: LigneCreditCreateManyBanqueInputEnvelope
    connect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
  }

  export type CompanyBanqueCreateNestedManyWithoutBanqueInput = {
    create?: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput> | CompanyBanqueCreateWithoutBanqueInput[] | CompanyBanqueUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutBanqueInput | CompanyBanqueCreateOrConnectWithoutBanqueInput[]
    createMany?: CompanyBanqueCreateManyBanqueInputEnvelope
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
  }

  export type BankAccountCreateNestedManyWithoutBanqueInput = {
    create?: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput> | BankAccountCreateWithoutBanqueInput[] | BankAccountUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutBanqueInput | BankAccountCreateOrConnectWithoutBanqueInput[]
    createMany?: BankAccountCreateManyBanqueInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type LigneCreditUncheckedCreateNestedManyWithoutBanqueInput = {
    create?: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput> | LigneCreditCreateWithoutBanqueInput[] | LigneCreditUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: LigneCreditCreateOrConnectWithoutBanqueInput | LigneCreditCreateOrConnectWithoutBanqueInput[]
    createMany?: LigneCreditCreateManyBanqueInputEnvelope
    connect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
  }

  export type CompanyBanqueUncheckedCreateNestedManyWithoutBanqueInput = {
    create?: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput> | CompanyBanqueCreateWithoutBanqueInput[] | CompanyBanqueUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutBanqueInput | CompanyBanqueCreateOrConnectWithoutBanqueInput[]
    createMany?: CompanyBanqueCreateManyBanqueInputEnvelope
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedManyWithoutBanqueInput = {
    create?: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput> | BankAccountCreateWithoutBanqueInput[] | BankAccountUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutBanqueInput | BankAccountCreateOrConnectWithoutBanqueInput[]
    createMany?: BankAccountCreateManyBanqueInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type LigneCreditUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput> | LigneCreditCreateWithoutBanqueInput[] | LigneCreditUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: LigneCreditCreateOrConnectWithoutBanqueInput | LigneCreditCreateOrConnectWithoutBanqueInput[]
    upsert?: LigneCreditUpsertWithWhereUniqueWithoutBanqueInput | LigneCreditUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: LigneCreditCreateManyBanqueInputEnvelope
    set?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    disconnect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    delete?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    connect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    update?: LigneCreditUpdateWithWhereUniqueWithoutBanqueInput | LigneCreditUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: LigneCreditUpdateManyWithWhereWithoutBanqueInput | LigneCreditUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: LigneCreditScalarWhereInput | LigneCreditScalarWhereInput[]
  }

  export type CompanyBanqueUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput> | CompanyBanqueCreateWithoutBanqueInput[] | CompanyBanqueUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutBanqueInput | CompanyBanqueCreateOrConnectWithoutBanqueInput[]
    upsert?: CompanyBanqueUpsertWithWhereUniqueWithoutBanqueInput | CompanyBanqueUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: CompanyBanqueCreateManyBanqueInputEnvelope
    set?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    disconnect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    delete?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    update?: CompanyBanqueUpdateWithWhereUniqueWithoutBanqueInput | CompanyBanqueUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: CompanyBanqueUpdateManyWithWhereWithoutBanqueInput | CompanyBanqueUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
  }

  export type BankAccountUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput> | BankAccountCreateWithoutBanqueInput[] | BankAccountUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutBanqueInput | BankAccountCreateOrConnectWithoutBanqueInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutBanqueInput | BankAccountUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: BankAccountCreateManyBanqueInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutBanqueInput | BankAccountUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutBanqueInput | BankAccountUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type LigneCreditUncheckedUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput> | LigneCreditCreateWithoutBanqueInput[] | LigneCreditUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: LigneCreditCreateOrConnectWithoutBanqueInput | LigneCreditCreateOrConnectWithoutBanqueInput[]
    upsert?: LigneCreditUpsertWithWhereUniqueWithoutBanqueInput | LigneCreditUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: LigneCreditCreateManyBanqueInputEnvelope
    set?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    disconnect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    delete?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    connect?: LigneCreditWhereUniqueInput | LigneCreditWhereUniqueInput[]
    update?: LigneCreditUpdateWithWhereUniqueWithoutBanqueInput | LigneCreditUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: LigneCreditUpdateManyWithWhereWithoutBanqueInput | LigneCreditUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: LigneCreditScalarWhereInput | LigneCreditScalarWhereInput[]
  }

  export type CompanyBanqueUncheckedUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput> | CompanyBanqueCreateWithoutBanqueInput[] | CompanyBanqueUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutBanqueInput | CompanyBanqueCreateOrConnectWithoutBanqueInput[]
    upsert?: CompanyBanqueUpsertWithWhereUniqueWithoutBanqueInput | CompanyBanqueUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: CompanyBanqueCreateManyBanqueInputEnvelope
    set?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    disconnect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    delete?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    update?: CompanyBanqueUpdateWithWhereUniqueWithoutBanqueInput | CompanyBanqueUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: CompanyBanqueUpdateManyWithWhereWithoutBanqueInput | CompanyBanqueUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateManyWithoutBanqueNestedInput = {
    create?: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput> | BankAccountCreateWithoutBanqueInput[] | BankAccountUncheckedCreateWithoutBanqueInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutBanqueInput | BankAccountCreateOrConnectWithoutBanqueInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutBanqueInput | BankAccountUpsertWithWhereUniqueWithoutBanqueInput[]
    createMany?: BankAccountCreateManyBanqueInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutBanqueInput | BankAccountUpdateWithWhereUniqueWithoutBanqueInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutBanqueInput | BankAccountUpdateManyWithWhereWithoutBanqueInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type BanqueCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<BanqueCreateWithoutBankAccountsInput, BanqueUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutBankAccountsInput
    connect?: BanqueWhereUniqueInput
  }

  export type BanqueUpdateOneRequiredWithoutBankAccountsNestedInput = {
    create?: XOR<BanqueCreateWithoutBankAccountsInput, BanqueUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutBankAccountsInput
    upsert?: BanqueUpsertWithoutBankAccountsInput
    connect?: BanqueWhereUniqueInput
    update?: XOR<XOR<BanqueUpdateToOneWithWhereWithoutBankAccountsInput, BanqueUpdateWithoutBankAccountsInput>, BanqueUncheckedUpdateWithoutBankAccountsInput>
  }

  export type BanqueCreateNestedOneWithoutLignesCreditInput = {
    create?: XOR<BanqueCreateWithoutLignesCreditInput, BanqueUncheckedCreateWithoutLignesCreditInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutLignesCreditInput
    connect?: BanqueWhereUniqueInput
  }

  export type GarantieCreateNestedManyWithoutLigneCreditInput = {
    create?: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput> | GarantieCreateWithoutLigneCreditInput[] | GarantieUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: GarantieCreateOrConnectWithoutLigneCreditInput | GarantieCreateOrConnectWithoutLigneCreditInput[]
    createMany?: GarantieCreateManyLigneCreditInputEnvelope
    connect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
  }

  export type EngagementCreateNestedManyWithoutLigneCreditInput = {
    create?: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput> | EngagementCreateWithoutLigneCreditInput[] | EngagementUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutLigneCreditInput | EngagementCreateOrConnectWithoutLigneCreditInput[]
    createMany?: EngagementCreateManyLigneCreditInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type GarantieUncheckedCreateNestedManyWithoutLigneCreditInput = {
    create?: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput> | GarantieCreateWithoutLigneCreditInput[] | GarantieUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: GarantieCreateOrConnectWithoutLigneCreditInput | GarantieCreateOrConnectWithoutLigneCreditInput[]
    createMany?: GarantieCreateManyLigneCreditInputEnvelope
    connect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
  }

  export type EngagementUncheckedCreateNestedManyWithoutLigneCreditInput = {
    create?: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput> | EngagementCreateWithoutLigneCreditInput[] | EngagementUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutLigneCreditInput | EngagementCreateOrConnectWithoutLigneCreditInput[]
    createMany?: EngagementCreateManyLigneCreditInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BanqueUpdateOneRequiredWithoutLignesCreditNestedInput = {
    create?: XOR<BanqueCreateWithoutLignesCreditInput, BanqueUncheckedCreateWithoutLignesCreditInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutLignesCreditInput
    upsert?: BanqueUpsertWithoutLignesCreditInput
    connect?: BanqueWhereUniqueInput
    update?: XOR<XOR<BanqueUpdateToOneWithWhereWithoutLignesCreditInput, BanqueUpdateWithoutLignesCreditInput>, BanqueUncheckedUpdateWithoutLignesCreditInput>
  }

  export type GarantieUpdateManyWithoutLigneCreditNestedInput = {
    create?: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput> | GarantieCreateWithoutLigneCreditInput[] | GarantieUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: GarantieCreateOrConnectWithoutLigneCreditInput | GarantieCreateOrConnectWithoutLigneCreditInput[]
    upsert?: GarantieUpsertWithWhereUniqueWithoutLigneCreditInput | GarantieUpsertWithWhereUniqueWithoutLigneCreditInput[]
    createMany?: GarantieCreateManyLigneCreditInputEnvelope
    set?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    disconnect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    delete?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    connect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    update?: GarantieUpdateWithWhereUniqueWithoutLigneCreditInput | GarantieUpdateWithWhereUniqueWithoutLigneCreditInput[]
    updateMany?: GarantieUpdateManyWithWhereWithoutLigneCreditInput | GarantieUpdateManyWithWhereWithoutLigneCreditInput[]
    deleteMany?: GarantieScalarWhereInput | GarantieScalarWhereInput[]
  }

  export type EngagementUpdateManyWithoutLigneCreditNestedInput = {
    create?: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput> | EngagementCreateWithoutLigneCreditInput[] | EngagementUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutLigneCreditInput | EngagementCreateOrConnectWithoutLigneCreditInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutLigneCreditInput | EngagementUpsertWithWhereUniqueWithoutLigneCreditInput[]
    createMany?: EngagementCreateManyLigneCreditInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutLigneCreditInput | EngagementUpdateWithWhereUniqueWithoutLigneCreditInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutLigneCreditInput | EngagementUpdateManyWithWhereWithoutLigneCreditInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type GarantieUncheckedUpdateManyWithoutLigneCreditNestedInput = {
    create?: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput> | GarantieCreateWithoutLigneCreditInput[] | GarantieUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: GarantieCreateOrConnectWithoutLigneCreditInput | GarantieCreateOrConnectWithoutLigneCreditInput[]
    upsert?: GarantieUpsertWithWhereUniqueWithoutLigneCreditInput | GarantieUpsertWithWhereUniqueWithoutLigneCreditInput[]
    createMany?: GarantieCreateManyLigneCreditInputEnvelope
    set?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    disconnect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    delete?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    connect?: GarantieWhereUniqueInput | GarantieWhereUniqueInput[]
    update?: GarantieUpdateWithWhereUniqueWithoutLigneCreditInput | GarantieUpdateWithWhereUniqueWithoutLigneCreditInput[]
    updateMany?: GarantieUpdateManyWithWhereWithoutLigneCreditInput | GarantieUpdateManyWithWhereWithoutLigneCreditInput[]
    deleteMany?: GarantieScalarWhereInput | GarantieScalarWhereInput[]
  }

  export type EngagementUncheckedUpdateManyWithoutLigneCreditNestedInput = {
    create?: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput> | EngagementCreateWithoutLigneCreditInput[] | EngagementUncheckedCreateWithoutLigneCreditInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutLigneCreditInput | EngagementCreateOrConnectWithoutLigneCreditInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutLigneCreditInput | EngagementUpsertWithWhereUniqueWithoutLigneCreditInput[]
    createMany?: EngagementCreateManyLigneCreditInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutLigneCreditInput | EngagementUpdateWithWhereUniqueWithoutLigneCreditInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutLigneCreditInput | EngagementUpdateManyWithWhereWithoutLigneCreditInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type LigneCreditCreateNestedOneWithoutGarantiesInput = {
    create?: XOR<LigneCreditCreateWithoutGarantiesInput, LigneCreditUncheckedCreateWithoutGarantiesInput>
    connectOrCreate?: LigneCreditCreateOrConnectWithoutGarantiesInput
    connect?: LigneCreditWhereUniqueInput
  }

  export type LigneCreditUpdateOneRequiredWithoutGarantiesNestedInput = {
    create?: XOR<LigneCreditCreateWithoutGarantiesInput, LigneCreditUncheckedCreateWithoutGarantiesInput>
    connectOrCreate?: LigneCreditCreateOrConnectWithoutGarantiesInput
    upsert?: LigneCreditUpsertWithoutGarantiesInput
    connect?: LigneCreditWhereUniqueInput
    update?: XOR<XOR<LigneCreditUpdateToOneWithWhereWithoutGarantiesInput, LigneCreditUpdateWithoutGarantiesInput>, LigneCreditUncheckedUpdateWithoutGarantiesInput>
  }

  export type LigneCreditCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<LigneCreditCreateWithoutEngagementsInput, LigneCreditUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: LigneCreditCreateOrConnectWithoutEngagementsInput
    connect?: LigneCreditWhereUniqueInput
  }

  export type WorkflowTemplateCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<WorkflowTemplateCreateWithoutEngagementsInput, WorkflowTemplateUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutEngagementsInput
    connect?: WorkflowTemplateWhereUniqueInput
  }

  export type WorkflowStepCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<WorkflowStepCreateWithoutEngagementsInput, WorkflowStepUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutEngagementsInput
    connect?: WorkflowStepWhereUniqueInput
  }

  export type EngagementCreateNestedOneWithoutChildEngagementsInput = {
    create?: XOR<EngagementCreateWithoutChildEngagementsInput, EngagementUncheckedCreateWithoutChildEngagementsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutChildEngagementsInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementCreateNestedManyWithoutParentEngagementInput = {
    create?: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput> | EngagementCreateWithoutParentEngagementInput[] | EngagementUncheckedCreateWithoutParentEngagementInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutParentEngagementInput | EngagementCreateOrConnectWithoutParentEngagementInput[]
    createMany?: EngagementCreateManyParentEngagementInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type StepCompletionCreateNestedManyWithoutEngagementInput = {
    create?: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput> | StepCompletionCreateWithoutEngagementInput[] | StepCompletionUncheckedCreateWithoutEngagementInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutEngagementInput | StepCompletionCreateOrConnectWithoutEngagementInput[]
    createMany?: StepCompletionCreateManyEngagementInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type EngagementUncheckedCreateNestedManyWithoutParentEngagementInput = {
    create?: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput> | EngagementCreateWithoutParentEngagementInput[] | EngagementUncheckedCreateWithoutParentEngagementInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutParentEngagementInput | EngagementCreateOrConnectWithoutParentEngagementInput[]
    createMany?: EngagementCreateManyParentEngagementInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type StepCompletionUncheckedCreateNestedManyWithoutEngagementInput = {
    create?: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput> | StepCompletionCreateWithoutEngagementInput[] | StepCompletionUncheckedCreateWithoutEngagementInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutEngagementInput | StepCompletionCreateOrConnectWithoutEngagementInput[]
    createMany?: StepCompletionCreateManyEngagementInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LigneCreditUpdateOneWithoutEngagementsNestedInput = {
    create?: XOR<LigneCreditCreateWithoutEngagementsInput, LigneCreditUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: LigneCreditCreateOrConnectWithoutEngagementsInput
    upsert?: LigneCreditUpsertWithoutEngagementsInput
    disconnect?: LigneCreditWhereInput | boolean
    delete?: LigneCreditWhereInput | boolean
    connect?: LigneCreditWhereUniqueInput
    update?: XOR<XOR<LigneCreditUpdateToOneWithWhereWithoutEngagementsInput, LigneCreditUpdateWithoutEngagementsInput>, LigneCreditUncheckedUpdateWithoutEngagementsInput>
  }

  export type WorkflowTemplateUpdateOneWithoutEngagementsNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutEngagementsInput, WorkflowTemplateUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutEngagementsInput
    upsert?: WorkflowTemplateUpsertWithoutEngagementsInput
    disconnect?: WorkflowTemplateWhereInput | boolean
    delete?: WorkflowTemplateWhereInput | boolean
    connect?: WorkflowTemplateWhereUniqueInput
    update?: XOR<XOR<WorkflowTemplateUpdateToOneWithWhereWithoutEngagementsInput, WorkflowTemplateUpdateWithoutEngagementsInput>, WorkflowTemplateUncheckedUpdateWithoutEngagementsInput>
  }

  export type WorkflowStepUpdateOneWithoutEngagementsNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutEngagementsInput, WorkflowStepUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutEngagementsInput
    upsert?: WorkflowStepUpsertWithoutEngagementsInput
    disconnect?: WorkflowStepWhereInput | boolean
    delete?: WorkflowStepWhereInput | boolean
    connect?: WorkflowStepWhereUniqueInput
    update?: XOR<XOR<WorkflowStepUpdateToOneWithWhereWithoutEngagementsInput, WorkflowStepUpdateWithoutEngagementsInput>, WorkflowStepUncheckedUpdateWithoutEngagementsInput>
  }

  export type EngagementUpdateOneWithoutChildEngagementsNestedInput = {
    create?: XOR<EngagementCreateWithoutChildEngagementsInput, EngagementUncheckedCreateWithoutChildEngagementsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutChildEngagementsInput
    upsert?: EngagementUpsertWithoutChildEngagementsInput
    disconnect?: EngagementWhereInput | boolean
    delete?: EngagementWhereInput | boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<XOR<EngagementUpdateToOneWithWhereWithoutChildEngagementsInput, EngagementUpdateWithoutChildEngagementsInput>, EngagementUncheckedUpdateWithoutChildEngagementsInput>
  }

  export type EngagementUpdateManyWithoutParentEngagementNestedInput = {
    create?: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput> | EngagementCreateWithoutParentEngagementInput[] | EngagementUncheckedCreateWithoutParentEngagementInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutParentEngagementInput | EngagementCreateOrConnectWithoutParentEngagementInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutParentEngagementInput | EngagementUpsertWithWhereUniqueWithoutParentEngagementInput[]
    createMany?: EngagementCreateManyParentEngagementInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutParentEngagementInput | EngagementUpdateWithWhereUniqueWithoutParentEngagementInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutParentEngagementInput | EngagementUpdateManyWithWhereWithoutParentEngagementInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type StepCompletionUpdateManyWithoutEngagementNestedInput = {
    create?: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput> | StepCompletionCreateWithoutEngagementInput[] | StepCompletionUncheckedCreateWithoutEngagementInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutEngagementInput | StepCompletionCreateOrConnectWithoutEngagementInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutEngagementInput | StepCompletionUpsertWithWhereUniqueWithoutEngagementInput[]
    createMany?: StepCompletionCreateManyEngagementInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutEngagementInput | StepCompletionUpdateWithWhereUniqueWithoutEngagementInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutEngagementInput | StepCompletionUpdateManyWithWhereWithoutEngagementInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput = {
    create?: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput> | EngagementCreateWithoutParentEngagementInput[] | EngagementUncheckedCreateWithoutParentEngagementInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutParentEngagementInput | EngagementCreateOrConnectWithoutParentEngagementInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutParentEngagementInput | EngagementUpsertWithWhereUniqueWithoutParentEngagementInput[]
    createMany?: EngagementCreateManyParentEngagementInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutParentEngagementInput | EngagementUpdateWithWhereUniqueWithoutParentEngagementInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutParentEngagementInput | EngagementUpdateManyWithWhereWithoutParentEngagementInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput = {
    create?: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput> | StepCompletionCreateWithoutEngagementInput[] | StepCompletionUncheckedCreateWithoutEngagementInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutEngagementInput | StepCompletionCreateOrConnectWithoutEngagementInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutEngagementInput | StepCompletionUpsertWithWhereUniqueWithoutEngagementInput[]
    createMany?: StepCompletionCreateManyEngagementInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutEngagementInput | StepCompletionUpdateWithWhereUniqueWithoutEngagementInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutEngagementInput | StepCompletionUpdateManyWithWhereWithoutEngagementInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type EngagementCreateNestedOneWithoutStepCompletionsInput = {
    create?: XOR<EngagementCreateWithoutStepCompletionsInput, EngagementUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutStepCompletionsInput
    connect?: EngagementWhereUniqueInput
  }

  export type WorkflowStepCreateNestedOneWithoutStepCompletionsInput = {
    create?: XOR<WorkflowStepCreateWithoutStepCompletionsInput, WorkflowStepUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutStepCompletionsInput
    connect?: WorkflowStepWhereUniqueInput
  }

  export type userCreateNestedOneWithoutStepCompletionsInput = {
    create?: XOR<userCreateWithoutStepCompletionsInput, userUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: userCreateOrConnectWithoutStepCompletionsInput
    connect?: userWhereUniqueInput
  }

  export type EngagementUpdateOneRequiredWithoutStepCompletionsNestedInput = {
    create?: XOR<EngagementCreateWithoutStepCompletionsInput, EngagementUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutStepCompletionsInput
    upsert?: EngagementUpsertWithoutStepCompletionsInput
    connect?: EngagementWhereUniqueInput
    update?: XOR<XOR<EngagementUpdateToOneWithWhereWithoutStepCompletionsInput, EngagementUpdateWithoutStepCompletionsInput>, EngagementUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type WorkflowStepUpdateOneRequiredWithoutStepCompletionsNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutStepCompletionsInput, WorkflowStepUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutStepCompletionsInput
    upsert?: WorkflowStepUpsertWithoutStepCompletionsInput
    connect?: WorkflowStepWhereUniqueInput
    update?: XOR<XOR<WorkflowStepUpdateToOneWithWhereWithoutStepCompletionsInput, WorkflowStepUpdateWithoutStepCompletionsInput>, WorkflowStepUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type userUpdateOneWithoutStepCompletionsNestedInput = {
    create?: XOR<userCreateWithoutStepCompletionsInput, userUncheckedCreateWithoutStepCompletionsInput>
    connectOrCreate?: userCreateOrConnectWithoutStepCompletionsInput
    upsert?: userUpsertWithoutStepCompletionsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutStepCompletionsInput, userUpdateWithoutStepCompletionsInput>, userUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type CompanyCreateNestedOneWithoutSubCompaniesInput = {
    create?: XOR<CompanyCreateWithoutSubCompaniesInput, CompanyUncheckedCreateWithoutSubCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubCompaniesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyCreateNestedManyWithoutParentCompanyInput = {
    create?: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput> | CompanyCreateWithoutParentCompanyInput[] | CompanyUncheckedCreateWithoutParentCompanyInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutParentCompanyInput | CompanyCreateOrConnectWithoutParentCompanyInput[]
    createMany?: CompanyCreateManyParentCompanyInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type BusinessUnitCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput> | BusinessUnitCreateWithoutCompanyInput[] | BusinessUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutCompanyInput | BusinessUnitCreateOrConnectWithoutCompanyInput[]
    createMany?: BusinessUnitCreateManyCompanyInputEnvelope
    connect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutCompanyInput = {
    create?: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput> | userCreateWithoutCompanyInput[] | userUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: userCreateOrConnectWithoutCompanyInput | userCreateOrConnectWithoutCompanyInput[]
    createMany?: userCreateManyCompanyInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type CompanySupplierCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput> | CompanySupplierCreateWithoutCompanyInput[] | CompanySupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutCompanyInput | CompanySupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanySupplierCreateManyCompanyInputEnvelope
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
  }

  export type CompanyBanqueCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput> | CompanyBanqueCreateWithoutCompanyInput[] | CompanyBanqueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutCompanyInput | CompanyBanqueCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBanqueCreateManyCompanyInputEnvelope
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutParentCompanyInput = {
    create?: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput> | CompanyCreateWithoutParentCompanyInput[] | CompanyUncheckedCreateWithoutParentCompanyInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutParentCompanyInput | CompanyCreateOrConnectWithoutParentCompanyInput[]
    createMany?: CompanyCreateManyParentCompanyInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput> | BusinessUnitCreateWithoutCompanyInput[] | BusinessUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutCompanyInput | BusinessUnitCreateOrConnectWithoutCompanyInput[]
    createMany?: BusinessUnitCreateManyCompanyInputEnvelope
    connect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput> | userCreateWithoutCompanyInput[] | userUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: userCreateOrConnectWithoutCompanyInput | userCreateOrConnectWithoutCompanyInput[]
    createMany?: userCreateManyCompanyInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput> | CompanySupplierCreateWithoutCompanyInput[] | CompanySupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutCompanyInput | CompanySupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanySupplierCreateManyCompanyInputEnvelope
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
  }

  export type CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput> | CompanyBanqueCreateWithoutCompanyInput[] | CompanyBanqueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutCompanyInput | CompanyBanqueCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBanqueCreateManyCompanyInputEnvelope
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
  }

  export type CompanyUpdateOneWithoutSubCompaniesNestedInput = {
    create?: XOR<CompanyCreateWithoutSubCompaniesInput, CompanyUncheckedCreateWithoutSubCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubCompaniesInput
    upsert?: CompanyUpsertWithoutSubCompaniesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSubCompaniesInput, CompanyUpdateWithoutSubCompaniesInput>, CompanyUncheckedUpdateWithoutSubCompaniesInput>
  }

  export type CompanyUpdateManyWithoutParentCompanyNestedInput = {
    create?: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput> | CompanyCreateWithoutParentCompanyInput[] | CompanyUncheckedCreateWithoutParentCompanyInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutParentCompanyInput | CompanyCreateOrConnectWithoutParentCompanyInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutParentCompanyInput | CompanyUpsertWithWhereUniqueWithoutParentCompanyInput[]
    createMany?: CompanyCreateManyParentCompanyInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutParentCompanyInput | CompanyUpdateWithWhereUniqueWithoutParentCompanyInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutParentCompanyInput | CompanyUpdateManyWithWhereWithoutParentCompanyInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type BusinessUnitUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput> | BusinessUnitCreateWithoutCompanyInput[] | BusinessUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutCompanyInput | BusinessUnitCreateOrConnectWithoutCompanyInput[]
    upsert?: BusinessUnitUpsertWithWhereUniqueWithoutCompanyInput | BusinessUnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BusinessUnitCreateManyCompanyInputEnvelope
    set?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    disconnect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    delete?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    connect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    update?: BusinessUnitUpdateWithWhereUniqueWithoutCompanyInput | BusinessUnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BusinessUnitUpdateManyWithWhereWithoutCompanyInput | BusinessUnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BusinessUnitScalarWhereInput | BusinessUnitScalarWhereInput[]
  }

  export type userUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput> | userCreateWithoutCompanyInput[] | userUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: userCreateOrConnectWithoutCompanyInput | userCreateOrConnectWithoutCompanyInput[]
    upsert?: userUpsertWithWhereUniqueWithoutCompanyInput | userUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: userCreateManyCompanyInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutCompanyInput | userUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: userUpdateManyWithWhereWithoutCompanyInput | userUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type CompanySupplierUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput> | CompanySupplierCreateWithoutCompanyInput[] | CompanySupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutCompanyInput | CompanySupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanySupplierUpsertWithWhereUniqueWithoutCompanyInput | CompanySupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanySupplierCreateManyCompanyInputEnvelope
    set?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    disconnect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    delete?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    update?: CompanySupplierUpdateWithWhereUniqueWithoutCompanyInput | CompanySupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanySupplierUpdateManyWithWhereWithoutCompanyInput | CompanySupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
  }

  export type CompanyBanqueUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput> | CompanyBanqueCreateWithoutCompanyInput[] | CompanyBanqueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutCompanyInput | CompanyBanqueCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBanqueUpsertWithWhereUniqueWithoutCompanyInput | CompanyBanqueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBanqueCreateManyCompanyInputEnvelope
    set?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    disconnect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    delete?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    update?: CompanyBanqueUpdateWithWhereUniqueWithoutCompanyInput | CompanyBanqueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBanqueUpdateManyWithWhereWithoutCompanyInput | CompanyBanqueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput = {
    create?: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput> | CompanyCreateWithoutParentCompanyInput[] | CompanyUncheckedCreateWithoutParentCompanyInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutParentCompanyInput | CompanyCreateOrConnectWithoutParentCompanyInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutParentCompanyInput | CompanyUpsertWithWhereUniqueWithoutParentCompanyInput[]
    createMany?: CompanyCreateManyParentCompanyInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutParentCompanyInput | CompanyUpdateWithWhereUniqueWithoutParentCompanyInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutParentCompanyInput | CompanyUpdateManyWithWhereWithoutParentCompanyInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput> | BusinessUnitCreateWithoutCompanyInput[] | BusinessUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutCompanyInput | BusinessUnitCreateOrConnectWithoutCompanyInput[]
    upsert?: BusinessUnitUpsertWithWhereUniqueWithoutCompanyInput | BusinessUnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BusinessUnitCreateManyCompanyInputEnvelope
    set?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    disconnect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    delete?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    connect?: BusinessUnitWhereUniqueInput | BusinessUnitWhereUniqueInput[]
    update?: BusinessUnitUpdateWithWhereUniqueWithoutCompanyInput | BusinessUnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BusinessUnitUpdateManyWithWhereWithoutCompanyInput | BusinessUnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BusinessUnitScalarWhereInput | BusinessUnitScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput> | userCreateWithoutCompanyInput[] | userUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: userCreateOrConnectWithoutCompanyInput | userCreateOrConnectWithoutCompanyInput[]
    upsert?: userUpsertWithWhereUniqueWithoutCompanyInput | userUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: userCreateManyCompanyInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutCompanyInput | userUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: userUpdateManyWithWhereWithoutCompanyInput | userUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput> | CompanySupplierCreateWithoutCompanyInput[] | CompanySupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutCompanyInput | CompanySupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanySupplierUpsertWithWhereUniqueWithoutCompanyInput | CompanySupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanySupplierCreateManyCompanyInputEnvelope
    set?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    disconnect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    delete?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    update?: CompanySupplierUpdateWithWhereUniqueWithoutCompanyInput | CompanySupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanySupplierUpdateManyWithWhereWithoutCompanyInput | CompanySupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
  }

  export type CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput> | CompanyBanqueCreateWithoutCompanyInput[] | CompanyBanqueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBanqueCreateOrConnectWithoutCompanyInput | CompanyBanqueCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBanqueUpsertWithWhereUniqueWithoutCompanyInput | CompanyBanqueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBanqueCreateManyCompanyInputEnvelope
    set?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    disconnect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    delete?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    connect?: CompanyBanqueWhereUniqueInput | CompanyBanqueWhereUniqueInput[]
    update?: CompanyBanqueUpdateWithWhereUniqueWithoutCompanyInput | CompanyBanqueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBanqueUpdateManyWithWhereWithoutCompanyInput | CompanyBanqueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBusinessUnitsInput = {
    create?: XOR<CompanyCreateWithoutBusinessUnitsInput, CompanyUncheckedCreateWithoutBusinessUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBusinessUnitsInput
    connect?: CompanyWhereUniqueInput
  }

  export type userCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput> | userCreateWithoutBusinessUnitInput[] | userUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: userCreateOrConnectWithoutBusinessUnitInput | userCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: userCreateManyBusinessUnitInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type BusinessUnitSupplierCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSupplierCreateWithoutBusinessUnitInput[] | BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSupplierCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput> | userCreateWithoutBusinessUnitInput[] | userUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: userCreateOrConnectWithoutBusinessUnitInput | userCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: userCreateManyBusinessUnitInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type BusinessUnitSupplierUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSupplierCreateWithoutBusinessUnitInput[] | BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSupplierCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBusinessUnitsNestedInput = {
    create?: XOR<CompanyCreateWithoutBusinessUnitsInput, CompanyUncheckedCreateWithoutBusinessUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBusinessUnitsInput
    upsert?: CompanyUpsertWithoutBusinessUnitsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBusinessUnitsInput, CompanyUpdateWithoutBusinessUnitsInput>, CompanyUncheckedUpdateWithoutBusinessUnitsInput>
  }

  export type userUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput> | userCreateWithoutBusinessUnitInput[] | userUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: userCreateOrConnectWithoutBusinessUnitInput | userCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: userUpsertWithWhereUniqueWithoutBusinessUnitInput | userUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: userCreateManyBusinessUnitInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutBusinessUnitInput | userUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: userUpdateManyWithWhereWithoutBusinessUnitInput | userUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type BusinessUnitSupplierUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSupplierCreateWithoutBusinessUnitInput[] | BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitSupplierUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSupplierUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSupplierCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    disconnect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    delete?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    update?: BusinessUnitSupplierUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSupplierUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitSupplierUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitSupplierUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput> | userCreateWithoutBusinessUnitInput[] | userUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: userCreateOrConnectWithoutBusinessUnitInput | userCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: userUpsertWithWhereUniqueWithoutBusinessUnitInput | userUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: userCreateManyBusinessUnitInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutBusinessUnitInput | userUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: userUpdateManyWithWhereWithoutBusinessUnitInput | userUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSupplierCreateWithoutBusinessUnitInput[] | BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitSupplierUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSupplierUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSupplierCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    disconnect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    delete?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    update?: BusinessUnitSupplierUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSupplierUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitSupplierUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitSupplierUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
  }

  export type CompanySupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput> | CompanySupplierCreateWithoutSupplierInput[] | CompanySupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutSupplierInput | CompanySupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: CompanySupplierCreateManySupplierInputEnvelope
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
  }

  export type BusinessUnitSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput> | BusinessUnitSupplierCreateWithoutSupplierInput[] | BusinessUnitSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutSupplierInput | BusinessUnitSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: BusinessUnitSupplierCreateManySupplierInputEnvelope
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
  }

  export type CompanySupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput> | CompanySupplierCreateWithoutSupplierInput[] | CompanySupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutSupplierInput | CompanySupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: CompanySupplierCreateManySupplierInputEnvelope
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
  }

  export type BusinessUnitSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput> | BusinessUnitSupplierCreateWithoutSupplierInput[] | BusinessUnitSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutSupplierInput | BusinessUnitSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: BusinessUnitSupplierCreateManySupplierInputEnvelope
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
  }

  export type CompanySupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput> | CompanySupplierCreateWithoutSupplierInput[] | CompanySupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutSupplierInput | CompanySupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: CompanySupplierUpsertWithWhereUniqueWithoutSupplierInput | CompanySupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CompanySupplierCreateManySupplierInputEnvelope
    set?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    disconnect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    delete?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    update?: CompanySupplierUpdateWithWhereUniqueWithoutSupplierInput | CompanySupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CompanySupplierUpdateManyWithWhereWithoutSupplierInput | CompanySupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
  }

  export type BusinessUnitSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput> | BusinessUnitSupplierCreateWithoutSupplierInput[] | BusinessUnitSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutSupplierInput | BusinessUnitSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: BusinessUnitSupplierUpsertWithWhereUniqueWithoutSupplierInput | BusinessUnitSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: BusinessUnitSupplierCreateManySupplierInputEnvelope
    set?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    disconnect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    delete?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    update?: BusinessUnitSupplierUpdateWithWhereUniqueWithoutSupplierInput | BusinessUnitSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: BusinessUnitSupplierUpdateManyWithWhereWithoutSupplierInput | BusinessUnitSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
  }

  export type CompanySupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput> | CompanySupplierCreateWithoutSupplierInput[] | CompanySupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CompanySupplierCreateOrConnectWithoutSupplierInput | CompanySupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: CompanySupplierUpsertWithWhereUniqueWithoutSupplierInput | CompanySupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CompanySupplierCreateManySupplierInputEnvelope
    set?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    disconnect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    delete?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    connect?: CompanySupplierWhereUniqueInput | CompanySupplierWhereUniqueInput[]
    update?: CompanySupplierUpdateWithWhereUniqueWithoutSupplierInput | CompanySupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CompanySupplierUpdateManyWithWhereWithoutSupplierInput | CompanySupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
  }

  export type BusinessUnitSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput> | BusinessUnitSupplierCreateWithoutSupplierInput[] | BusinessUnitSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BusinessUnitSupplierCreateOrConnectWithoutSupplierInput | BusinessUnitSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: BusinessUnitSupplierUpsertWithWhereUniqueWithoutSupplierInput | BusinessUnitSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: BusinessUnitSupplierCreateManySupplierInputEnvelope
    set?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    disconnect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    delete?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    connect?: BusinessUnitSupplierWhereUniqueInput | BusinessUnitSupplierWhereUniqueInput[]
    update?: BusinessUnitSupplierUpdateWithWhereUniqueWithoutSupplierInput | BusinessUnitSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: BusinessUnitSupplierUpdateManyWithWhereWithoutSupplierInput | BusinessUnitSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCompanySuppliersInput = {
    create?: XOR<CompanyCreateWithoutCompanySuppliersInput, CompanyUncheckedCreateWithoutCompanySuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanySuppliersInput
    connect?: CompanyWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutCompanySuppliersInput = {
    create?: XOR<SupplierCreateWithoutCompanySuppliersInput, SupplierUncheckedCreateWithoutCompanySuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanySuppliersInput
    connect?: SupplierWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanySuppliersNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanySuppliersInput, CompanyUncheckedCreateWithoutCompanySuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanySuppliersInput
    upsert?: CompanyUpsertWithoutCompanySuppliersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanySuppliersInput, CompanyUpdateWithoutCompanySuppliersInput>, CompanyUncheckedUpdateWithoutCompanySuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutCompanySuppliersNestedInput = {
    create?: XOR<SupplierCreateWithoutCompanySuppliersInput, SupplierUncheckedCreateWithoutCompanySuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanySuppliersInput
    upsert?: SupplierUpsertWithoutCompanySuppliersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutCompanySuppliersInput, SupplierUpdateWithoutCompanySuppliersInput>, SupplierUncheckedUpdateWithoutCompanySuppliersInput>
  }

  export type BusinessUnitCreateNestedOneWithoutBusinessUnitSuppliersInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSuppliersInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitSuppliersInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutBusinessUnitSuppliersInput = {
    create?: XOR<SupplierCreateWithoutBusinessUnitSuppliersInput, SupplierUncheckedCreateWithoutBusinessUnitSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutBusinessUnitSuppliersInput
    connect?: SupplierWhereUniqueInput
  }

  export type BusinessUnitUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSuppliersInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitSuppliersInput
    upsert?: BusinessUnitUpsertWithoutBusinessUnitSuppliersInput
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitSuppliersInput, BusinessUnitUpdateWithoutBusinessUnitSuppliersInput>, BusinessUnitUncheckedUpdateWithoutBusinessUnitSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput = {
    create?: XOR<SupplierCreateWithoutBusinessUnitSuppliersInput, SupplierUncheckedCreateWithoutBusinessUnitSuppliersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutBusinessUnitSuppliersInput
    upsert?: SupplierUpsertWithoutBusinessUnitSuppliersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutBusinessUnitSuppliersInput, SupplierUpdateWithoutBusinessUnitSuppliersInput>, SupplierUncheckedUpdateWithoutBusinessUnitSuppliersInput>
  }

  export type CompanyCreateNestedOneWithoutCompanyBanquesInput = {
    create?: XOR<CompanyCreateWithoutCompanyBanquesInput, CompanyUncheckedCreateWithoutCompanyBanquesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyBanquesInput
    connect?: CompanyWhereUniqueInput
  }

  export type BanqueCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<BanqueCreateWithoutCompaniesInput, BanqueUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutCompaniesInput
    connect?: BanqueWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanyBanquesNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyBanquesInput, CompanyUncheckedCreateWithoutCompanyBanquesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyBanquesInput
    upsert?: CompanyUpsertWithoutCompanyBanquesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyBanquesInput, CompanyUpdateWithoutCompanyBanquesInput>, CompanyUncheckedUpdateWithoutCompanyBanquesInput>
  }

  export type BanqueUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<BanqueCreateWithoutCompaniesInput, BanqueUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: BanqueCreateOrConnectWithoutCompaniesInput
    upsert?: BanqueUpsertWithoutCompaniesInput
    connect?: BanqueWhereUniqueInput
    update?: XOR<XOR<BanqueUpdateToOneWithWhereWithoutCompaniesInput, BanqueUpdateWithoutCompaniesInput>, BanqueUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<userCreateWithoutUserRolesInput, userUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUserRolesInput
    connect?: userWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<userCreateWithoutUserRolesInput, userUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUserRolesInput
    upsert?: userUpsertWithoutUserRolesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserRolesInput, userUpdateWithoutUserRolesInput>, userUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type userCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<userCreateWithoutAuditLogsInput, userUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: userCreateOrConnectWithoutAuditLogsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<userCreateWithoutAuditLogsInput, userUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: userCreateOrConnectWithoutAuditLogsInput
    upsert?: userUpsertWithoutAuditLogsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAuditLogsInput, userUpdateWithoutAuditLogsInput>, userUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkflowStepCreateNestedManyWithoutTemplateInput = {
    create?: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput> | WorkflowStepCreateWithoutTemplateInput[] | WorkflowStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutTemplateInput | WorkflowStepCreateOrConnectWithoutTemplateInput[]
    createMany?: WorkflowStepCreateManyTemplateInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type EngagementCreateNestedManyWithoutWorkflowTemplateInput = {
    create?: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput> | EngagementCreateWithoutWorkflowTemplateInput[] | EngagementUncheckedCreateWithoutWorkflowTemplateInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowTemplateInput | EngagementCreateOrConnectWithoutWorkflowTemplateInput[]
    createMany?: EngagementCreateManyWorkflowTemplateInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type WorkflowStepUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput> | WorkflowStepCreateWithoutTemplateInput[] | WorkflowStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutTemplateInput | WorkflowStepCreateOrConnectWithoutTemplateInput[]
    createMany?: WorkflowStepCreateManyTemplateInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type EngagementUncheckedCreateNestedManyWithoutWorkflowTemplateInput = {
    create?: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput> | EngagementCreateWithoutWorkflowTemplateInput[] | EngagementUncheckedCreateWithoutWorkflowTemplateInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowTemplateInput | EngagementCreateOrConnectWithoutWorkflowTemplateInput[]
    createMany?: EngagementCreateManyWorkflowTemplateInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type WorkflowStepUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput> | WorkflowStepCreateWithoutTemplateInput[] | WorkflowStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutTemplateInput | WorkflowStepCreateOrConnectWithoutTemplateInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutTemplateInput | WorkflowStepUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: WorkflowStepCreateManyTemplateInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutTemplateInput | WorkflowStepUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutTemplateInput | WorkflowStepUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type EngagementUpdateManyWithoutWorkflowTemplateNestedInput = {
    create?: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput> | EngagementCreateWithoutWorkflowTemplateInput[] | EngagementUncheckedCreateWithoutWorkflowTemplateInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowTemplateInput | EngagementCreateOrConnectWithoutWorkflowTemplateInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutWorkflowTemplateInput | EngagementUpsertWithWhereUniqueWithoutWorkflowTemplateInput[]
    createMany?: EngagementCreateManyWorkflowTemplateInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutWorkflowTemplateInput | EngagementUpdateWithWhereUniqueWithoutWorkflowTemplateInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutWorkflowTemplateInput | EngagementUpdateManyWithWhereWithoutWorkflowTemplateInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type WorkflowStepUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput> | WorkflowStepCreateWithoutTemplateInput[] | WorkflowStepUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutTemplateInput | WorkflowStepCreateOrConnectWithoutTemplateInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutTemplateInput | WorkflowStepUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: WorkflowStepCreateManyTemplateInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutTemplateInput | WorkflowStepUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutTemplateInput | WorkflowStepUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type EngagementUncheckedUpdateManyWithoutWorkflowTemplateNestedInput = {
    create?: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput> | EngagementCreateWithoutWorkflowTemplateInput[] | EngagementUncheckedCreateWithoutWorkflowTemplateInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowTemplateInput | EngagementCreateOrConnectWithoutWorkflowTemplateInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutWorkflowTemplateInput | EngagementUpsertWithWhereUniqueWithoutWorkflowTemplateInput[]
    createMany?: EngagementCreateManyWorkflowTemplateInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutWorkflowTemplateInput | EngagementUpdateWithWhereUniqueWithoutWorkflowTemplateInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutWorkflowTemplateInput | EngagementUpdateManyWithWhereWithoutWorkflowTemplateInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type WorkflowTemplateCreateNestedOneWithoutStepsInput = {
    create?: XOR<WorkflowTemplateCreateWithoutStepsInput, WorkflowTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutStepsInput
    connect?: WorkflowTemplateWhereUniqueInput
  }

  export type EngagementCreateNestedManyWithoutWorkflowStepInput = {
    create?: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput> | EngagementCreateWithoutWorkflowStepInput[] | EngagementUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowStepInput | EngagementCreateOrConnectWithoutWorkflowStepInput[]
    createMany?: EngagementCreateManyWorkflowStepInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type StepCompletionCreateNestedManyWithoutWorkflowStepInput = {
    create?: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput> | StepCompletionCreateWithoutWorkflowStepInput[] | StepCompletionUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutWorkflowStepInput | StepCompletionCreateOrConnectWithoutWorkflowStepInput[]
    createMany?: StepCompletionCreateManyWorkflowStepInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type EngagementUncheckedCreateNestedManyWithoutWorkflowStepInput = {
    create?: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput> | EngagementCreateWithoutWorkflowStepInput[] | EngagementUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowStepInput | EngagementCreateOrConnectWithoutWorkflowStepInput[]
    createMany?: EngagementCreateManyWorkflowStepInputEnvelope
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
  }

  export type StepCompletionUncheckedCreateNestedManyWithoutWorkflowStepInput = {
    create?: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput> | StepCompletionCreateWithoutWorkflowStepInput[] | StepCompletionUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutWorkflowStepInput | StepCompletionCreateOrConnectWithoutWorkflowStepInput[]
    createMany?: StepCompletionCreateManyWorkflowStepInputEnvelope
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
  }

  export type WorkflowTemplateUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<WorkflowTemplateCreateWithoutStepsInput, WorkflowTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowTemplateCreateOrConnectWithoutStepsInput
    upsert?: WorkflowTemplateUpsertWithoutStepsInput
    connect?: WorkflowTemplateWhereUniqueInput
    update?: XOR<XOR<WorkflowTemplateUpdateToOneWithWhereWithoutStepsInput, WorkflowTemplateUpdateWithoutStepsInput>, WorkflowTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type EngagementUpdateManyWithoutWorkflowStepNestedInput = {
    create?: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput> | EngagementCreateWithoutWorkflowStepInput[] | EngagementUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowStepInput | EngagementCreateOrConnectWithoutWorkflowStepInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutWorkflowStepInput | EngagementUpsertWithWhereUniqueWithoutWorkflowStepInput[]
    createMany?: EngagementCreateManyWorkflowStepInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutWorkflowStepInput | EngagementUpdateWithWhereUniqueWithoutWorkflowStepInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutWorkflowStepInput | EngagementUpdateManyWithWhereWithoutWorkflowStepInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type StepCompletionUpdateManyWithoutWorkflowStepNestedInput = {
    create?: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput> | StepCompletionCreateWithoutWorkflowStepInput[] | StepCompletionUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutWorkflowStepInput | StepCompletionCreateOrConnectWithoutWorkflowStepInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutWorkflowStepInput | StepCompletionUpsertWithWhereUniqueWithoutWorkflowStepInput[]
    createMany?: StepCompletionCreateManyWorkflowStepInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutWorkflowStepInput | StepCompletionUpdateWithWhereUniqueWithoutWorkflowStepInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutWorkflowStepInput | StepCompletionUpdateManyWithWhereWithoutWorkflowStepInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type EngagementUncheckedUpdateManyWithoutWorkflowStepNestedInput = {
    create?: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput> | EngagementCreateWithoutWorkflowStepInput[] | EngagementUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: EngagementCreateOrConnectWithoutWorkflowStepInput | EngagementCreateOrConnectWithoutWorkflowStepInput[]
    upsert?: EngagementUpsertWithWhereUniqueWithoutWorkflowStepInput | EngagementUpsertWithWhereUniqueWithoutWorkflowStepInput[]
    createMany?: EngagementCreateManyWorkflowStepInputEnvelope
    set?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    disconnect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    delete?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    connect?: EngagementWhereUniqueInput | EngagementWhereUniqueInput[]
    update?: EngagementUpdateWithWhereUniqueWithoutWorkflowStepInput | EngagementUpdateWithWhereUniqueWithoutWorkflowStepInput[]
    updateMany?: EngagementUpdateManyWithWhereWithoutWorkflowStepInput | EngagementUpdateManyWithWhereWithoutWorkflowStepInput[]
    deleteMany?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
  }

  export type StepCompletionUncheckedUpdateManyWithoutWorkflowStepNestedInput = {
    create?: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput> | StepCompletionCreateWithoutWorkflowStepInput[] | StepCompletionUncheckedCreateWithoutWorkflowStepInput[]
    connectOrCreate?: StepCompletionCreateOrConnectWithoutWorkflowStepInput | StepCompletionCreateOrConnectWithoutWorkflowStepInput[]
    upsert?: StepCompletionUpsertWithWhereUniqueWithoutWorkflowStepInput | StepCompletionUpsertWithWhereUniqueWithoutWorkflowStepInput[]
    createMany?: StepCompletionCreateManyWorkflowStepInputEnvelope
    set?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    disconnect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    delete?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    connect?: StepCompletionWhereUniqueInput | StepCompletionWhereUniqueInput[]
    update?: StepCompletionUpdateWithWhereUniqueWithoutWorkflowStepInput | StepCompletionUpdateWithWhereUniqueWithoutWorkflowStepInput[]
    updateMany?: StepCompletionUpdateManyWithWhereWithoutWorkflowStepInput | StepCompletionUpdateManyWithWhereWithoutWorkflowStepInput[]
    deleteMany?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type BusinessUnitCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBusinessUnitsInput
    businessUnitSuppliers?: BusinessUnitSupplierCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    companyId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutUsersInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutUsersInput, BusinessUnitUncheckedCreateWithoutUsersInput>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StepCompletionCreateWithoutUserInput = {
    id?: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    engagement: EngagementCreateNestedOneWithoutStepCompletionsInput
    workflowStep: WorkflowStepCreateNestedOneWithoutStepCompletionsInput
  }

  export type StepCompletionUncheckedCreateWithoutUserInput = {
    id?: string
    engagementId: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type StepCompletionCreateOrConnectWithoutUserInput = {
    where: StepCompletionWhereUniqueInput
    create: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput>
  }

  export type StepCompletionCreateManyUserInputEnvelope = {
    data: StepCompletionCreateManyUserInput | StepCompletionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BusinessUnitUpsertWithoutUsersInput = {
    update: XOR<BusinessUnitUpdateWithoutUsersInput, BusinessUnitUncheckedUpdateWithoutUsersInput>
    create: XOR<BusinessUnitCreateWithoutUsersInput, BusinessUnitUncheckedCreateWithoutUsersInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutUsersInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutUsersInput, BusinessUnitUncheckedUpdateWithoutUsersInput>
  }

  export type BusinessUnitUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBusinessUnitsNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    companyId?: StringNullableFilter<"UserRole"> | string | null
    businessUnitId?: StringNullableFilter<"UserRole"> | string | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringNullableFilter<"UserRole"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type StepCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: StepCompletionWhereUniqueInput
    update: XOR<StepCompletionUpdateWithoutUserInput, StepCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<StepCompletionCreateWithoutUserInput, StepCompletionUncheckedCreateWithoutUserInput>
  }

  export type StepCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: StepCompletionWhereUniqueInput
    data: XOR<StepCompletionUpdateWithoutUserInput, StepCompletionUncheckedUpdateWithoutUserInput>
  }

  export type StepCompletionUpdateManyWithWhereWithoutUserInput = {
    where: StepCompletionScalarWhereInput
    data: XOR<StepCompletionUpdateManyMutationInput, StepCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type StepCompletionScalarWhereInput = {
    AND?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
    OR?: StepCompletionScalarWhereInput[]
    NOT?: StepCompletionScalarWhereInput | StepCompletionScalarWhereInput[]
    id?: StringFilter<"StepCompletion"> | string
    engagementId?: StringFilter<"StepCompletion"> | string
    workflowStepId?: StringFilter<"StepCompletion"> | string
    fieldData?: StringNullableFilter<"StepCompletion"> | string | null
    documents?: StringNullableFilter<"StepCompletion"> | string | null
    completedBy?: StringNullableFilter<"StepCompletion"> | string | null
    completedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    createdAt?: DateTimeFilter<"StepCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"StepCompletion"> | Date | string
    notes?: StringNullableFilter<"StepCompletion"> | string | null
  }

  export type LigneCreditCreateWithoutBanqueInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    garanties?: GarantieCreateNestedManyWithoutLigneCreditInput
    engagements?: EngagementCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditUncheckedCreateWithoutBanqueInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    garanties?: GarantieUncheckedCreateNestedManyWithoutLigneCreditInput
    engagements?: EngagementUncheckedCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditCreateOrConnectWithoutBanqueInput = {
    where: LigneCreditWhereUniqueInput
    create: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput>
  }

  export type LigneCreditCreateManyBanqueInputEnvelope = {
    data: LigneCreditCreateManyBanqueInput | LigneCreditCreateManyBanqueInput[]
    skipDuplicates?: boolean
  }

  export type CompanyBanqueCreateWithoutBanqueInput = {
    id?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanyBanquesInput
  }

  export type CompanyBanqueUncheckedCreateWithoutBanqueInput = {
    id?: string
    companyId: string
    createdAt?: Date | string
  }

  export type CompanyBanqueCreateOrConnectWithoutBanqueInput = {
    where: CompanyBanqueWhereUniqueInput
    create: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput>
  }

  export type CompanyBanqueCreateManyBanqueInputEnvelope = {
    data: CompanyBanqueCreateManyBanqueInput | CompanyBanqueCreateManyBanqueInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutBanqueInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
  }

  export type BankAccountUncheckedCreateWithoutBanqueInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
  }

  export type BankAccountCreateOrConnectWithoutBanqueInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput>
  }

  export type BankAccountCreateManyBanqueInputEnvelope = {
    data: BankAccountCreateManyBanqueInput | BankAccountCreateManyBanqueInput[]
    skipDuplicates?: boolean
  }

  export type LigneCreditUpsertWithWhereUniqueWithoutBanqueInput = {
    where: LigneCreditWhereUniqueInput
    update: XOR<LigneCreditUpdateWithoutBanqueInput, LigneCreditUncheckedUpdateWithoutBanqueInput>
    create: XOR<LigneCreditCreateWithoutBanqueInput, LigneCreditUncheckedCreateWithoutBanqueInput>
  }

  export type LigneCreditUpdateWithWhereUniqueWithoutBanqueInput = {
    where: LigneCreditWhereUniqueInput
    data: XOR<LigneCreditUpdateWithoutBanqueInput, LigneCreditUncheckedUpdateWithoutBanqueInput>
  }

  export type LigneCreditUpdateManyWithWhereWithoutBanqueInput = {
    where: LigneCreditScalarWhereInput
    data: XOR<LigneCreditUpdateManyMutationInput, LigneCreditUncheckedUpdateManyWithoutBanqueInput>
  }

  export type LigneCreditScalarWhereInput = {
    AND?: LigneCreditScalarWhereInput | LigneCreditScalarWhereInput[]
    OR?: LigneCreditScalarWhereInput[]
    NOT?: LigneCreditScalarWhereInput | LigneCreditScalarWhereInput[]
    id?: StringFilter<"LigneCredit"> | string
    no?: StringFilter<"LigneCredit"> | string
    description?: StringNullableFilter<"LigneCredit"> | string | null
    banqueId?: StringFilter<"LigneCredit"> | string
    autorisationNo?: StringFilter<"LigneCredit"> | string
    bankAccountNo?: StringFilter<"LigneCredit"> | string
    montantPlafond?: FloatFilter<"LigneCredit"> | number
    montantDevise?: StringFilter<"LigneCredit"> | string
    taux?: FloatFilter<"LigneCredit"> | number
    commitmentCommissionRate?: FloatFilter<"LigneCredit"> | number
    estimatedOutstanding?: FloatFilter<"LigneCredit"> | number
    consumption?: FloatFilter<"LigneCredit"> | number
    outstanding?: FloatFilter<"LigneCredit"> | number
    startDate?: DateTimeFilter<"LigneCredit"> | Date | string
    expiryDate?: DateTimeFilter<"LigneCredit"> | Date | string
    renewalDate?: DateTimeNullableFilter<"LigneCredit"> | Date | string | null
    statut?: StringFilter<"LigneCredit"> | string
    responsibilityCenter?: StringNullableFilter<"LigneCredit"> | string | null
    seuilAvanceSurStock?: FloatFilter<"LigneCredit"> | number
    seuilAvanceSurFacture?: FloatFilter<"LigneCredit"> | number
    seuilEscompte?: FloatFilter<"LigneCredit"> | number
    seuilLC?: FloatFilter<"LigneCredit"> | number
    seuilObligtDouane?: FloatFilter<"LigneCredit"> | number
    seuilCautionAdmin?: FloatFilter<"LigneCredit"> | number
    seuilDcvrtMobile?: FloatFilter<"LigneCredit"> | number
    seuilTrsfrLibre?: FloatFilter<"LigneCredit"> | number
    seuilLeasing?: FloatFilter<"LigneCredit"> | number
    seuilCMT?: FloatFilter<"LigneCredit"> | number
    seuilFraisMission?: FloatFilter<"LigneCredit"> | number
    seuilLCAS?: FloatFilter<"LigneCredit"> | number
    avanceSurStock?: FloatFilter<"LigneCredit"> | number
    avanceFacture?: FloatFilter<"LigneCredit"> | number
    escompte?: FloatFilter<"LigneCredit"> | number
    obligatDouane?: FloatFilter<"LigneCredit"> | number
    cautionAdmin?: FloatFilter<"LigneCredit"> | number
    dcvrtMobile?: FloatFilter<"LigneCredit"> | number
    trsfrLibre?: FloatFilter<"LigneCredit"> | number
    leasing?: FloatFilter<"LigneCredit"> | number
    CMT?: FloatFilter<"LigneCredit"> | number
    fraisMission?: FloatFilter<"LigneCredit"> | number
    LCAS?: FloatFilter<"LigneCredit"> | number
    faciliteCaissier?: FloatFilter<"LigneCredit"> | number
    typeFinancement?: StringFilter<"LigneCredit"> | string
    maxConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    minConsumptionTolerance?: FloatFilter<"LigneCredit"> | number
    noSeries?: StringFilter<"LigneCredit"> | string
    refinancing?: FloatFilter<"LigneCredit"> | number
    createdAt?: DateTimeFilter<"LigneCredit"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCredit"> | Date | string
  }

  export type CompanyBanqueUpsertWithWhereUniqueWithoutBanqueInput = {
    where: CompanyBanqueWhereUniqueInput
    update: XOR<CompanyBanqueUpdateWithoutBanqueInput, CompanyBanqueUncheckedUpdateWithoutBanqueInput>
    create: XOR<CompanyBanqueCreateWithoutBanqueInput, CompanyBanqueUncheckedCreateWithoutBanqueInput>
  }

  export type CompanyBanqueUpdateWithWhereUniqueWithoutBanqueInput = {
    where: CompanyBanqueWhereUniqueInput
    data: XOR<CompanyBanqueUpdateWithoutBanqueInput, CompanyBanqueUncheckedUpdateWithoutBanqueInput>
  }

  export type CompanyBanqueUpdateManyWithWhereWithoutBanqueInput = {
    where: CompanyBanqueScalarWhereInput
    data: XOR<CompanyBanqueUpdateManyMutationInput, CompanyBanqueUncheckedUpdateManyWithoutBanqueInput>
  }

  export type CompanyBanqueScalarWhereInput = {
    AND?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
    OR?: CompanyBanqueScalarWhereInput[]
    NOT?: CompanyBanqueScalarWhereInput | CompanyBanqueScalarWhereInput[]
    id?: StringFilter<"CompanyBanque"> | string
    companyId?: StringFilter<"CompanyBanque"> | string
    banqueId?: StringFilter<"CompanyBanque"> | string
    createdAt?: DateTimeFilter<"CompanyBanque"> | Date | string
  }

  export type BankAccountUpsertWithWhereUniqueWithoutBanqueInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutBanqueInput, BankAccountUncheckedUpdateWithoutBanqueInput>
    create: XOR<BankAccountCreateWithoutBanqueInput, BankAccountUncheckedCreateWithoutBanqueInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutBanqueInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutBanqueInput, BankAccountUncheckedUpdateWithoutBanqueInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutBanqueInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutBanqueInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    OR?: BankAccountScalarWhereInput[]
    NOT?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    accountNumber?: StringFilter<"BankAccount"> | string
    keyAccount?: StringFilter<"BankAccount"> | string
    currency?: StringFilter<"BankAccount"> | string
    rib?: StringNullableFilter<"BankAccount"> | string | null
    isActive?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    createdBy?: StringFilter<"BankAccount"> | string
    updatedBy?: StringFilter<"BankAccount"> | string
    deletedBy?: StringNullableFilter<"BankAccount"> | string | null
    banqueId?: StringFilter<"BankAccount"> | string
  }

  export type BanqueCreateWithoutBankAccountsInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditCreateNestedManyWithoutBanqueInput
    companies?: CompanyBanqueCreateNestedManyWithoutBanqueInput
  }

  export type BanqueUncheckedCreateWithoutBankAccountsInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditUncheckedCreateNestedManyWithoutBanqueInput
    companies?: CompanyBanqueUncheckedCreateNestedManyWithoutBanqueInput
  }

  export type BanqueCreateOrConnectWithoutBankAccountsInput = {
    where: BanqueWhereUniqueInput
    create: XOR<BanqueCreateWithoutBankAccountsInput, BanqueUncheckedCreateWithoutBankAccountsInput>
  }

  export type BanqueUpsertWithoutBankAccountsInput = {
    update: XOR<BanqueUpdateWithoutBankAccountsInput, BanqueUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<BanqueCreateWithoutBankAccountsInput, BanqueUncheckedCreateWithoutBankAccountsInput>
    where?: BanqueWhereInput
  }

  export type BanqueUpdateToOneWithWhereWithoutBankAccountsInput = {
    where?: BanqueWhereInput
    data: XOR<BanqueUpdateWithoutBankAccountsInput, BanqueUncheckedUpdateWithoutBankAccountsInput>
  }

  export type BanqueUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUpdateManyWithoutBanqueNestedInput
    companies?: CompanyBanqueUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueUncheckedUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUncheckedUpdateManyWithoutBanqueNestedInput
    companies?: CompanyBanqueUncheckedUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueCreateWithoutLignesCreditInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyBanqueCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountCreateNestedManyWithoutBanqueInput
  }

  export type BanqueUncheckedCreateWithoutLignesCreditInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyBanqueUncheckedCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutBanqueInput
  }

  export type BanqueCreateOrConnectWithoutLignesCreditInput = {
    where: BanqueWhereUniqueInput
    create: XOR<BanqueCreateWithoutLignesCreditInput, BanqueUncheckedCreateWithoutLignesCreditInput>
  }

  export type GarantieCreateWithoutLigneCreditInput = {
    id?: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type GarantieUncheckedCreateWithoutLigneCreditInput = {
    id?: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type GarantieCreateOrConnectWithoutLigneCreditInput = {
    where: GarantieWhereUniqueInput
    create: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput>
  }

  export type GarantieCreateManyLigneCreditInputEnvelope = {
    data: GarantieCreateManyLigneCreditInput | GarantieCreateManyLigneCreditInput[]
    skipDuplicates?: boolean
  }

  export type EngagementCreateWithoutLigneCreditInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateWithoutLigneCreditInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementCreateOrConnectWithoutLigneCreditInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput>
  }

  export type EngagementCreateManyLigneCreditInputEnvelope = {
    data: EngagementCreateManyLigneCreditInput | EngagementCreateManyLigneCreditInput[]
    skipDuplicates?: boolean
  }

  export type BanqueUpsertWithoutLignesCreditInput = {
    update: XOR<BanqueUpdateWithoutLignesCreditInput, BanqueUncheckedUpdateWithoutLignesCreditInput>
    create: XOR<BanqueCreateWithoutLignesCreditInput, BanqueUncheckedCreateWithoutLignesCreditInput>
    where?: BanqueWhereInput
  }

  export type BanqueUpdateToOneWithWhereWithoutLignesCreditInput = {
    where?: BanqueWhereInput
    data: XOR<BanqueUpdateWithoutLignesCreditInput, BanqueUncheckedUpdateWithoutLignesCreditInput>
  }

  export type BanqueUpdateWithoutLignesCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyBanqueUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueUncheckedUpdateWithoutLignesCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyBanqueUncheckedUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutBanqueNestedInput
  }

  export type GarantieUpsertWithWhereUniqueWithoutLigneCreditInput = {
    where: GarantieWhereUniqueInput
    update: XOR<GarantieUpdateWithoutLigneCreditInput, GarantieUncheckedUpdateWithoutLigneCreditInput>
    create: XOR<GarantieCreateWithoutLigneCreditInput, GarantieUncheckedCreateWithoutLigneCreditInput>
  }

  export type GarantieUpdateWithWhereUniqueWithoutLigneCreditInput = {
    where: GarantieWhereUniqueInput
    data: XOR<GarantieUpdateWithoutLigneCreditInput, GarantieUncheckedUpdateWithoutLigneCreditInput>
  }

  export type GarantieUpdateManyWithWhereWithoutLigneCreditInput = {
    where: GarantieScalarWhereInput
    data: XOR<GarantieUpdateManyMutationInput, GarantieUncheckedUpdateManyWithoutLigneCreditInput>
  }

  export type GarantieScalarWhereInput = {
    AND?: GarantieScalarWhereInput | GarantieScalarWhereInput[]
    OR?: GarantieScalarWhereInput[]
    NOT?: GarantieScalarWhereInput | GarantieScalarWhereInput[]
    id?: StringFilter<"Garantie"> | string
    ligneCreditId?: StringFilter<"Garantie"> | string
    type?: StringFilter<"Garantie"> | string
    montant?: FloatFilter<"Garantie"> | number
    dateExpiration?: DateTimeFilter<"Garantie"> | Date | string
    description?: StringNullableFilter<"Garantie"> | string | null
    createdAt?: DateTimeFilter<"Garantie"> | Date | string
  }

  export type EngagementUpsertWithWhereUniqueWithoutLigneCreditInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutLigneCreditInput, EngagementUncheckedUpdateWithoutLigneCreditInput>
    create: XOR<EngagementCreateWithoutLigneCreditInput, EngagementUncheckedCreateWithoutLigneCreditInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutLigneCreditInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutLigneCreditInput, EngagementUncheckedUpdateWithoutLigneCreditInput>
  }

  export type EngagementUpdateManyWithWhereWithoutLigneCreditInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutLigneCreditInput>
  }

  export type EngagementScalarWhereInput = {
    AND?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
    OR?: EngagementScalarWhereInput[]
    NOT?: EngagementScalarWhereInput | EngagementScalarWhereInput[]
    id?: StringFilter<"Engagement"> | string
    ligneCreditId?: StringNullableFilter<"Engagement"> | string | null
    typeFinancement?: StringFilter<"Engagement"> | string
    montant?: FloatNullableFilter<"Engagement"> | number | null
    devise?: StringNullableFilter<"Engagement"> | string | null
    dateEngagement?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    dateEcheance?: DateTimeNullableFilter<"Engagement"> | Date | string | null
    statut?: StringFilter<"Engagement"> | string
    referenceDossier?: StringFilter<"Engagement"> | string
    createdAt?: DateTimeFilter<"Engagement"> | Date | string
    updatedAt?: DateTimeFilter<"Engagement"> | Date | string
    workflowTemplateId?: StringNullableFilter<"Engagement"> | string | null
    workflowStepId?: StringNullableFilter<"Engagement"> | string | null
    parentEngagementId?: StringNullableFilter<"Engagement"> | string | null
  }

  export type LigneCreditCreateWithoutGarantiesInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    banque: BanqueCreateNestedOneWithoutLignesCreditInput
    engagements?: EngagementCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditUncheckedCreateWithoutGarantiesInput = {
    id?: string
    no: string
    description?: string | null
    banqueId: string
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditCreateOrConnectWithoutGarantiesInput = {
    where: LigneCreditWhereUniqueInput
    create: XOR<LigneCreditCreateWithoutGarantiesInput, LigneCreditUncheckedCreateWithoutGarantiesInput>
  }

  export type LigneCreditUpsertWithoutGarantiesInput = {
    update: XOR<LigneCreditUpdateWithoutGarantiesInput, LigneCreditUncheckedUpdateWithoutGarantiesInput>
    create: XOR<LigneCreditCreateWithoutGarantiesInput, LigneCreditUncheckedCreateWithoutGarantiesInput>
    where?: LigneCreditWhereInput
  }

  export type LigneCreditUpdateToOneWithWhereWithoutGarantiesInput = {
    where?: LigneCreditWhereInput
    data: XOR<LigneCreditUpdateWithoutGarantiesInput, LigneCreditUncheckedUpdateWithoutGarantiesInput>
  }

  export type LigneCreditUpdateWithoutGarantiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banque?: BanqueUpdateOneRequiredWithoutLignesCreditNestedInput
    engagements?: EngagementUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditUncheckedUpdateWithoutGarantiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditCreateWithoutEngagementsInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    banque: BanqueCreateNestedOneWithoutLignesCreditInput
    garanties?: GarantieCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditUncheckedCreateWithoutEngagementsInput = {
    id?: string
    no: string
    description?: string | null
    banqueId: string
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
    garanties?: GarantieUncheckedCreateNestedManyWithoutLigneCreditInput
  }

  export type LigneCreditCreateOrConnectWithoutEngagementsInput = {
    where: LigneCreditWhereUniqueInput
    create: XOR<LigneCreditCreateWithoutEngagementsInput, LigneCreditUncheckedCreateWithoutEngagementsInput>
  }

  export type WorkflowTemplateCreateWithoutEngagementsInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepCreateNestedManyWithoutTemplateInput
  }

  export type WorkflowTemplateUncheckedCreateWithoutEngagementsInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type WorkflowTemplateCreateOrConnectWithoutEngagementsInput = {
    where: WorkflowTemplateWhereUniqueInput
    create: XOR<WorkflowTemplateCreateWithoutEngagementsInput, WorkflowTemplateUncheckedCreateWithoutEngagementsInput>
  }

  export type WorkflowStepCreateWithoutEngagementsInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template: WorkflowTemplateCreateNestedOneWithoutStepsInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutEngagementsInput = {
    id?: string
    workflowTemplateId: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutEngagementsInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutEngagementsInput, WorkflowStepUncheckedCreateWithoutEngagementsInput>
  }

  export type EngagementCreateWithoutChildEngagementsInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateWithoutChildEngagementsInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementCreateOrConnectWithoutChildEngagementsInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutChildEngagementsInput, EngagementUncheckedCreateWithoutChildEngagementsInput>
  }

  export type EngagementCreateWithoutParentEngagementInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateWithoutParentEngagementInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementCreateOrConnectWithoutParentEngagementInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput>
  }

  export type EngagementCreateManyParentEngagementInputEnvelope = {
    data: EngagementCreateManyParentEngagementInput | EngagementCreateManyParentEngagementInput[]
    skipDuplicates?: boolean
  }

  export type StepCompletionCreateWithoutEngagementInput = {
    id?: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    workflowStep: WorkflowStepCreateNestedOneWithoutStepCompletionsInput
    user?: userCreateNestedOneWithoutStepCompletionsInput
  }

  export type StepCompletionUncheckedCreateWithoutEngagementInput = {
    id?: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type StepCompletionCreateOrConnectWithoutEngagementInput = {
    where: StepCompletionWhereUniqueInput
    create: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput>
  }

  export type StepCompletionCreateManyEngagementInputEnvelope = {
    data: StepCompletionCreateManyEngagementInput | StepCompletionCreateManyEngagementInput[]
    skipDuplicates?: boolean
  }

  export type LigneCreditUpsertWithoutEngagementsInput = {
    update: XOR<LigneCreditUpdateWithoutEngagementsInput, LigneCreditUncheckedUpdateWithoutEngagementsInput>
    create: XOR<LigneCreditCreateWithoutEngagementsInput, LigneCreditUncheckedCreateWithoutEngagementsInput>
    where?: LigneCreditWhereInput
  }

  export type LigneCreditUpdateToOneWithWhereWithoutEngagementsInput = {
    where?: LigneCreditWhereInput
    data: XOR<LigneCreditUpdateWithoutEngagementsInput, LigneCreditUncheckedUpdateWithoutEngagementsInput>
  }

  export type LigneCreditUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banque?: BanqueUpdateOneRequiredWithoutLignesCreditNestedInput
    garanties?: GarantieUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditUncheckedUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banqueId?: StringFieldUpdateOperationsInput | string
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garanties?: GarantieUncheckedUpdateManyWithoutLigneCreditNestedInput
  }

  export type WorkflowTemplateUpsertWithoutEngagementsInput = {
    update: XOR<WorkflowTemplateUpdateWithoutEngagementsInput, WorkflowTemplateUncheckedUpdateWithoutEngagementsInput>
    create: XOR<WorkflowTemplateCreateWithoutEngagementsInput, WorkflowTemplateUncheckedCreateWithoutEngagementsInput>
    where?: WorkflowTemplateWhereInput
  }

  export type WorkflowTemplateUpdateToOneWithWhereWithoutEngagementsInput = {
    where?: WorkflowTemplateWhereInput
    data: XOR<WorkflowTemplateUpdateWithoutEngagementsInput, WorkflowTemplateUncheckedUpdateWithoutEngagementsInput>
  }

  export type WorkflowTemplateUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUpdateManyWithoutTemplateNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type WorkflowStepUpsertWithoutEngagementsInput = {
    update: XOR<WorkflowStepUpdateWithoutEngagementsInput, WorkflowStepUncheckedUpdateWithoutEngagementsInput>
    create: XOR<WorkflowStepCreateWithoutEngagementsInput, WorkflowStepUncheckedCreateWithoutEngagementsInput>
    where?: WorkflowStepWhereInput
  }

  export type WorkflowStepUpdateToOneWithWhereWithoutEngagementsInput = {
    where?: WorkflowStepWhereInput
    data: XOR<WorkflowStepUpdateWithoutEngagementsInput, WorkflowStepUncheckedUpdateWithoutEngagementsInput>
  }

  export type WorkflowStepUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: WorkflowTemplateUpdateOneRequiredWithoutStepsNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowTemplateId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutWorkflowStepNestedInput
  }

  export type EngagementUpsertWithoutChildEngagementsInput = {
    update: XOR<EngagementUpdateWithoutChildEngagementsInput, EngagementUncheckedUpdateWithoutChildEngagementsInput>
    create: XOR<EngagementCreateWithoutChildEngagementsInput, EngagementUncheckedCreateWithoutChildEngagementsInput>
    where?: EngagementWhereInput
  }

  export type EngagementUpdateToOneWithWhereWithoutChildEngagementsInput = {
    where?: EngagementWhereInput
    data: XOR<EngagementUpdateWithoutChildEngagementsInput, EngagementUncheckedUpdateWithoutChildEngagementsInput>
  }

  export type EngagementUpdateWithoutChildEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutChildEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUpsertWithWhereUniqueWithoutParentEngagementInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutParentEngagementInput, EngagementUncheckedUpdateWithoutParentEngagementInput>
    create: XOR<EngagementCreateWithoutParentEngagementInput, EngagementUncheckedCreateWithoutParentEngagementInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutParentEngagementInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutParentEngagementInput, EngagementUncheckedUpdateWithoutParentEngagementInput>
  }

  export type EngagementUpdateManyWithWhereWithoutParentEngagementInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutParentEngagementInput>
  }

  export type StepCompletionUpsertWithWhereUniqueWithoutEngagementInput = {
    where: StepCompletionWhereUniqueInput
    update: XOR<StepCompletionUpdateWithoutEngagementInput, StepCompletionUncheckedUpdateWithoutEngagementInput>
    create: XOR<StepCompletionCreateWithoutEngagementInput, StepCompletionUncheckedCreateWithoutEngagementInput>
  }

  export type StepCompletionUpdateWithWhereUniqueWithoutEngagementInput = {
    where: StepCompletionWhereUniqueInput
    data: XOR<StepCompletionUpdateWithoutEngagementInput, StepCompletionUncheckedUpdateWithoutEngagementInput>
  }

  export type StepCompletionUpdateManyWithWhereWithoutEngagementInput = {
    where: StepCompletionScalarWhereInput
    data: XOR<StepCompletionUpdateManyMutationInput, StepCompletionUncheckedUpdateManyWithoutEngagementInput>
  }

  export type EngagementCreateWithoutStepCompletionsInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
  }

  export type EngagementUncheckedCreateWithoutStepCompletionsInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
  }

  export type EngagementCreateOrConnectWithoutStepCompletionsInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutStepCompletionsInput, EngagementUncheckedCreateWithoutStepCompletionsInput>
  }

  export type WorkflowStepCreateWithoutStepCompletionsInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    template: WorkflowTemplateCreateNestedOneWithoutStepsInput
    engagements?: EngagementCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutStepCompletionsInput = {
    id?: string
    workflowTemplateId: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutStepCompletionsInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutStepCompletionsInput, WorkflowStepUncheckedCreateWithoutStepCompletionsInput>
  }

  export type userCreateWithoutStepCompletionsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    businessUnit?: BusinessUnitCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutStepCompletionsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutStepCompletionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutStepCompletionsInput, userUncheckedCreateWithoutStepCompletionsInput>
  }

  export type EngagementUpsertWithoutStepCompletionsInput = {
    update: XOR<EngagementUpdateWithoutStepCompletionsInput, EngagementUncheckedUpdateWithoutStepCompletionsInput>
    create: XOR<EngagementCreateWithoutStepCompletionsInput, EngagementUncheckedCreateWithoutStepCompletionsInput>
    where?: EngagementWhereInput
  }

  export type EngagementUpdateToOneWithWhereWithoutStepCompletionsInput = {
    where?: EngagementWhereInput
    data: XOR<EngagementUpdateWithoutStepCompletionsInput, EngagementUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type EngagementUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
  }

  export type WorkflowStepUpsertWithoutStepCompletionsInput = {
    update: XOR<WorkflowStepUpdateWithoutStepCompletionsInput, WorkflowStepUncheckedUpdateWithoutStepCompletionsInput>
    create: XOR<WorkflowStepCreateWithoutStepCompletionsInput, WorkflowStepUncheckedCreateWithoutStepCompletionsInput>
    where?: WorkflowStepWhereInput
  }

  export type WorkflowStepUpdateToOneWithWhereWithoutStepCompletionsInput = {
    where?: WorkflowStepWhereInput
    data: XOR<WorkflowStepUpdateWithoutStepCompletionsInput, WorkflowStepUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type WorkflowStepUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: WorkflowTemplateUpdateOneRequiredWithoutStepsNestedInput
    engagements?: EngagementUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowTemplateId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutWorkflowStepNestedInput
  }

  export type userUpsertWithoutStepCompletionsInput = {
    update: XOR<userUpdateWithoutStepCompletionsInput, userUncheckedUpdateWithoutStepCompletionsInput>
    create: XOR<userCreateWithoutStepCompletionsInput, userUncheckedCreateWithoutStepCompletionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutStepCompletionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutStepCompletionsInput, userUncheckedUpdateWithoutStepCompletionsInput>
  }

  export type userUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    businessUnit?: BusinessUnitUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutStepCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutSubCompaniesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSubCompaniesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSubCompaniesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSubCompaniesInput, CompanyUncheckedCreateWithoutSubCompaniesInput>
  }

  export type CompanyCreateWithoutParentCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutParentCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutParentCompanyInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput>
  }

  export type CompanyCreateManyParentCompanyInputEnvelope = {
    data: CompanyCreateManyParentCompanyInput | CompanyCreateManyParentCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: userCreateNestedManyWithoutBusinessUnitInput
    businessUnitSuppliers?: BusinessUnitSupplierCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: userUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutCompanyInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput>
  }

  export type BusinessUnitCreateManyCompanyInputEnvelope = {
    data: BusinessUnitCreateManyCompanyInput | BusinessUnitCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnit?: BusinessUnitCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCompanyInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput>
  }

  export type userCreateManyCompanyInputEnvelope = {
    data: userCreateManyCompanyInput | userCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanySupplierCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutCompanySuppliersInput
  }

  export type CompanySupplierUncheckedCreateWithoutCompanyInput = {
    id?: string
    supplierId: string
    createdAt?: Date | string
  }

  export type CompanySupplierCreateOrConnectWithoutCompanyInput = {
    where: CompanySupplierWhereUniqueInput
    create: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput>
  }

  export type CompanySupplierCreateManyCompanyInputEnvelope = {
    data: CompanySupplierCreateManyCompanyInput | CompanySupplierCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyBanqueCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string
    banque: BanqueCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyBanqueUncheckedCreateWithoutCompanyInput = {
    id?: string
    banqueId: string
    createdAt?: Date | string
  }

  export type CompanyBanqueCreateOrConnectWithoutCompanyInput = {
    where: CompanyBanqueWhereUniqueInput
    create: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBanqueCreateManyCompanyInputEnvelope = {
    data: CompanyBanqueCreateManyCompanyInput | CompanyBanqueCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutSubCompaniesInput = {
    update: XOR<CompanyUpdateWithoutSubCompaniesInput, CompanyUncheckedUpdateWithoutSubCompaniesInput>
    create: XOR<CompanyCreateWithoutSubCompaniesInput, CompanyUncheckedCreateWithoutSubCompaniesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSubCompaniesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSubCompaniesInput, CompanyUncheckedUpdateWithoutSubCompaniesInput>
  }

  export type CompanyUpdateWithoutSubCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSubCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUpsertWithWhereUniqueWithoutParentCompanyInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutParentCompanyInput, CompanyUncheckedUpdateWithoutParentCompanyInput>
    create: XOR<CompanyCreateWithoutParentCompanyInput, CompanyUncheckedCreateWithoutParentCompanyInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutParentCompanyInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutParentCompanyInput, CompanyUncheckedUpdateWithoutParentCompanyInput>
  }

  export type CompanyUpdateManyWithWhereWithoutParentCompanyInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutParentCompanyInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    contactInfo?: StringNullableFilter<"Company"> | string | null
    parentCompanyId?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type BusinessUnitUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BusinessUnitWhereUniqueInput
    update: XOR<BusinessUnitUpdateWithoutCompanyInput, BusinessUnitUncheckedUpdateWithoutCompanyInput>
    create: XOR<BusinessUnitCreateWithoutCompanyInput, BusinessUnitUncheckedCreateWithoutCompanyInput>
  }

  export type BusinessUnitUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BusinessUnitWhereUniqueInput
    data: XOR<BusinessUnitUpdateWithoutCompanyInput, BusinessUnitUncheckedUpdateWithoutCompanyInput>
  }

  export type BusinessUnitUpdateManyWithWhereWithoutCompanyInput = {
    where: BusinessUnitScalarWhereInput
    data: XOR<BusinessUnitUpdateManyMutationInput, BusinessUnitUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BusinessUnitScalarWhereInput = {
    AND?: BusinessUnitScalarWhereInput | BusinessUnitScalarWhereInput[]
    OR?: BusinessUnitScalarWhereInput[]
    NOT?: BusinessUnitScalarWhereInput | BusinessUnitScalarWhereInput[]
    id?: StringFilter<"BusinessUnit"> | string
    name?: StringFilter<"BusinessUnit"> | string
    code?: StringFilter<"BusinessUnit"> | string
    description?: StringNullableFilter<"BusinessUnit"> | string | null
    companyId?: StringFilter<"BusinessUnit"> | string
    isActive?: BoolFilter<"BusinessUnit"> | boolean
    createdAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessUnit"> | Date | string
  }

  export type userUpsertWithWhereUniqueWithoutCompanyInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutCompanyInput, userUncheckedUpdateWithoutCompanyInput>
    create: XOR<userCreateWithoutCompanyInput, userUncheckedCreateWithoutCompanyInput>
  }

  export type userUpdateWithWhereUniqueWithoutCompanyInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutCompanyInput, userUncheckedUpdateWithoutCompanyInput>
  }

  export type userUpdateManyWithWhereWithoutCompanyInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutCompanyInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    phone?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    role?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"user"> | Date | string | null
    failedLoginAttempts?: IntFilter<"user"> | number
    lockedUntil?: DateTimeNullableFilter<"user"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"user"> | Date | string | null
    companyId?: StringNullableFilter<"user"> | string | null
    businessUnitId?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }

  export type CompanySupplierUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanySupplierWhereUniqueInput
    update: XOR<CompanySupplierUpdateWithoutCompanyInput, CompanySupplierUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanySupplierCreateWithoutCompanyInput, CompanySupplierUncheckedCreateWithoutCompanyInput>
  }

  export type CompanySupplierUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanySupplierWhereUniqueInput
    data: XOR<CompanySupplierUpdateWithoutCompanyInput, CompanySupplierUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanySupplierUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanySupplierScalarWhereInput
    data: XOR<CompanySupplierUpdateManyMutationInput, CompanySupplierUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanySupplierScalarWhereInput = {
    AND?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
    OR?: CompanySupplierScalarWhereInput[]
    NOT?: CompanySupplierScalarWhereInput | CompanySupplierScalarWhereInput[]
    id?: StringFilter<"CompanySupplier"> | string
    companyId?: StringFilter<"CompanySupplier"> | string
    supplierId?: StringFilter<"CompanySupplier"> | string
    createdAt?: DateTimeFilter<"CompanySupplier"> | Date | string
  }

  export type CompanyBanqueUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBanqueWhereUniqueInput
    update: XOR<CompanyBanqueUpdateWithoutCompanyInput, CompanyBanqueUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyBanqueCreateWithoutCompanyInput, CompanyBanqueUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBanqueUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBanqueWhereUniqueInput
    data: XOR<CompanyBanqueUpdateWithoutCompanyInput, CompanyBanqueUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyBanqueUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyBanqueScalarWhereInput
    data: XOR<CompanyBanqueUpdateManyMutationInput, CompanyBanqueUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCreateWithoutBusinessUnitsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBusinessUnitsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBusinessUnitsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBusinessUnitsInput, CompanyUncheckedCreateWithoutBusinessUnitsInput>
  }

  export type userCreateWithoutBusinessUnitInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBusinessUnitInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBusinessUnitInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput>
  }

  export type userCreateManyBusinessUnitInputEnvelope = {
    data: userCreateManyBusinessUnitInput | userCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSupplierCreateWithoutBusinessUnitInput = {
    id?: string
    createdAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutBusinessUnitSuppliersInput
  }

  export type BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput = {
    id?: string
    supplierId: string
    createdAt?: Date | string
  }

  export type BusinessUnitSupplierCreateOrConnectWithoutBusinessUnitInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    create: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSupplierCreateManyBusinessUnitInputEnvelope = {
    data: BusinessUnitSupplierCreateManyBusinessUnitInput | BusinessUnitSupplierCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBusinessUnitsInput = {
    update: XOR<CompanyUpdateWithoutBusinessUnitsInput, CompanyUncheckedUpdateWithoutBusinessUnitsInput>
    create: XOR<CompanyCreateWithoutBusinessUnitsInput, CompanyUncheckedCreateWithoutBusinessUnitsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBusinessUnitsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBusinessUnitsInput, CompanyUncheckedUpdateWithoutBusinessUnitsInput>
  }

  export type CompanyUpdateWithoutBusinessUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBusinessUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type userUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutBusinessUnitInput, userUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<userCreateWithoutBusinessUnitInput, userUncheckedCreateWithoutBusinessUnitInput>
  }

  export type userUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutBusinessUnitInput, userUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type userUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitSupplierUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    update: XOR<BusinessUnitSupplierUpdateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<BusinessUnitSupplierCreateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSupplierUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    data: XOR<BusinessUnitSupplierUpdateWithoutBusinessUnitInput, BusinessUnitSupplierUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSupplierUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: BusinessUnitSupplierScalarWhereInput
    data: XOR<BusinessUnitSupplierUpdateManyMutationInput, BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitSupplierScalarWhereInput = {
    AND?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
    OR?: BusinessUnitSupplierScalarWhereInput[]
    NOT?: BusinessUnitSupplierScalarWhereInput | BusinessUnitSupplierScalarWhereInput[]
    id?: StringFilter<"BusinessUnitSupplier"> | string
    businessUnitId?: StringFilter<"BusinessUnitSupplier"> | string
    supplierId?: StringFilter<"BusinessUnitSupplier"> | string
    createdAt?: DateTimeFilter<"BusinessUnitSupplier"> | Date | string
  }

  export type CompanySupplierCreateWithoutSupplierInput = {
    id?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanySuppliersInput
  }

  export type CompanySupplierUncheckedCreateWithoutSupplierInput = {
    id?: string
    companyId: string
    createdAt?: Date | string
  }

  export type CompanySupplierCreateOrConnectWithoutSupplierInput = {
    where: CompanySupplierWhereUniqueInput
    create: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput>
  }

  export type CompanySupplierCreateManySupplierInputEnvelope = {
    data: CompanySupplierCreateManySupplierInput | CompanySupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSupplierCreateWithoutSupplierInput = {
    id?: string
    createdAt?: Date | string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSuppliersInput
  }

  export type BusinessUnitSupplierUncheckedCreateWithoutSupplierInput = {
    id?: string
    businessUnitId: string
    createdAt?: Date | string
  }

  export type BusinessUnitSupplierCreateOrConnectWithoutSupplierInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    create: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type BusinessUnitSupplierCreateManySupplierInputEnvelope = {
    data: BusinessUnitSupplierCreateManySupplierInput | BusinessUnitSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type CompanySupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CompanySupplierWhereUniqueInput
    update: XOR<CompanySupplierUpdateWithoutSupplierInput, CompanySupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<CompanySupplierCreateWithoutSupplierInput, CompanySupplierUncheckedCreateWithoutSupplierInput>
  }

  export type CompanySupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CompanySupplierWhereUniqueInput
    data: XOR<CompanySupplierUpdateWithoutSupplierInput, CompanySupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type CompanySupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: CompanySupplierScalarWhereInput
    data: XOR<CompanySupplierUpdateManyMutationInput, CompanySupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type BusinessUnitSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    update: XOR<BusinessUnitSupplierUpdateWithoutSupplierInput, BusinessUnitSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<BusinessUnitSupplierCreateWithoutSupplierInput, BusinessUnitSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type BusinessUnitSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: BusinessUnitSupplierWhereUniqueInput
    data: XOR<BusinessUnitSupplierUpdateWithoutSupplierInput, BusinessUnitSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type BusinessUnitSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: BusinessUnitSupplierScalarWhereInput
    data: XOR<BusinessUnitSupplierUpdateManyMutationInput, BusinessUnitSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CompanyCreateWithoutCompanySuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanySuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companyBanques?: CompanyBanqueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanySuppliersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanySuppliersInput, CompanyUncheckedCreateWithoutCompanySuppliersInput>
  }

  export type SupplierCreateWithoutCompanySuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSuppliers?: BusinessUnitSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCompanySuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCompanySuppliersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCompanySuppliersInput, SupplierUncheckedCreateWithoutCompanySuppliersInput>
  }

  export type CompanyUpsertWithoutCompanySuppliersInput = {
    update: XOR<CompanyUpdateWithoutCompanySuppliersInput, CompanyUncheckedUpdateWithoutCompanySuppliersInput>
    create: XOR<CompanyCreateWithoutCompanySuppliersInput, CompanyUncheckedCreateWithoutCompanySuppliersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanySuppliersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanySuppliersInput, CompanyUncheckedUpdateWithoutCompanySuppliersInput>
  }

  export type CompanyUpdateWithoutCompanySuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanySuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type SupplierUpsertWithoutCompanySuppliersInput = {
    update: XOR<SupplierUpdateWithoutCompanySuppliersInput, SupplierUncheckedUpdateWithoutCompanySuppliersInput>
    create: XOR<SupplierCreateWithoutCompanySuppliersInput, SupplierUncheckedCreateWithoutCompanySuppliersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutCompanySuppliersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutCompanySuppliersInput, SupplierUncheckedUpdateWithoutCompanySuppliersInput>
  }

  export type SupplierUpdateWithoutCompanySuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSuppliers?: BusinessUnitSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCompanySuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type BusinessUnitCreateWithoutBusinessUnitSuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBusinessUnitsInput
    users?: userCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutBusinessUnitSuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    companyId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: userUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutBusinessUnitSuppliersInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSuppliersInput>
  }

  export type SupplierCreateWithoutBusinessUnitSuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companySuppliers?: CompanySupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutBusinessUnitSuppliersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    contactInfo?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutBusinessUnitSuppliersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutBusinessUnitSuppliersInput, SupplierUncheckedCreateWithoutBusinessUnitSuppliersInput>
  }

  export type BusinessUnitUpsertWithoutBusinessUnitSuppliersInput = {
    update: XOR<BusinessUnitUpdateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitSuppliersInput>
    create: XOR<BusinessUnitCreateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSuppliersInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitSuppliersInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutBusinessUnitSuppliersInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitSuppliersInput>
  }

  export type BusinessUnitUpdateWithoutBusinessUnitSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBusinessUnitsNestedInput
    users?: userUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutBusinessUnitSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type SupplierUpsertWithoutBusinessUnitSuppliersInput = {
    update: XOR<SupplierUpdateWithoutBusinessUnitSuppliersInput, SupplierUncheckedUpdateWithoutBusinessUnitSuppliersInput>
    create: XOR<SupplierCreateWithoutBusinessUnitSuppliersInput, SupplierUncheckedCreateWithoutBusinessUnitSuppliersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutBusinessUnitSuppliersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutBusinessUnitSuppliersInput, SupplierUncheckedUpdateWithoutBusinessUnitSuppliersInput>
  }

  export type SupplierUpdateWithoutBusinessUnitSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySuppliers?: CompanySupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutBusinessUnitSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CompanyCreateWithoutCompanyBanquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCompany?: CompanyCreateNestedOneWithoutSubCompaniesInput
    subCompanies?: CompanyCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitCreateNestedManyWithoutCompanyInput
    users?: userCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanyBanquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    parentCompanyId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subCompanies?: CompanyUncheckedCreateNestedManyWithoutParentCompanyInput
    businessUnits?: BusinessUnitUncheckedCreateNestedManyWithoutCompanyInput
    users?: userUncheckedCreateNestedManyWithoutCompanyInput
    companySuppliers?: CompanySupplierUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanyBanquesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyBanquesInput, CompanyUncheckedCreateWithoutCompanyBanquesInput>
  }

  export type BanqueCreateWithoutCompaniesInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountCreateNestedManyWithoutBanqueInput
  }

  export type BanqueUncheckedCreateWithoutCompaniesInput = {
    id?: string
    nom: string
    codeSwift: string
    codeGuichet?: string | null
    adresse: string
    contactInfo?: string | null
    establishment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesCredit?: LigneCreditUncheckedCreateNestedManyWithoutBanqueInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutBanqueInput
  }

  export type BanqueCreateOrConnectWithoutCompaniesInput = {
    where: BanqueWhereUniqueInput
    create: XOR<BanqueCreateWithoutCompaniesInput, BanqueUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutCompanyBanquesInput = {
    update: XOR<CompanyUpdateWithoutCompanyBanquesInput, CompanyUncheckedUpdateWithoutCompanyBanquesInput>
    create: XOR<CompanyCreateWithoutCompanyBanquesInput, CompanyUncheckedCreateWithoutCompanyBanquesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyBanquesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyBanquesInput, CompanyUncheckedUpdateWithoutCompanyBanquesInput>
  }

  export type CompanyUpdateWithoutCompanyBanquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCompany?: CompanyUpdateOneWithoutSubCompaniesNestedInput
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanyBanquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    parentCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BanqueUpsertWithoutCompaniesInput = {
    update: XOR<BanqueUpdateWithoutCompaniesInput, BanqueUncheckedUpdateWithoutCompaniesInput>
    create: XOR<BanqueCreateWithoutCompaniesInput, BanqueUncheckedCreateWithoutCompaniesInput>
    where?: BanqueWhereInput
  }

  export type BanqueUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: BanqueWhereInput
    data: XOR<BanqueUpdateWithoutCompaniesInput, BanqueUncheckedUpdateWithoutCompaniesInput>
  }

  export type BanqueUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutBanqueNestedInput
  }

  export type BanqueUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    codeSwift?: StringFieldUpdateOperationsInput | string
    codeGuichet?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    establishment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesCredit?: LigneCreditUncheckedUpdateManyWithoutBanqueNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutBanqueNestedInput
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
    user: userCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type userCreateWithoutUserRolesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    businessUnit?: BusinessUnitCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserRolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserRolesInput, userUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type userUpsertWithoutUserRolesInput = {
    update: XOR<userUpdateWithoutUserRolesInput, userUncheckedUpdateWithoutUserRolesInput>
    create: XOR<userCreateWithoutUserRolesInput, userUncheckedCreateWithoutUserRolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserRolesInput, userUncheckedUpdateWithoutUserRolesInput>
  }

  export type userUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    businessUnit?: BusinessUnitUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    resource: string
    action: string
    scope?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    resource: string
    action: string
    scope?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    businessUnit?: BusinessUnitCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAuditLogsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAuditLogsInput, userUncheckedCreateWithoutAuditLogsInput>
  }

  export type userUpsertWithoutAuditLogsInput = {
    update: XOR<userUpdateWithoutAuditLogsInput, userUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<userCreateWithoutAuditLogsInput, userUncheckedCreateWithoutAuditLogsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAuditLogsInput, userUncheckedUpdateWithoutAuditLogsInput>
  }

  export type userUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    businessUnit?: BusinessUnitUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkflowStepCreateWithoutTemplateInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementCreateNestedManyWithoutWorkflowStepInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepUncheckedCreateWithoutTemplateInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutWorkflowStepInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutWorkflowStepInput
  }

  export type WorkflowStepCreateOrConnectWithoutTemplateInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput>
  }

  export type WorkflowStepCreateManyTemplateInputEnvelope = {
    data: WorkflowStepCreateManyTemplateInput | WorkflowStepCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type EngagementCreateWithoutWorkflowTemplateInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowStep?: WorkflowStepCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateWithoutWorkflowTemplateInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowStepId?: string | null
    parentEngagementId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementCreateOrConnectWithoutWorkflowTemplateInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput>
  }

  export type EngagementCreateManyWorkflowTemplateInputEnvelope = {
    data: EngagementCreateManyWorkflowTemplateInput | EngagementCreateManyWorkflowTemplateInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepUpsertWithWhereUniqueWithoutTemplateInput = {
    where: WorkflowStepWhereUniqueInput
    update: XOR<WorkflowStepUpdateWithoutTemplateInput, WorkflowStepUncheckedUpdateWithoutTemplateInput>
    create: XOR<WorkflowStepCreateWithoutTemplateInput, WorkflowStepUncheckedCreateWithoutTemplateInput>
  }

  export type WorkflowStepUpdateWithWhereUniqueWithoutTemplateInput = {
    where: WorkflowStepWhereUniqueInput
    data: XOR<WorkflowStepUpdateWithoutTemplateInput, WorkflowStepUncheckedUpdateWithoutTemplateInput>
  }

  export type WorkflowStepUpdateManyWithWhereWithoutTemplateInput = {
    where: WorkflowStepScalarWhereInput
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyWithoutTemplateInput>
  }

  export type WorkflowStepScalarWhereInput = {
    AND?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    OR?: WorkflowStepScalarWhereInput[]
    NOT?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowTemplateId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    code?: StringFilter<"WorkflowStep"> | string
    label?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredFields?: JsonNullableFilter<"WorkflowStep">
    requiredDocuments?: JsonNullableFilter<"WorkflowStep">
    requiresApproval?: BoolFilter<"WorkflowStep"> | boolean
    approvalRoles?: JsonNullableFilter<"WorkflowStep">
    triggerAction?: StringNullableFilter<"WorkflowStep"> | string | null
    icon?: StringNullableFilter<"WorkflowStep"> | string | null
    color?: StringNullableFilter<"WorkflowStep"> | string | null
    allowedRoles?: JsonNullableFilter<"WorkflowStep">
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
  }

  export type EngagementUpsertWithWhereUniqueWithoutWorkflowTemplateInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutWorkflowTemplateInput, EngagementUncheckedUpdateWithoutWorkflowTemplateInput>
    create: XOR<EngagementCreateWithoutWorkflowTemplateInput, EngagementUncheckedCreateWithoutWorkflowTemplateInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutWorkflowTemplateInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutWorkflowTemplateInput, EngagementUncheckedUpdateWithoutWorkflowTemplateInput>
  }

  export type EngagementUpdateManyWithWhereWithoutWorkflowTemplateInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutWorkflowTemplateInput>
  }

  export type WorkflowTemplateCreateWithoutStepsInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementCreateNestedManyWithoutWorkflowTemplateInput
  }

  export type WorkflowTemplateUncheckedCreateWithoutStepsInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    icon?: string | null
    color?: string | null
    displayOrder?: number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutWorkflowTemplateInput
  }

  export type WorkflowTemplateCreateOrConnectWithoutStepsInput = {
    where: WorkflowTemplateWhereUniqueInput
    create: XOR<WorkflowTemplateCreateWithoutStepsInput, WorkflowTemplateUncheckedCreateWithoutStepsInput>
  }

  export type EngagementCreateWithoutWorkflowStepInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ligneCredit?: LigneCreditCreateNestedOneWithoutEngagementsInput
    workflowTemplate?: WorkflowTemplateCreateNestedOneWithoutEngagementsInput
    parentEngagement?: EngagementCreateNestedOneWithoutChildEngagementsInput
    childEngagements?: EngagementCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionCreateNestedManyWithoutEngagementInput
  }

  export type EngagementUncheckedCreateWithoutWorkflowStepInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    parentEngagementId?: string | null
    childEngagements?: EngagementUncheckedCreateNestedManyWithoutParentEngagementInput
    stepCompletions?: StepCompletionUncheckedCreateNestedManyWithoutEngagementInput
  }

  export type EngagementCreateOrConnectWithoutWorkflowStepInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput>
  }

  export type EngagementCreateManyWorkflowStepInputEnvelope = {
    data: EngagementCreateManyWorkflowStepInput | EngagementCreateManyWorkflowStepInput[]
    skipDuplicates?: boolean
  }

  export type StepCompletionCreateWithoutWorkflowStepInput = {
    id?: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    engagement: EngagementCreateNestedOneWithoutStepCompletionsInput
    user?: userCreateNestedOneWithoutStepCompletionsInput
  }

  export type StepCompletionUncheckedCreateWithoutWorkflowStepInput = {
    id?: string
    engagementId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type StepCompletionCreateOrConnectWithoutWorkflowStepInput = {
    where: StepCompletionWhereUniqueInput
    create: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput>
  }

  export type StepCompletionCreateManyWorkflowStepInputEnvelope = {
    data: StepCompletionCreateManyWorkflowStepInput | StepCompletionCreateManyWorkflowStepInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowTemplateUpsertWithoutStepsInput = {
    update: XOR<WorkflowTemplateUpdateWithoutStepsInput, WorkflowTemplateUncheckedUpdateWithoutStepsInput>
    create: XOR<WorkflowTemplateCreateWithoutStepsInput, WorkflowTemplateUncheckedCreateWithoutStepsInput>
    where?: WorkflowTemplateWhereInput
  }

  export type WorkflowTemplateUpdateToOneWithWhereWithoutStepsInput = {
    where?: WorkflowTemplateWhereInput
    data: XOR<WorkflowTemplateUpdateWithoutStepsInput, WorkflowTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type WorkflowTemplateUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUpdateManyWithoutWorkflowTemplateNestedInput
  }

  export type WorkflowTemplateUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutWorkflowTemplateNestedInput
  }

  export type EngagementUpsertWithWhereUniqueWithoutWorkflowStepInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutWorkflowStepInput, EngagementUncheckedUpdateWithoutWorkflowStepInput>
    create: XOR<EngagementCreateWithoutWorkflowStepInput, EngagementUncheckedCreateWithoutWorkflowStepInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutWorkflowStepInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutWorkflowStepInput, EngagementUncheckedUpdateWithoutWorkflowStepInput>
  }

  export type EngagementUpdateManyWithWhereWithoutWorkflowStepInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutWorkflowStepInput>
  }

  export type StepCompletionUpsertWithWhereUniqueWithoutWorkflowStepInput = {
    where: StepCompletionWhereUniqueInput
    update: XOR<StepCompletionUpdateWithoutWorkflowStepInput, StepCompletionUncheckedUpdateWithoutWorkflowStepInput>
    create: XOR<StepCompletionCreateWithoutWorkflowStepInput, StepCompletionUncheckedCreateWithoutWorkflowStepInput>
  }

  export type StepCompletionUpdateWithWhereUniqueWithoutWorkflowStepInput = {
    where: StepCompletionWhereUniqueInput
    data: XOR<StepCompletionUpdateWithoutWorkflowStepInput, StepCompletionUncheckedUpdateWithoutWorkflowStepInput>
  }

  export type StepCompletionUpdateManyWithWhereWithoutWorkflowStepInput = {
    where: StepCompletionScalarWhereInput
    data: XOR<StepCompletionUpdateManyMutationInput, StepCompletionUncheckedUpdateManyWithoutWorkflowStepInput>
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type StepCompletionCreateManyUserInput = {
    id?: string
    engagementId: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StepCompletionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: EngagementUpdateOneRequiredWithoutStepCompletionsNestedInput
    workflowStep?: WorkflowStepUpdateOneRequiredWithoutStepCompletionsNestedInput
  }

  export type StepCompletionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LigneCreditCreateManyBanqueInput = {
    id?: string
    no: string
    description?: string | null
    autorisationNo: string
    bankAccountNo: string
    montantPlafond: number
    montantDevise: string
    taux: number
    commitmentCommissionRate: number
    estimatedOutstanding: number
    consumption: number
    outstanding: number
    startDate: Date | string
    expiryDate: Date | string
    renewalDate?: Date | string | null
    statut: string
    responsibilityCenter?: string | null
    seuilAvanceSurStock: number
    seuilAvanceSurFacture: number
    seuilEscompte: number
    seuilLC: number
    seuilObligtDouane: number
    seuilCautionAdmin: number
    seuilDcvrtMobile: number
    seuilTrsfrLibre: number
    seuilLeasing: number
    seuilCMT: number
    seuilFraisMission: number
    seuilLCAS: number
    avanceSurStock: number
    avanceFacture: number
    escompte: number
    obligatDouane: number
    cautionAdmin: number
    dcvrtMobile: number
    trsfrLibre: number
    leasing: number
    CMT: number
    fraisMission: number
    LCAS: number
    faciliteCaissier: number
    typeFinancement: string
    maxConsumptionTolerance: number
    minConsumptionTolerance: number
    noSeries: string
    refinancing: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyBanqueCreateManyBanqueInput = {
    id?: string
    companyId: string
    createdAt?: Date | string
  }

  export type BankAccountCreateManyBanqueInput = {
    id?: string
    accountNumber: string
    keyAccount: string
    currency: string
    rib?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: string
    updatedBy: string
    deletedBy?: string | null
  }

  export type LigneCreditUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garanties?: GarantieUpdateManyWithoutLigneCreditNestedInput
    engagements?: EngagementUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditUncheckedUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garanties?: GarantieUncheckedUpdateManyWithoutLigneCreditNestedInput
    engagements?: EngagementUncheckedUpdateManyWithoutLigneCreditNestedInput
  }

  export type LigneCreditUncheckedUpdateManyWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autorisationNo?: StringFieldUpdateOperationsInput | string
    bankAccountNo?: StringFieldUpdateOperationsInput | string
    montantPlafond?: FloatFieldUpdateOperationsInput | number
    montantDevise?: StringFieldUpdateOperationsInput | string
    taux?: FloatFieldUpdateOperationsInput | number
    commitmentCommissionRate?: FloatFieldUpdateOperationsInput | number
    estimatedOutstanding?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    outstanding?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    responsibilityCenter?: NullableStringFieldUpdateOperationsInput | string | null
    seuilAvanceSurStock?: FloatFieldUpdateOperationsInput | number
    seuilAvanceSurFacture?: FloatFieldUpdateOperationsInput | number
    seuilEscompte?: FloatFieldUpdateOperationsInput | number
    seuilLC?: FloatFieldUpdateOperationsInput | number
    seuilObligtDouane?: FloatFieldUpdateOperationsInput | number
    seuilCautionAdmin?: FloatFieldUpdateOperationsInput | number
    seuilDcvrtMobile?: FloatFieldUpdateOperationsInput | number
    seuilTrsfrLibre?: FloatFieldUpdateOperationsInput | number
    seuilLeasing?: FloatFieldUpdateOperationsInput | number
    seuilCMT?: FloatFieldUpdateOperationsInput | number
    seuilFraisMission?: FloatFieldUpdateOperationsInput | number
    seuilLCAS?: FloatFieldUpdateOperationsInput | number
    avanceSurStock?: FloatFieldUpdateOperationsInput | number
    avanceFacture?: FloatFieldUpdateOperationsInput | number
    escompte?: FloatFieldUpdateOperationsInput | number
    obligatDouane?: FloatFieldUpdateOperationsInput | number
    cautionAdmin?: FloatFieldUpdateOperationsInput | number
    dcvrtMobile?: FloatFieldUpdateOperationsInput | number
    trsfrLibre?: FloatFieldUpdateOperationsInput | number
    leasing?: FloatFieldUpdateOperationsInput | number
    CMT?: FloatFieldUpdateOperationsInput | number
    fraisMission?: FloatFieldUpdateOperationsInput | number
    LCAS?: FloatFieldUpdateOperationsInput | number
    faciliteCaissier?: FloatFieldUpdateOperationsInput | number
    typeFinancement?: StringFieldUpdateOperationsInput | string
    maxConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    minConsumptionTolerance?: FloatFieldUpdateOperationsInput | number
    noSeries?: StringFieldUpdateOperationsInput | string
    refinancing?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyBanquesNestedInput
  }

  export type CompanyBanqueUncheckedUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueUncheckedUpdateManyWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankAccountUncheckedUpdateWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankAccountUncheckedUpdateManyWithoutBanqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    keyAccount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    rib?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GarantieCreateManyLigneCreditInput = {
    id?: string
    type: string
    montant: number
    dateExpiration: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type EngagementCreateManyLigneCreditInput = {
    id?: string
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
    parentEngagementId?: string | null
  }

  export type GarantieUpdateWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GarantieUncheckedUpdateWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GarantieUncheckedUpdateManyWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementUpdateWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateManyWithoutLigneCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementCreateManyParentEngagementInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    workflowStepId?: string | null
  }

  export type StepCompletionCreateManyEngagementInput = {
    id?: string
    workflowStepId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type EngagementUpdateWithoutParentEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutParentEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateManyWithoutParentEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workflowStep?: WorkflowStepUpdateOneRequiredWithoutStepCompletionsNestedInput
    user?: userUpdateOneWithoutStepCompletionsNestedInput
  }

  export type StepCompletionUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUncheckedUpdateManyWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowStepId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateManyParentCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    address?: string | null
    contactInfo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUnitCreateManyCompanyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userCreateManyCompanyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    businessUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySupplierCreateManyCompanyInput = {
    id?: string
    supplierId: string
    createdAt?: Date | string
  }

  export type CompanyBanqueCreateManyCompanyInput = {
    id?: string
    banqueId: string
    createdAt?: Date | string
  }

  export type CompanyUpdateWithoutParentCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUpdateManyWithoutCompanyNestedInput
    users?: userUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutParentCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCompanies?: CompanyUncheckedUpdateManyWithoutParentCompanyNestedInput
    businessUnits?: BusinessUnitUncheckedUpdateManyWithoutCompanyNestedInput
    users?: userUncheckedUpdateManyWithoutCompanyNestedInput
    companySuppliers?: CompanySupplierUncheckedUpdateManyWithoutCompanyNestedInput
    companyBanques?: CompanyBanqueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutParentCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSuppliers?: BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnit?: BusinessUnitUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutCompanySuppliersNestedInput
  }

  export type CompanySupplierUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banque?: BanqueUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyBanqueUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBanqueUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyBusinessUnitInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    role?: string
    status?: string
    emailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastLoginAt?: Date | string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUnitSupplierCreateManyBusinessUnitInput = {
    id?: string
    supplierId: string
    createdAt?: Date | string
  }

  export type userUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput
  }

  export type BusinessUnitSupplierUncheckedUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierCreateManySupplierInput = {
    id?: string
    companyId: string
    createdAt?: Date | string
  }

  export type BusinessUnitSupplierCreateManySupplierInput = {
    id?: string
    businessUnitId: string
    createdAt?: Date | string
  }

  export type CompanySupplierUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanySuppliersNestedInput
  }

  export type CompanySupplierUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSuppliersNestedInput
  }

  export type BusinessUnitSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    companyId?: string | null
    businessUnitId?: string | null
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    businessUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateManyTemplateInput = {
    id?: string
    stepOrder: number
    code: string
    label: string
    description?: string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: string | null
    icon?: string | null
    color?: string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementCreateManyWorkflowTemplateInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowStepId?: string | null
    parentEngagementId?: string | null
  }

  export type WorkflowStepUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUpdateManyWithoutWorkflowStepNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutWorkflowStepNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutWorkflowStepNestedInput
  }

  export type WorkflowStepUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredFields?: NullableJsonNullValueInput | InputJsonValue
    requiredDocuments?: NullableJsonNullValueInput | InputJsonValue
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvalRoles?: NullableJsonNullValueInput | InputJsonValue
    triggerAction?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementUpdateWithoutWorkflowTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowStep?: WorkflowStepUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutWorkflowTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateManyWithoutWorkflowTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStepId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementCreateManyWorkflowStepInput = {
    id?: string
    ligneCreditId?: string | null
    typeFinancement: string
    montant?: number | null
    devise?: string | null
    dateEngagement?: Date | string | null
    dateEcheance?: Date | string | null
    statut: string
    referenceDossier: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowTemplateId?: string | null
    parentEngagementId?: string | null
  }

  export type StepCompletionCreateManyWorkflowStepInput = {
    id?: string
    engagementId: string
    fieldData?: string | null
    documents?: string | null
    completedBy?: string | null
    completedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
  }

  export type EngagementUpdateWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligneCredit?: LigneCreditUpdateOneWithoutEngagementsNestedInput
    workflowTemplate?: WorkflowTemplateUpdateOneWithoutEngagementsNestedInput
    parentEngagement?: EngagementUpdateOneWithoutChildEngagementsNestedInput
    childEngagements?: EngagementUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
    childEngagements?: EngagementUncheckedUpdateManyWithoutParentEngagementNestedInput
    stepCompletions?: StepCompletionUncheckedUpdateManyWithoutEngagementNestedInput
  }

  export type EngagementUncheckedUpdateManyWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligneCreditId?: NullableStringFieldUpdateOperationsInput | string | null
    typeFinancement?: StringFieldUpdateOperationsInput | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    devise?: NullableStringFieldUpdateOperationsInput | string | null
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    referenceDossier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    parentEngagementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUpdateWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: EngagementUpdateOneRequiredWithoutStepCompletionsNestedInput
    user?: userUpdateOneWithoutStepCompletionsNestedInput
  }

  export type StepCompletionUncheckedUpdateWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StepCompletionUncheckedUpdateManyWithoutWorkflowStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    fieldData?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanqueCountOutputTypeDefaultArgs instead
     */
    export type BanqueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanqueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneCreditCountOutputTypeDefaultArgs instead
     */
    export type LigneCreditCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneCreditCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EngagementCountOutputTypeDefaultArgs instead
     */
    export type EngagementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EngagementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessUnitCountOutputTypeDefaultArgs instead
     */
    export type BusinessUnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessUnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowTemplateCountOutputTypeDefaultArgs instead
     */
    export type WorkflowTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepCountOutputTypeDefaultArgs instead
     */
    export type WorkflowStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanqueDefaultArgs instead
     */
    export type BanqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankAccountDefaultArgs instead
     */
    export type BankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneCreditDefaultArgs instead
     */
    export type LigneCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneCreditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GarantieDefaultArgs instead
     */
    export type GarantieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GarantieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EngagementDefaultArgs instead
     */
    export type EngagementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EngagementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StepCompletionDefaultArgs instead
     */
    export type StepCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StepCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SwiftMessageDefaultArgs instead
     */
    export type SwiftMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SwiftMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentImportDefaultArgs instead
     */
    export type DocumentImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentImportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessUnitDefaultArgs instead
     */
    export type BusinessUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessUnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanySupplierDefaultArgs instead
     */
    export type CompanySupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanySupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessUnitSupplierDefaultArgs instead
     */
    export type BusinessUnitSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessUnitSupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyBanqueDefaultArgs instead
     */
    export type CompanyBanqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyBanqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowTemplateDefaultArgs instead
     */
    export type WorkflowTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepDefaultArgs instead
     */
    export type WorkflowStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}